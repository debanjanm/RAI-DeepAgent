{
  "title": "On the Viability of Open-Source Financial Rails: Economic Security of\n  Permissionless Consensus",
  "sections": [
    {
      "section_id": 0,
      "text": "## Abstract\n\nBitcoin demonstrated the possibility of a financial ledger that operates without the need for a trusted central authority. However, concerns persist regarding its security and considerable energy consumption. We assess the consensus protocols that underpin Bitcoin's functionality, questioning whether they can ensure economically meaningful security while maintaining a permissionless design that allows free entry of operators. We answer this affirmatively by constructing a protocol that guarantees economic security and preserves Bitcoin's permissionless design. This protocol's security does not depend on monetary payments to miners or immense electricity consumption, which our analysis suggests are ineffective. Our framework integrates economic theory with distributed systems theory, and formalizes the role of the protocol's user community.\n\n[^0]\n[^0]:    *University of Chicago Booth School of Business, Jacob.Leshno@ChicagoBooth.edu.\n    ${ }^{\\dagger}$ Tel Aviv University and Cornell Tech, Computer Science, rafaelp@tau.ac.il.\n    ${ }^{\\ddagger}$ Carnegie Mellon University, Computer Science and Electrical and Computer Engineering, runting@gmail.com.\n    ${ }^{\\S}$ This work is supported by NSF grant number 2212747 and by the Robert H. Topel Faculty Research Fund at the University of Chicago Booth School of Business. We thank Srivatsan Sridhar and Dionyziz Zindros for their insightful and detailed comments. We thank Ittai Abraham, Garth Baughman, Dirk Bergemann, Eric Budish, Francesca Carapella, Alex Frankel, Rod Garratt, Niels Gormsen, Emir Kamenica, Anil Kashyap, Andrew Lewis-Pye, Yueran Ma, Dahlia Malkhi, Harry Pei, Tim Roughgarden, Marciano Siniscalchi, Ertem Nusret Tas, David Tse, Maarten van Oordt, Luigi Zingales, and seminar participants at the ACM SIGecom Winter Meeting, the Federal Reserve Board of Governors, Market Design NBER, a16z Research Lab, Stanford, Princeton, the Northwestern Conference on the Interface between Computer Science and Economics, the London Symposium on Information Theory, and the Simons Institute for the Theory of Computing. All errors are our own.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 1,
      "text": "# 1 Introduction \n\nA long-standing literature has demonstrated the critical role of the financial system in fostering economic growth (Schumpeter, 1911, Rajan and Zingales, 1998), and the importance of a trusted financial system that protects against fraud and deception (La Porta et al., 2006, Guiso et al., 2004, 2008). While acknowledging its benefits, economists have raised concerns regarding the current state of the financial system, particularly highlighting inefficiencies and rent-seeking behavior (Greenwood and Scharfstein, 2013, Admati and Hellwig, 2014, Philippon, 2015). Payment-processing firms, the operators of the rails of the financial system, collected global revenues of 2.2 trillion in 2022 (McKinsey and Company, 2023), and are frequently subject to regulatory scrutiny and antitrust litigation aimed at curbing their market power. ${ }^{1}$\n\nNakamoto (2008) showed the possibility of an open-source alternative. It introduced Bitcoin, the first functioning payment system ${ }^{2}$ operated by anonymous interchangeable computer servers (known as nodes or miners) that can freely enter and exit the network. Bitcoin's economic design, particularly the free entry of its miners, shields users from monopoly pricing and eliminates the pricing power of the system's operators. ${ }^{3}$ This economic design was made possible by a technological breakthrough: the Nakamoto permissionless consensus protocol, which coordinates a network of untrusted participants who collectively maintain a distributed ledger. In other words, the Nakamoto consensus protocol creates a record-keeping service without a trusted recordkeeper. The potential of such \"decentralized\" consensus protocols sparked significant public interest and extensive research. Recently, the Web3 movement aspired to leverage this technology to curtail the market power of Big Tech platforms and develop open-source alternatives. ${ }^{4}$\n\n[^0]\n[^0]:    ${ }^{1}$ Recent high-profile cases include the U.S. vs. American Express (DOJ, 2010), the European Commission imposing interchange fee regulation (European Parliament and Council, 2015), and the DOJ blocking Visa's acquisition of Plaid (DOJ, 2020). For lists of antitrust lawsuits and regulatory actions, see Table 5 in Herkenhoff and Raveendranathan (2020) and Hayashi and Maniff (2019), respectively.\n    ${ }^{2}$ Bitcoin offers the basic functionality of a payment system. Ownership of funds is verified through cryptography. Standard accounting principles, such as ensuring that each transaction's credits equal its debits, are enforced through an open and auditable ledger.\n    ${ }^{3}$ Huberman et al. (2021) show that the free entry of miners in Bitcoin's Nakamoto protocol prevents any miner (even large ones) from profitably affecting transaction fees. Empirical work by Easley et al. (2019) and Donmez and Karaivanov (2022) supports these findings.\n    ${ }^{4}$ See Dixon (2024) for an exposition of these ideas and historical precedents, including the success of the open-source operating system Linux and the community-controlled Domain Name System (the internet's \"phone book\"). For media coverage, see https://www.wired.com/story/web3-paradise-crypto-arcade/ and https://www.wired.com/story/how-blockchain-can-wrest-the-internet-from-corporations/ (accessed August 2024).\n\nYet, despite the significant attention cryptocurrencies have garnered, mainstream adoption remains limited (BIS, 2023). ${ }^{5}$ The issue extends beyond the adoption challenges faced by any new technology. There are fundamental questions about Bitcoin's design and the viability of any permissionless consensus protocols for mainstream financial applications. In particular, Bitcoin's Nakamoto protocol is vulnerable to corrupt majority attacks (also called $51 \\%$ attacks or double-spending). ${ }^{6}$ This vulnerability has attracted much attention from practitioners, economists, and computer scientists, questioning whether permissionless consensus protocols can be made secure at a reasonable cost. ${ }^{7}$\n\nWe approach this problem as an economic design problem, asking whether it is possible to design a protocol that has the free entry properties that are provided by a permissionless design while also providing a security guarantee that is economically meaningful.\n\nIn this paper, we theoretically evaluate whether consensus protocols can provide economically meaningful security while preserving a permissionless design that allows for the free entry of operators. Our primary finding is that a permissionless and economically secure protocol is indeed feasible. We demonstrate this feasibility by constructing a secure modification of Bitcoin's Nakamoto protocol that maintains its permissionless design. Notably, our protocol adopts a different approach to security; its security does not depend on monetary incentives for miners or their excessive energy consumption, which we identify as ineffective.\n\nTo perform our analysis, we use a framework that integrates economic theory with distributed systems theory, both components being necessary and complementary. The distributed systems model is essential for analyzing general protocols, user behaviors, and attacks. Additionally, economic incentives depend on the system's ability to detect and punish deviations from prescribed behaviors. The distributed systems model enables us to assess the knowledge of each participant and determine whether an attack is detectable. The economic model allows us to account for attacks that operate or incentivize nodes within the system, and it provides a meaningful quantification of such security vulnerabilities in terms\n\n[^0]\n[^0]:    ${ }^{5}$ Makarov and Schoar (2021) find that much of cryptocurrency user activity has been linked to speculative behavior or black market transactions. Alvarez et al. (2023) find limited adoption for payments. Auer et al. (2023) analyze Bitcoin adoption and find that financial speculation drives entry of new users. Yermack (2019) evaluates the technological promise but concludes that \"significant disruptions to the legacy financial system still appear to be years away.\" Critiques in the press are common, see, for example, https://www.forbes.com/sites/yayafanusie/2021/01/01/stop-saying-you-want-to-bank-the-unbanked/, and https://www.wired.com/story/whats-blockchain-good-for-not-much/.\n    ${ }^{6}$ In a corrupt majority attack, a malicious actor can create a manipulated ledger (which reverts transactions) and exploit the consensus protocol to get all others to adopt the manipulated ledger (see Section 3).\n    ${ }^{7}$ Budish (2022) critiques Bitcoin's Nakamoto protocol for its vulnerability to double-spend attacks. Shanaev et al. (2019) provides a list of successful double-spend attacks of blockchains that utilize the Nakamoto protocol. See the literature review below for further details.\n\nof the cost of the attack.\nWe present a definition of economic security for general consensus protocols that captures whether users of the system are protected against deception or fraud in the face of general attacks. Consider a merchant who wishes to receive payment. The merchant wants to ensure that the payment is valid, i.e., the credit is recognized by others and can be spent. In a digital payment system, the merchant relies on a payment terminal to determine whether the payment is valid. In distributed systems terminology, the merchant problem is achieving consensus on the validity of the payment. If the distributed systems property consistency is satisfied, the merchant's terminal is guaranteed to be in agreement with the rest of the network, and the merchant cannot be deceived. Therefore, we define the economic security of a distributed ledger as the economic cost required to violate consistency (Section 2 provides background and motivation for the definition). This definition captures the corrupt majority attack mentioned above, ${ }^{8}$ as well as other attacks. ${ }^{9}$\n\nWe analyze Bitcoin's Nakamoto protocol to highlight challenges in securing permissionless protocols. We evaluate the economic security of Bitcoin's Nakamoto protocol in two economic environments, selected to underscore the deficiencies in incentives for securing permissionless protocols. Two shortcomings compromise the system's security, regardless of the level of mining rewards. First, the protocol fails to detect attacks. Malicious miners can generate an alternative ledger and cause the system to adopt it, deleting transactions and violating consistency. The protocol does not recognize that this alternative ledger is a product of malicious behavior, treating these miners the same as honest ones (we explain the protocol's rationale in Section 3.3). In particular, the protocol fails to punish such attackers and does not provide incentives to disincentivize attacks. Second, even if attacks prompt an external response, such as a collapse in the exchange rate, the resulting harm affects all miners, irrespective of their involvement in the attack. If miners are small, the tragedy of the commons can arise. Together, these deficiencies underscore a broader challenge in relying on incentives to secure permissionless protocols.\n\nThe absence of attacks on Bitcoin and Ethereum so far suggests that other factors deter attacks. We highlight one in particular: the community response. Recall that the protocol is a record keeper that maintains a ledger. An attack can cause the nodes to adopt a corrupted ledger. However, if the community detects the ledger is corrupted, they may manually override the nodes to restore the correct ledger. This community response is powerful, as it\n\n[^0]\n[^0]:    ${ }^{8} \\mathrm{~A}$ double-spend attack that deceives the merchant constitutes a consistency violation.\n    ${ }^{9}$ For example, an attacker can potentially profit from rewriting old parts of the ledger to \"retroactively\" buy an option after its expiration. See Appendix C for further detail.\n\neffectively nullifies the attack and serves as a deterrent against future attacks. However, this response requires that the community be able to detect attacks and maintain agreement on the correct ledger.\n\nThe community's response suggests an alternative approach to protocol security. Rather than relying solely on incentives and monetary rewards, a protocol could achieve security by automating and integrating a community-like response into its design. That is, the protocol should maintain agreement on the correct ledger. Instead of allowing attacks to corrupt the ledger and subsequently restoring it, the protocol should enable all nodes to preserve the correct state and ignore attacks that attempt to corrupt it. By considering a version of the community response within a formal protocol, we can develop alternative protocols and rigorously evaluate the capabilities of the community.\n\nWe demonstrate the feasibility of a permissionless consensus protocol that is economically secure by constructing such a protocol. Our protocol, which we name Stubborn Nakamoto, is a modification of Bitcoin's Nakamoto protocol. It is designed for the same environment as the Nakamoto protocol (namely, synchrony with late joiners). In the absence of an attack, the Stubborn Nakamoto protocol and the Nakamoto protocol operate essentially identically. Stubborn Nakamoto preserves the free entry of nodes. All nodes serve equivalent roles, remain anonymous, and can join or leave at any time. We prove that the Stubborn Nakamoto protocol is economically secure, showing that it guarantees consistency even against an attacker with unlimited computational power and economic resources. In particular, corrupt majority attacks (such as double-spending) are rendered impossible under the Stubborn Nakamoto protocol.\n\nThe Stubborn Nakamoto protocol differs from the standard Nakamoto protocol in two key aspects. First, it specifies an explicit condition under which a node finalizes a record in its ledger. Once a record is finalized, the node never reverts it. Second, the Stubborn Nakamoto protocol instructs nodes to wait before finalizing a record. This delay allows nodes to determine whether any other node observes an inconsistent ledger and ensures that the ledger is updated only when the node is certain that no conflict is possible. Together, these measures ensure that if a node finalizes a record, all other nodes are in agreement.\n\nSome trade-offs in protocol design are inevitable. Impossibility results show that no protocol can make progress (i.e., add records to the ledger) and guarantee security when attacked by a sufficiently powerful adversary. ${ }^{10}$ Our Stubborn Nakamoto protocol prioritizes security. The protocol is able to detect whether it is impossible to securely make progress,\n\n[^0]\n[^0]:    ${ }^{10}$ See Pass and Shi (2017a), Lewis-Pye and Roughgarden (2023), and Section 4.4.\n\nand halts progress to guarantee security. We show that the Stubborn Nakamoto protocol can recover from attacks with external help from the community, which we model as a recovery oracle. We prove that such external help is necessary and show that the required recovery oracle can be plausibly implemented.\n\nOur results show the feasibility of an economically secure ledger that operates without the need for a trusted record keeper. ${ }^{11}$ It protects its users from monopoly's harm, allows free entry and exit of its operators, and renders its operators exchangeable. The analysis offers an alternative explanation for Bitcoin's security, suggesting a broader perspective that includes the role of the community. Attacks that deceive the protocol may be rendered ineffective if they can be detected and reversed by the community. The security of a ledger, therefore, may have little to do with the amount of resources spent on it. Instead, security is ensured by establishing agreement among all participants.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 2,
      "text": "# 1.1 Related work \n\nThis paper builds on work in economics and in distributed systems, bringing together elements of both.\n\nWe build on a rich literature in economics that studies double-spend attacks on Bitcoin's Nakamoto protocol, including Budish (2022), Auer (2019), Bonneau (2016), Chiu and Koeppl (2022), Moroz et al. (2020), Garratt and van Oordt (2023), Pagnotta (2022), and Gans and Halaburda (2024). This literature focuses on the double-spend attack against Bitcoin's Nakamoto protocol. Our framework allows us to give a definition of economic security that considers general attacks and to analyze alternative protocol designs. Abraham et al. (2006), Abadi and Brunnermeier (2022), Garay et al. (2013), Biais et al. (2019), Badertscher et al. (2021), and Halaburda et al. (2021) offer economic models of consensus protocols. See Halaburda et al. (2022) for a review.\n\nEyal and Sirer (2018) demonstrate that Bitcoin miners can earn higher rewards through strategic behavior. A significant body of literature followed exploring strategic actions in blockchain protocols, including Kiayias et al. (2016), Carlsten et al. (2016), Cai et al. (2024). Such manipulations do not compromise the protocol's consistency, ${ }^{12}$ and are therefore beyond\n\n[^0]\n[^0]:    ${ }^{11}$ This paper focuses on the technology's ability to offer a record-keeping service, that is, to maintain a ledger, as record-keeping is a core service of any financial system, and payment systems in particular (famously, Kocherlakota (1998) reasons that \"Money is Memory\"). See Section 6 for a discussion of additional challenges.\n    ${ }^{12}$ Because the Nakamoto protocol guarantees consistency under honest majority, deviation by small miners cannot lead to consistency violations.\n\nof the scope of this paper.\nOur work builds on the seminal work in distributed systems. We adopt the modeling approach established in this literature in works such as Pease et al. (1980), Lamport et al. (1982), Dwork et al. (1988), Fischer et al. (1985). Our work also builds on more recent developments in distributed systems that provide rigorous analysis of the Nakamoto protocol (Garay et al., 2015, Pass et al., 2017, Guo and Ren, 2022).\n\nWe diverge from this literature in considering an economic notion of security and free entry of nodes. Classic consensus protocols, such as Paxos (Leslie, 1998), are designed for consensus among a fixed set of known nodes (e.g., a firm's server and its backups). Their goal is to provide resilience to faults such as hardware or software failure and electricity outages. In such a closed deployment scenario, incentives are a non-issue. These protocols can lose consistency if a sufficient number of nodes are corrupted, as such events are rare in the settings they were designed for. By contrast, in environments with free entry, the number of corrupt nodes is endogenous; an attacker willing to bear the cost can control as many nodes as necessary to execute an attack. Therefore, our Stubborn Nakamoto protocol is designed to remain secure regardless of the number of corrupt nodes.\n\nFree entry imposes an additional challenge: nodes may join the protocol at any point in time. There are classic consensus protocols, such as Dolev-Strong (Dolev and Strong, 1983), that are designed for a fixed set of nodes and can operate securely (i.e., guarantee consistency and liveness) given any number of corrupt nodes. However, if nodes can join at any point and there are sufficiently many corrupt nodes, then any protocol, including Dolev-Strong, can lose consistency. Our research builds on the works of Lewis-Pye and Roughgarden (2023), Budish et al. (2024), and Pass and Shi (2017a) that prove this impossibility result and show additional difficulties that arise in the permissionless setting.\n\nThe analysis of bribery attacks on Bitcoin builds upon the ideas introduced in Bonneau (2016). Contemporaneously and independently of this work, Newman (2023) also argues that bribery attacks are cheap when miners are small and rational because small miners are unlikely to be pivotal to an attack's success.\n\nEarlier works suggested using irreversible \"checkpoints\" to secure blockchain protocols (Daian et al., 2019, Buterin and Zamfir, 2015, Karakostas and Kiayias, 2021, Buterin and Griffith, 2017, Neu et al., 2021, Ethereum Foundation, 2023, Sankagiri et al., 2021). In contrast to previous approaches that rely on adding finality gadgets or beacons that are external to the protocol, our Stubborn Nakamoto directs nodes to be \"stubborn\" given their local record, and it is provably secure without relying on any external support.\n\nWhile we focus on protocols that allow fully anonymous nodes (commonly called proof-ofwork), it is worth noting that some proof-of-stake consensus protocols can provide Byzantine forensics and accountability (Sheng et al., 2021, Neu et al., 2022). In other words, if nodes misbehave, it may be possible to produce cryptographic evidence that implicates them. Such cryptographic forensics evidence can serve as a deterrent to attacks on these proof-of-stake protocols. However, Budish et al. (2024) show the limitations of this approach.\n\nFinally, this work is related to Sridhar et al. (2023), which is concurrent with an earlier draft of the present paper. Sridhar et al. (2023) demonstrate that a range of proof-of-stake consensus protocols can be modified to guarantee consistency even under a corrupt majority and suggest a recovery approach following attacks. A key difference is that our Stubborn Nakamoto protocol does not require the setup or infrastructure of proof-of-stake protocols.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 3,
      "text": "# 1.2 Paper outline \n\nThe remainder of the paper is organized as follows. Section 2 provides our model and motivates our definition of economic security. Section 3 analyzes Nakamoto's economic security and shows deficiencies in its incentives. We provide an explanation for the lack of attacks on Bitcoin in Section 3.5 and discuss other factors that deter attacks in practice in Appendix D. Section 4 presents the Stubborn Nakamoto protocol and proves its security. We provide comments on proof-of-stake protocols in Section 5. Section 6 concludes.\n\nTechnical details and formal definitions are in Appendix A. Omitted proofs can be found in Appendix B. Appendix C provides examples of profit from consistency attacks.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 4,
      "text": "## 2 Model and Definitions\n\nThis section describes our model and defines economic security for permissionless protocols. The model abstracts away from some technical details, which are given in Appendix A.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 5,
      "text": "### 2.1 Background: Distributed ledgers and consensus\n\nA consensus protocol coordinates a collection of parties to collectively maintain a single write-only ledger. We interchangeably refer to the parties who maintain the ledger as miners or nodes. Each node $i \\in N$ keeps a local copy of the ledger. Denote the local ledger of node $i$ at time $t$ by $\\log _{i}^{t}$. With a slight abuse of notation, we write $\\log \\subseteq \\log ^{\\prime}$ if the ledger $\\log ^{\\prime}$ can be generated by appending data to Log. We refer to a generic piece of data in the ledger\n\nas a transaction $\\mathrm{tx}$, and assume that users continuously generate unforgeable ${ }^{13}$ transactions and broadcast them to all nodes. Users may issue conflicting transactions, and the ledger needs to resolve such conflicts. ${ }^{14}$\n\nWe say that node $i$ finalizes a transaction tx if $i$ adds the transaction tx to its ledger (updating balances accordingly). The ledger is append-only, meaning that data can only be added (never deleted). That is, $\\log _{i}^{t} \\subseteq \\log _{i}^{t^{\\prime}}$ for any $i \\in N$ and $t^{\\prime}>t$.\n\nEach node $i \\in N$ can observe only its local history, which we call the node's view. In particular, a node may not know what other nodes observe. Depending on its view, the node may wait to receive messages, send messages, run computations, or finalize transactions (appending them to the ledger). In particular, a node can hold received transactions as \"pending\" before finalizing them.\n\nA distributed protocol specifies each node's actions given its view. Nodes are said to be honest if they follow the protocol and are said to be faulty or corrupt otherwise. Correctness ${ }^{15}$ of the consensus protocol is captured by the following ${ }^{16}$ properties:\n\n- Consistency: There are no disagreements between finalized ledgers of honest nodes. That is, for any honest nodes $i$ and $j$ (where $i$ and $j$ may be the same or different) and times $t, t^{\\prime}$, either $\\log _{i}^{t} \\subseteq \\log _{j}^{t^{\\prime}}$ or $\\log _{i}^{t} \\supseteq \\log _{j}^{t^{\\prime}}$.\n- Liveness: There exists a confirmation time $T$ such that if an honest node $i$ receives transaction tx at time $t$, then any honest node $j$ finalizes tx by time $t+T$.\n\nInformally, consistency ensures agreement among all the nodes that maintain local copies of the ledger, and liveness ensures that the ledger keeps updating. When both ${ }^{17}$ of these\n\n[^0]\n[^0]:    ${ }^{13}$ Each transaction is cryptographically signed, ensuring that its owner authorizes it. The analysis allows for a ledger that holds arbitrary data records.\n    ${ }^{14} \\mathrm{~A}$ user may issue a payment twice by mistake, or a malicious user may create conflicting transactions. The ledger must include only one of the conflicting transactions. Alternatively, the ledger can be viewed as a strict ordering of all finalized transactions, where a transaction is deemed invalid (and should be ignored) if it conflicts with earlier transactions.\n    ${ }^{15}$ These properties are agnostic about the content of the ledger. Some applications impose additional validity properties that ensure that the content of the ledger is valid (e.g., the ledger can include only transactions that are properly signed).\n    ${ }^{16}$ These definitions are simplified to focus on the core elements. Protocols that rely on randomness (e.g., hash functions) may inevitably fail with some positive probability. The technical definition addresses this issue by requiring the probability of failure to be appropriately small; see Appendix A for details. In addition, we implicitly assume that the protocol has sufficient capacity to include all transactions.\n    ${ }^{17}$ While a consensus protocol is useful only if it satisfies both properties, it is useful to separate the two properties to distinguish different possible failures. Liveness is violated if the system stops processing records (e.g., a payment system that stops processing transactions because it has lost communication). Consistency is violated if two nodes disagree on a finalized record, then (e.g., a website gives a user confirmation that a payment has been processed although the payment failed).\n\nproperties hold, it appears to protocol users as if a single record keeper maintains a continuously updated ledger.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 6,
      "text": "# 2.2 Free entry and permissionless protocols \n\nOur interest is in protocols that provide an economically valuable property: nodes are exchangeable and may freely enter and exit. The following definition enables free entry. ${ }^{18}$\n\nDefinition 1. We say the protocol is permissionless if a node can join or leave the protocol at any time.\n\nIn particular, nodes do not require permission from any authority, centralized or distributed. Bitcoin's Nakamoto protocol (Nakamoto, 2008) is permissionless, allowing new nodes to join at any time. ${ }^{19}$ By contrast, classic consensus protocols (e.g., Pease et al. 1980, Dolev and Strong 1983, Castro et al. 1999) are permissioned and assume that the set of nodes is known and fixed.\n\nWhen analyzing a run of the protocol from time $t$ to time $t^{\\prime}$, we say that a node is online if it joined before time $t$ and remains active through time $t^{\\prime}$. We say a node is a late joiner if it joined at some time $\\tau>t$. Note that consistency and liveness of the protocol must hold for both online nodes and late joiners.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 7,
      "text": "### 2.3 Communication assumptions\n\nWe assume synchronous communication with dynamic joins and leaves (Pass and Shi, 2017b), unless explicitly stated otherwise. The same communication assumption is used in previous analyses of Nakamoto's protocol (Garay et al., 2015, Pass et al., 2017, Shi, 2022). We denote the maximum message delay by $\\Delta$. In other words, if an honest node $i$ sends a message to an honest node $j$ at time $t$, the message is guaranteed to be delivered at or before time ${ }^{20} t+\\Delta$.\n\nNodes dynamically join and leave. If a node joins at some time $t$, then in each $t^{\\prime} \\geq t$ it will have received all messages sent by honest nodes in round $t^{\\prime}-\\Delta$ or earlier. Further,\n\n[^0]\n[^0]:    ${ }^{18}$ Running a node may require computational infrastructure, and node operators may need to pay the required costs to obtain it (Garratt and van Oordt, 2023, Prat and Walter, 2021). The definition requires no entry restrictions within the protocol.\n    ${ }^{19}$ Moreover, nodes are anonymous to the Nakamoto protocol, and a newly joined node is treated identically to any other node.\n    ${ }^{20}$ The model allows for longer message delays if either the sender or the receiver is faulty.\n\nwhen a node joins, it may receive arbitrary messages from adversarial nodes. Note that late joiners cannot observe the timing of any messages sent before they joined. ${ }^{21}$",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 8,
      "text": "# 2.4 Definition of economic security \n\nThis section motivates and defines economic security for permissionless ledgers. Our goal is to provide users with meaningful guarantees, even if they are unaware of the protocol's technical specifics.\n\nTo motivate our definition, consider a merchant attempting to receive payment from a buyer. A dishonest buyer may want to deceive the merchant into believing that payment was made without transferring funds to the merchant. Fearing the buyer may be dishonest, the merchant might be reluctant to accept paper bills that might be counterfeit or a paper check that may not be backed by sufficient funds. To reduce the risk of fraud, the merchant may employ some security measures. For example, the merchant may check security devices on the bills or call the bank to verify that a check will be honored.\n\nIn a centralized digital payment system, a trusted recordkeeper (bank or payment processor) maintains a ledger of balances and transactions. A dishonest buyer may attempt to mislead the merchant into believing that payment was made when, in fact, the payment is not acknowledged by the trusted recordkeeper (and no funds are transferred to the merchant). To mitigate such risks, the merchant employs a point-of-sale terminal (computer) that verifies the payment. The merchant cannot be deceived if any transaction verified by the merchant's computer is recognized and approved by the trusted recordkeeper.\n\nIn an open distributed ledger, there is no trusted recordkeeper. Instead, a network of computer servers attempts to solve the canonical problem of distributed systems: collectively maintaining a single ledger. Each node holds a local copy of the ledger, and honest nodes update their local ledger according to the protocol's directions. If consistency holds, the many local copies held by different honest nodes agree. Consistency allows us to refer to the consensus ledger, although no canonical copy exists. ${ }^{22}$\n\nSecurity for the merchant corresponds to the consistency of the protocol. Consider the merchant's point-of-sale terminal as a node in the distributed protocol. The merchant's\n\n[^0]\n[^0]:    ${ }^{21}$ For example, suppose that an adversary attempts to broadcast a message at time $t$ and falsely claims that this message was broadcast to all nodes at time $\\tau<t-\\Delta$. An online node can detect that the message was not broadcast at time $\\tau$ because it did not receive it by time $\\tau+\\Delta$. However, a late-joining node cannot detect whether the message was sent at time $t$ or earlier.\n    ${ }^{22}$ One analogy is that one may refer to \"the Bible\" even though there is no canonical copy of the Biblical text.\n\nnode attempts to determine whether the transaction is included in the consensus ledger. When consistency holds, ${ }^{23}$ a merchant's terminal that follows the protocol and determines that a transaction is finalized guarantees that the transaction is included in the consensus ledger (that is, it will be included in the local copy of the ledger of any honest node). In other words, the protocol's consistency guarantees the merchant cannot be deceived: any transaction finalized by the merchant must be accepted by any honest node.\n\nConversely, if an attacker deceives a merchant who follows the protocol, then consistency is violated.\n\nWe combine the distributed systems model with an economic model to define economic security. Classic results in the distributed systems literature prove the consistency and liveness of protocols given a bound on the number of faulty nodes. For example, classic consensus protocols such as Paxos (Lamport, 2001) and PBFT (Castro et al., 1999) guarantee consistency and liveness when more than $2 / 3$ of the nodes are honest. ${ }^{24}$ However, consistency may be violated if a majority of nodes are faulty.\n\nPermissionless protocols require a different approach. Under permissionless protocols, the number of faulty nodes is endogenous. An attacker can control many nodes that join the protocol or create financial incentives to convince existing node operators to deviate from the protocol. To give a meaningful quantification of the challenges the attacker must overcome in order to violate the protocol's consistency, we measure the attacker's cost of violating consistency. If the attacker cannot violate the protocol's consistency, we say the protocol has infinite economic security. If the attacker can violate consistency, quantifying the protocol's economic security requires an economic model specifying the attacker's possible actions and the cost of each possible action. Thus, our definition requires a specification of a distributed systems model and an economic model.\n\nDefinition 2. Given a distributed systems model and an economic cost model, the economic security of a distributed ledger is the minimal attacker's cost required to violate consistency.\n\nOur definition takes a similar approach to Budish (2022) in that we focus on the attacker's cost, which can be quantified within the model. By contrast, the benefits to an attacker may\n\n[^0]\n[^0]:    ${ }^{23}$ The consistency property is also appropriate for centralized payment systems, in which the merchant attempts to maintain consistency between the point-of-sale terminal and the trusted record keeper.\n    ${ }^{24}$ These classic consensus protocols are permissioned, that is, designed for settings where a central designer authorizes each node (for example, a firm operating multiple data centers). In such settings, faults may occur due to hardware outages or software errors, and it is natural to assume that faulty behavior of many nodes is rare.\n\ndepend on many aspects that cannot be observed within the model. ${ }^{25}$ (Appendix C provides examples of the potential profitability of consistency violations.)\n\nKnowledge of the protocol's economic security allows protocol users to adjust their behavior to ensure that an attacker cannot profitably deceive them (given reasonable assumptions on the attacker's benefit). For example, a merchant may only accept payments of a lower value than the protocol's economic security, making deception unprofitable for the attacker.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 9,
      "text": "# 3 Incentives in Permissionless Protocols: Analysis of Bitcoin's Nakamoto Protocol \n\nWe formally demonstrate challenges in securing permissionless protocols by applying our definition of economic security to Bitcoin's Nakamoto protocol. Our analysis focuses on two distinct economic environments, chosen to highlight the inherent incentive deficiencies. First, the protocol lacks a mechanism to penalize attackers. Section 3.2 describes how the protocol can be attacked, and Section 3.3 details the design limitations that prevent it from detecting and punishing attacks. Second, even if an attack prompts a response from outside the protocol (e.g., an exchange rate collapse), this response negatively impacts all miners regardless of their involvement in the attack. Section 3.4 shows that if miners are small, the tragedy of the commons can arise.\n\nThe results suggest that Bitcoin's security does not stem from miners' monetary incentives. We provide an alternative explanation for the security of Bitcoin in Section 3.5. Other considerations are discussed in Appendix D.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 10,
      "text": "### 3.1 Background: Bitcoin's Nakamoto protocol\n\nFor completeness, we provide a brief description of the Nakamoto protocol. Some technical details are deferred to Appendix A.\n\nThe Blockchain data format The ledger is held in the format of a blockchain, which grows over time as new blocks are appended. A blockchain is an ordered sequence of blocks $\\left(B_{0}, B_{1}, \\ldots, B_{n}\\right)$, where $B_{0}$ is the protocol's genesis block. Each block $B_{\\ell}$ contains transaction data and a reference to the preceding block $\\mathrm{B}_{\\ell-1}$. A block $\\mathrm{B}_{n}$ uniquely identifies a chain of preceding blocks, and we write $\\operatorname{Chain}\\left(\\mathrm{B}_{n}\\right)=\\left(\\mathrm{B}_{0}, \\mathrm{~B}_{1}, \\ldots, \\mathrm{~B}_{n}\\right)$. We say that block $\\mathrm{B}_{n-k+1}$ is\n\n[^0]\n[^0]:    ${ }^{25}$ For example, the attacker may have financial interests stemming from bets made outside the system.\n\n$k$-deep in $\\operatorname{Chain}\\left(\\mathrm{B}_{\\mathrm{n}}\\right)$. Let $h\\left(\\mathrm{~B}_{\\ell}\\right)=\\ell$ denote the height of the block, defined as the number of blocks in Chain $\\left(\\mathrm{B}_{\\ell}\\right)$ minus one.\n\nThe view of a node $i \\in N$ encompasses all the information available to node $i$, including its local history and any blocks it has received. A node may receive multiple blocks of the same height, which cannot belong to the same chain.\n\nBrief description of the Nakamoto protocol Each node (miner) organizes valid pending transactions into a suggested block. The protocol uses a hash function to select a node's block randomly. Each node calculates the hash of its block, ${ }^{26}$ and the block is valid if the hash is lower than the difficulty threshold $D .{ }^{27}$ A node that finds a block with a valid hash is said to have mined a block. A node's mining power is the number of hash computations it can attempt per unit time. Nodes can write a special transaction into their block that awards them a block reward $p_{B} .{ }^{28}$\n\nThe protocol specifies the genesis block $\\mathrm{B}_{0}$ that all chains must extend. If a node mines or receives a block, it broadcasts the block to all other nodes. The protocol directs nodes to mine blocks that extend the longest chain in their view. Ties are broken arbitrarily.\n\nThe Nakamoto protocol itself does not specify when transactions are finalized. In common usage, ${ }^{29}$ finality is parameterized by a required block depth $k$, where a transaction is considered finalized by node $i$ if the transaction is within a block at least $k$-deep in the longest chain in $i$ 's view. That is, if $\\operatorname{Chain}\\left(\\mathrm{B}_{\\mathrm{n}}\\right)=\\left(\\mathrm{B}_{0}, \\mathrm{~B}_{1}, \\ldots, \\mathrm{~B}_{\\mathrm{n}}\\right)$ is (one of) the longest chains in the view of node $i$, then $i$ 's local copy of the ledger is $\\log _{i}=\\left(\\mathrm{B}_{0}, \\mathrm{~B}_{1}, \\ldots, \\mathrm{~B}_{n-k+1}\\right)$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 11,
      "text": "# 3.2 Economic security of Bitcoin under the rental model \n\nWe consider a stylized economic environment where miners can freely enter and exit. Several papers have explored a similar model and argued that an attacker can violate the\n\n[^0]\n[^0]:    ${ }^{26}$ Following the literature (Garay et al., 2015, Pass et al., 2017, Shi, 2022), we model the hash function as a random oracle that always returns a random integer between $[0,1]$ on a fresh input. We may assume that the execution proceeds in (possibly infinitesimally small) time increments, such that a unit of mining power can invoke the hash function once per increment. A miner can calculate a new hash for the same block by changing a nonce field. This field serves the sole purpose of allowing multiple inputs to the hash function for the same block.\n    ${ }^{27}$ The difficulty threshold is periodically adjusted.\n    ${ }^{28} \\mathrm{~A}$ node that mines a block can include a special transaction that awards the node with a fixed number of newly minted coins and transaction fees from transactions included in its block. We collectively refer to these as the block reward and use $p_{b}$ to denote its USD value. The node can claim the block reward only if the block is included in the consensus chain.\n    ${ }^{29}$ The parameter $k$ is commonly called the \"confirmation depth\". A common value for $k$ is 6 blocks. For example, see https://coinmarketcap.com/academy/article/how-long-does-a-bitcoin-transaction-take.\n\nconsistency of Nakamoto at a low cost (Budish 2022, Tabarrok 2019, Auer 2019, Moroz et al. 2020, Gans and Halaburda 2024). We provide a similar result in our framework, showing that protocol users cannot defend against these attacks and clarifying why the protocol's design enables such attacks.\n\nIn the rental model, miners choose their computational power and may flexibly adjust it (for example, by renting capacity from a cloud computing service). Computing costs are linear: each miner pays $c$ per attempt to compute a hash. Each hash provides the miner a $1 / D$ chance of mining a block. Each block includes a reward of $p_{\\mathrm{B}}$. Miners are purely profit-motivated. The attacker has the same capabilities and costs as other miners.\n\nConsider an attacker who wishes to deceive a merchant into accepting an invalid transaction. That is, the merchant finalizes the transaction, but the transaction is not included in the consensus chain at some later time (e.g., when the merchant seeks to spend the funds). The merchant uses an observer node ${ }^{30}$ to determine whether the transaction was finalized. Thus, to deceive the merchant, the attacker must violate the consistency of the protocol.\n\nThe following theorem states that Nakamoto's economic security in this economic environment is zero, as the attacker can violate consistency at zero cost. Moreover, this holds even if the merchant uses additional security measures, such as requiring additional verifications before finalizing transactions or monitoring network activity.\n\nProposition 1. The economic security of Bitcoin's Nakamoto protocol in the rental model is zero; that is, the attacker can violate consistency and deceive a merchant at zero net cost. This holds even if the merchant perfectly monitors all network activity and requires additional confirmations for finality.\n\nThe attacker deceives the merchant by creating a conflicting ledger: a blockchain in which the transaction crediting the merchant is absent. This is possible because of the permissionless nature of the protocol, as the attacker can construct such a blockchain by operating a set of miners and providing them with malicious inputs. ${ }^{31}$ The attacker waits for the merchant to finalize the transaction before initiating the attack, rendering any monitoring by the merchant ineffective. The critical phase of the attack involves persuading honest nodes to adopt the conflicting ledger. This is achievable because of the longest chain rule: if the attacker's blockchain becomes longer than the honest chain, all honest nodes will adopt the conflicting chain, thereby violating consistency.\n\n[^0]\n[^0]:    ${ }^{30}$ An observer node is identical to a mining node with zero hash power.\n    ${ }^{31}$ The attacker's miners can even run the same code as honest miners. However, the attacker directs its miners to operate in a separate environment where they never receive the merchant's transaction or any blocks from a chain that includes it.\n\nThe proof uses a similar approach as Budish (2022), Auer (2019), and Gans and Halaburda (2024), and is included in Appendix B for completeness. ${ }^{32}$ The key argument in the proof is that the protocol fails to recognize that an attack has occurred and treats blocks mined by the attacker as if they were mined by honest miners. In particular, once the attacker's chain is adopted, the attacker becomes the \"honest miner\" who created the agreed ledger and is paid the mining rewards. Since honest miners do not lose from mining, neither does the attacker.\n\nObserve that the result holds regardless of the amount of mining rewards in the protocol. This is because mining rewards are given equally to honest and attacking miners. However, deterrence of attacks requires that an attacker's payoff is lower than an honest miner's payoff.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 12,
      "text": "# 3.3 Why Nakamoto fails to detect attacks \n\nTo understand why the Nakamoto protocol permits such attacks, it is useful to examine its design and the rationale behind its longest-chain rule.\n\nIf all nodes are honest and messages are communicated instantly, exactly one block is mined at each height, and nodes achieve consensus on this unique chain. But if messages are communicated with some lag, it is possible for two honest nodes to \"simultaneously\" mine conflicting blocks of the same height. ${ }^{33}$\n\nTo address this possibility, the Nakamoto protocol uses the longest-chain rule to reach consensus on a unique chain. If conflicting blocks of the same height exist, the next mined block extends and selects one unique chain. Although there is a possibility that both blocks are extended simultaneously, the probability of continuing conflict becomes small when network lags are sufficiently short (relative to inter-block time). The probability that multiple honest miners mine conflicting blocks \"simultaneously\" is small, and the probability that two conflicting chains $\\left(\\mathrm{B}_{0}, \\ldots, \\mathrm{~B}_{n-1}, \\mathrm{~B}_{n}, \\ldots, \\mathrm{~B}_{n+k}\\right)$ and $\\left(\\mathrm{B}_{0}, \\ldots, \\mathrm{~B}_{n-1}, \\mathrm{~B}_{n}^{\\prime}, \\ldots, \\mathrm{B}_{n+k}^{\\prime}\\right)$ are both mined by honest nodes is exponentially small in $k$. This observation is used to show that the\n\n[^0]\n[^0]:    ${ }^{32}$ Budish (2022) and Auer (2019) show that Nakamoto has positive economic security if the attacker cannot recoup the mining rewards or if the attacker has higher mining costs. Gans and Halaburda (2024) show that the net cost of the attack can be negative because the attacker can affect the block reward. We discuss such factors in Section D.\n    ${ }^{33}$ For example, assume that it takes 10 seconds for a message from node $i$ to reach node $j$. Suppose that at time $t$, all miners attempt to extend block $\\mathrm{B}_{n-1}$, and that node $i$ mines a block $\\mathrm{B}_{n}$ at time $t$ and communicates it immediately to all other nodes. At time $t+5$ honest node $j$ is yet unaware of the block $\\mathrm{B}_{n}$ mined by $i$, and can mine block $\\mathrm{B}_{n}^{\\prime}$ (that conflicts with block $\\mathrm{B}_{n}$ ). At time $t+20$, the local view of any node includes two conflicting blocks $\\mathrm{B}_{n}, \\mathrm{~B}_{n}^{\\prime}$, and it is unclear which block should be considered part of the consensus chain.\n\nNakamoto protocol satisfies ${ }^{34}$ consistency and liveness if (i) communication is synchronous: network lags are bounded and sufficiently short, and (ii) a sufficient fraction of the mining power is controlled by honest nodes.\n\nBoth assumptions are necessary: the Nakamoto protocol can lose consistency if network lags are too long or the adversary controls enough computational power. To see why synchrony is necessary, consider a network partition. That is, suppose that some miners are in North America (NA) and some are in South America (SA) and that a network partition prevents any communication between NA and SA for a period of time. The protocol directs each group of miners to continue mining and extend the longest chain in their view. ${ }^{35}$ Two conflicting chains grow, one by NA nodes and one by SA nodes. When the network partition is resolved, both NA nodes and SA nodes become aware of both chains. At this point, the protocol reconciles the two conflicting chains by directing all nodes to adopt the longest chain. If the partition lasts long enough, this reconciliation can violate consistency: NA and SA finalize conflicting blocks that are $k$-deep, and the group with the shorter chain discards some finalized blocks.\n\nAn attacker with sufficient computational power essentially exploits the longest-chain rule by \"pretending\" to be partitioned. If the attacker can mine a conflicting chain that is longer than the honest chain, the protocol directs all miners to adopt the new longest chain, as in the reconciliation.\n\nIn practice, the community will be aware that the protocol was attacked. Under synchronous communication, which is necessary for Nakamoto (Pass and Shi, 2017a), honest nodes can detect that the attacker's blocks could not have been mined by honest nodes because they receive these blocks after a long delay. The protocol cannot detect whether this delay results from the attacker's malicious behavior or from honest nodes suffering a network partition. However, it is very unlikely that a significant fraction of the computing power in the network is partitioned. ${ }^{36}$ A common assumption in the literature is that an attack on the protocol will trigger a collapse of the exchange rate of the protocol's coin, which implicitly assumes that the community can detect attacks.\n\n[^0]\n[^0]:    ${ }^{34}$ See Appendix A and Garay et al. (2015), Pass et al. (2017), Shi (2022), and Guo and Ren (2022).\n    ${ }^{35}$ Partitioned nodes in SA can observe that they do not receive any messages from NA nodes but cannot determine whether NA nodes have stopped running the protocol or whether there is a communication failure. The protocol directs SA nodes to continue operating as if all NA nodes stopped.\n    ${ }^{36}$ Moreover, if such a significant partition occurs, it will likely be known to the nodes and protocol users.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 13,
      "text": "# 3.4 Bribery model and the tragedy of the commons \n\nConsider now an economic environment in which the set of miners is fixed, and the attacker can obtain mining power only from existing miners. Even though the Nakamoto protocol is permissionless, external factors may restrict miner entry. For example, miners may employ specialized mining equipment or have access to other restricted resources (e.g., cheap electricity and computing facilities). This stylized economic environment can be considered as an extreme fixed cost ${ }^{37}$ of mining, which makes entry prohibitively expensive.\n\nTo focus on the role of economic incentives, we assume that miners are rational and profit-driven. The attacker can affect the behavior of miners by committing to an incentive contract, which we refer to as a bribery contract (Bonneau, 2016, McCorry et al., 2018, Winzer et al., 2019, Judmayer et al., 2021). We refer to this economic environment as the bribery model.\n\nThe bribery model allows miners to suffer losses due to a community response to an attack. When there is no free entry of miners, it is possible that $p_{\\mathrm{B}}>D \\cdot c$ and miners earn positive profits from mining, and the expectation of future profits increases the value of mining equipment. If the community responds to an attack by decreasing usage, the value of future mining rewards decreases, and mining equipment loses value. Miners may also incur additional losses, and we use $\\Psi_{A}$ to capture all losses miners suffer if the system is attacked. ${ }^{38}$\n\nA community response may carry additional implications for the attacker. We consider these separately below and in Section 3.5. In the bribery model, a successful attack allows the attacker to collect the standard value of block rewards $p_{\\mathrm{B}}$ despite the community response.\n\nThe bribery model has a continuum of miners, each controlling an infinitesimal unit of computational power. ${ }^{39}$ Let $\\psi_{A}$ denote the normalized harm per infinitesimal miner. Miners will participate in the attack if it is in their selfish best interest, given the payments they stand to receive from the protocol, the bribes from the miner, and the harm they may suffer from an attack.\n\nA bribery contract induces a game among the miners. For simplicity, we assume miners play a simultaneous move game where all miners observe the bribery contract and simul-\n\n[^0]\n[^0]:    ${ }^{37}$ Garratt and van Oordt (2023) analyze a security model with fixed costs and Prat and Walter (2021) analyze miner entry with fixed costs.\n    ${ }^{38}$ Garratt and van Oordt (2023) endogenously determine the miners' loss and evaluate the security implications for an attacker who owns all the mining equipment used in the attack.\n    ${ }^{39}$ Contemporaneously and independently of this work, Newman (2023) analyzes a model with finitely many miners and shows that small miners are unlikely to be pivotal to an attack's success.\n\ntaneously choose whether to participate in the attack. The attacker succeeds in attacking the protocol if the attacker violates the protocol's consistency under any equilibrium of the induced game.\n\nThe following theorem shows that even if miners are substantially harmed by an attack, it is cheap for the attacker to incentivize individual small miners to participate in an attack.\n\nProposition 2. In the bribery model, the economic security of Bitcoin's Nakamoto protocol is arbitrarily close to zero; that is, the attacker can violate consistency and deceive a merchant at a net cost arbitrarily close to zero.\n\nProf of Proposition 2. As in the proof of Proposition 1 in Appendix A, the attacker waits until the merchant finalizes the transaction in some block $\\mathrm{B}_{n}$ at some time $t$. Only then, the attacker publishes a bribery contract that pays miners who mine blocks $\\mathrm{B}_{n}^{\\prime}, \\ldots, \\mathrm{B}_{n+k-1}^{\\prime}$ that form the attack chain $\\left(\\mathrm{B}_{0}, \\ldots, \\mathrm{~B}_{n-1}, \\mathrm{~B}_{n}^{\\prime}, \\ldots, \\mathrm{B}_{n+k-1}^{\\prime}\\right)$. The contract commits to pay $\\tilde{p}_{b}$ for each mined block. ${ }^{40}$ The block reward from each of the blocks $\\mathrm{B}_{n}^{\\prime}, \\ldots, \\mathrm{B}_{n+k-1}^{\\prime}$ is directed to an address controlled by the attacker, enabling the attacker to collect them if the attack succeeds.\n\n![table_0](table_0)\n\nTable 1: Miner payoffs under the bribery contract.\n\nThis bribery contract induces a game among miners. Each miner may choose to mine the honest chain, mine the attack chain, or stop mining. ${ }^{41}$ If sufficiently many miners mine the honest chain and refuse to mine the attack chain, the attack fails. If sufficiently many miners mine the attack chain, the attack succeeds. The bribery contract guarantees to pay miners who mine a block in the attack chain an attack block reward of $\\tilde{p}_{\\mathrm{B}}$ regardless of whether the attack succeeds or fails. Miners who mine a block in the honest chain collect an honest block reward of $p_{\\mathrm{B}}$ only if the attack fails. If the attack succeeds, all miners suffer the cost\n\n[^0]\n[^0]:    ${ }^{40}$ Such a commitment can be implemented by a smart contract running on a different blockchain (McCorry et al., 2018). To receive payment, the miner submits the block to the smart contract, which can verify that the block extends the attack chain.\n    ${ }^{41}$ For simplicity, we assume miners do not split their mining power.\n\nof the attack $\\psi_{A}$ (recall that miners are anonymous). Let $x$ denote the number of hashes a miner can compute during the attack. The potential payoffs of a miner are summarized in Table 1.\n\nBy assumption, miners are small and not pivotal to the attack's success. Because honest miners must be willing to mine the honest chain when there is no attack, we have that $p_{\\mathrm{B}} / D-c \\geq 0$. Thus, if the attacker pays $\\tilde{p}_{\\mathrm{B}}>p_{\\mathrm{B}}$, it is a dominant strategy for each individual miner to participate in the attack. The attacker's net cost per block in the attack chain is $\\tilde{p}_{\\mathrm{B}}-p_{\\mathrm{B}} \\approx 0$, and the net cost of the entire attack is arbitrarily close to zero.\n\nNotably, the attacker can induce miners to participate in the attack without compensating miners for the total harm of the attack, $\\Psi_{A}$, or even for their individual losses, $\\psi_{A}$. The game induced by the bribery contract creates a tragedy of the commons for miners. Even if $\\Psi_{A}$ is substantial, it does not affect an individual miner's incentive to deter the attack. Miners are anonymous, and the attack harms both miners who participate in the attack and honest miners alike. If an individual miner cannot affect whether the attack succeeds or fails, the harm does not incentivize individual miners to deter attacks. In that respect, Proposition 2 gives a foundation for the EAAC (expensive to attack in the absence of collapse) property of Budish et al. (2024).\n\nThe community response may limit the attacker's ability to recoup its costs by collecting mining rewards. For example, suppose that the community responds to an attack by refusing to accept payments through the protocol. In that case, the attacker cannot collect block rewards after the attack. This response increases the attacker's net cost to $p_{\\mathrm{B}}$ per block in the attack chain, but the attacker does not need to compensate miners for the losses from the attack, $\\Psi_{A}$. Such a response differentiates between honest miners and attackers, creating penalties that deter attacks. However, other community responses can be more effective. We discuss these next.",
      "tables": {
        "table_0": "|  | Attack <br> Succeeds | Attack <br> Fails |\n| :--: | :--: | :--: |\n| Mine attack chain | $x \\cdot\\left(\\tilde{p}_{\\mathrm{B}} / D-c\\right)-\\psi_{A}$ | $x \\cdot\\left(\\tilde{p}_{\\mathrm{B}} / D-c\\right)$ |\n| Mine honest chain | $-x \\cdot c-\\psi_{A}$ | $x \\cdot\\left(p_{\\mathrm{B}} / D-c\\right)$ |\n| Do not mine | $-\\psi_{A}$ | 0 |"
      },
      "images": {}
    },
    {
      "section_id": 14,
      "text": "# 3.5 What deters attacks in practice? \n\nDespite the possibility of attacks, major cryptocurrencies like Bitcoin and Ethereum ${ }^{42}$ have remained secure. At the same time, numerous attacks on multiple cryptocurrencies that operate the Nakamoto protocol show that the Nakamoto protocol is indeed vulnerable to attacks in practice (Shanaev et al., 2019).\n\n[^0]\n[^0]:    ${ }^{42}$ Ethereum used the Nakamoto protocol until 2022.\n\nWe discuss several explanations for the absence of attacks on Bitcoin in Appendix D and highlight one explanation in particular: the community's ability to correct the ledger after an attack, which we refer to as a community response. Recall that the protocol provides a record-keeping service: maintaining an agreed-upon ledger. If the community agrees that the ledger was corrupted, the community may override the protocol to change it. In blockchain terminology, the community can \"fork\" the protocol by directing all miners to ignore the attack chain and extend the honest chain. Doing so reverts any effect of the attack, leaving the ledger unchanged by the attack. ${ }^{43}$ Moreover, the community response imposes a significant risk to the attacker of having to pay all the attack's costs only to see it undone.\n\nSuch community responses are not without precedent and are actively considered by system developers. ${ }^{44}$ A notable example is the Ethereum community's decision to fork the Ethereum ledger in order to return funds stolen from the DAO attack (Ethereum Foundation, 2016). Such measures, however, require the community to be willing to override the protocol and able to agree on the correct ledger. While the Ethereum blockchain community was able to override the protocol, the Ethereum Classic blockchain rejects any community interventions (Ethereum Classic, 2022). Anecdotally, Ethereum did not suffer any consistency attacks, whereas Ethereum Classic suffered multiple such attacks (Nesbitt, 2019).\n\nHowever, the community response is not a silver bullet. To undo the attack, the community must reach an agreement on the correct ledger. In other words, the community needs to solve the same consensus problem that the protocol attempts to solve. Moreover, the attacker may employ a different attack to deceive both the protocol and the community. Without a formal model of the community's decision-making process, it is difficult to assess the community response.\n\nIn the next section, we analyze a model inspired by the efficacy of the community response. The protocol can be seen as incorporating the community response within the protocol. The analysis evaluates the required capabilities and limitations of the community.\n\n[^0]\n[^0]:    ${ }^{43}$ Such corrections also occur in traditional record-keeping services. For example, the New York Stock Exchange canceled trades that resulted from a software glitch (CNBC, 2024).\n    ${ }^{44}$ For example, Buterim writes \"if the cryptoeconomic consensus fails, whether due to a bug or an intentional $51 \\%$ attack, a vast community of many thousands of developers and many more users are watching carefully to make sure the chain recovers correctly\" (Buterin, 2023). The developer community often uses the terms social consensus (Buterin, 2016) or a community hard fork when referring to the protocol's reliance on external sources.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 15,
      "text": "# 4 Possibility of a Permissionless and Economically Secure Consensus Protocol \n\nWe now consider the broader question of protocol design: Can a permissionless ${ }^{45}$ protocol achieve economic security? This section answers affirmatively. We show that a permissionless protocol can be economically secure by constructing such a protocol. This protocol is a variation of the Nakamoto protocol, and we name it Stubborn Nakamoto protocol. We prove that it is infinitely economically secure - that is, even an attacker with unlimited resources cannot violate consistency - under the same communication assumptions required by Bitcoin's Nakamoto, namely, synchrony with late joiners. The Stubborn Nakamoto protocol preserves the permissionless properties of the Nakamoto protocol while ensuring economic security. Specifically, miners remain anonymous and can enter or exit the system without restriction.\n\nThe design approach underlying the Stubborn Nakamoto protocol is motivated by the analysis in Section 3. The negative results in Section 3 demonstrate that the inability to detect attacks compromises the economic security of Bitcoin's Nakamoto protocol, whereas the effectiveness of the community response highlights the power of attack detection. Accordingly, the Stubborn Nakamoto protocol is designed to enable nodes to detect potential attacks.\n\nThe protocol can be interpreted as incorporating the community response which restores the correct ledger following an attack. A straightforward design might require nodes to communicate and reestablish the correct ledger after an attack. The Stubborn Nakamoto protocol takes a more efficient approach: if a node is assured that the community response will restore the correct ledger, it can immediately adjust its local copy to reflect that correct ledger. (For example, a node can reject an attack chain if it is confident that all honest nodes will likewise reject it.) The Stubborn Nakamoto protocol provides nodes with sufficient knowledge about the behavior of other nodes, ensuring that they maintain a consistent ledger.\n\nThis analysis in this section examines the role of the \"community\" - that is, external inputs beyond the protocol. Some external input is unavoidable. For instance, the initialization of any protocol requires an external source (e.g., setting the genesis block in Bitcoin's Nakamoto protocol), and late joiners must rely on an external input to connect to the protocol (e.g., distinguishing Bitcon's chain from Dogecoin's chain). However, reliance on such\n\n[^0]\n[^0]:    ${ }^{45} \\mathrm{~A}$ common alternative approach is to modify the protocol's permissionless properties. For example, Proof of Stake (PoS) protocols require nodes to register an identifier and associate it with an account. We discuss such protocols in Section 5.\n\nexternal inputs should be minimized. ${ }^{46}$ This section rigorously evaluates the necessary role of the community, formalizing it as a recovery oracle. We prove that some external dependence is necessary for recovery after attacks, and design the Stubborn Nakamoto protocol to minimize this reliance in two key ways. First, the requirements from the recovery oracle can be practically implemented. Second, the Recovery Oracle should not hold excessive control over the system. The Stubborn Nakamoto protocol is thus designed to minimize both: the recovery oracle is simple to implement, invoked only for attack recovery, and holds minimal influence over the system.\n\nSection 4.1 defines the Stubborn Nakamoto protocol, and we prove its security and liveness for online nodes in Section 4.2. Section 4.3 defines the protocol for late joiners and proves the corresponding guarantees. Section 4.4 details how the Stubborn Nakamoto protocol can recover from an attack and formalizes the role of the community in the recovery. Section 4.5 examines the necessary role of the community.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 16,
      "text": "# 4.1 The Stubborn Nakamoto protocol \n\nIn contrast to the analysis of Bitcoin's Nakamoto protocol in Section 3, the definition and analysis of Stubborn Nakamoto protocol require careful consideration of each node's knowledge, and in particular each node's knowledge of the state of other nodes. Before giving the definition of the Stubborn Nakamoto protocol, we introduce notation and definitions that represent the knowledge held by a node. Note that this section defines the Stubborn Nakamoto protocol for online nodes. The protocol for late joiners is defined in Section 4.3.\n\nThe Stubborn Nakamoto protocol makes the same communication assumptions as Bitcoin's Nakamoto protocol, namely synchronous communication with late joiners. We also assume \"implicit echoing\", namely, if an honest node ${ }^{47}$ receives a message at time $t$, then every honest node receives the message by time $t+\\Delta$. Stubborn Nakamoto also shares the same setup assumptions as Bitcoin's Nakamoto protocol: all nodes are assumed to have knowledge of the genesis block and the protocol's rules. The protocol is parameterized by a confirmation depth $k$.\n\n[^0]\n[^0]:    ${ }^{46}$ Reliance on the community to resolve challenges is often challenging to formally model and analyze. Moreover, reliance on out-of-protocol inputs can introduce fundamental issues. First, the primary objective of the protocol is to establish consensus, so it should not depend on the community's ability to achieve consensus (conversely, if the protocol cannot establish consensus, why should the community be able to do so?). Second, reliance on external inputs may undermine the protocol's permissionless properties, potentially giving control over the system to an out-of-protocol entity.\n    ${ }^{47}$ We assume that the implicit echoing assumption holds for all nodes, including observer nodes that do not mine. Sridhar et al. (2024) show the necessity of this assumption.\n\nStubborn Nakamoto uses the blockchain data format. The local view of node $i$ includes all the blocks received by $i$, as well as additional information recorded in the form of block labels. We write $\\mathrm{B} \\in$ View $_{i}^{t}$ to denote that node $i$ received block B by time $t$. Each block label is encoded as a subset of blocks in view. We describe below how a node assigns each label given its local view. Labels are never removed. ${ }^{48}$\n\nA block B conflicts with block $\\mathrm{B}^{\\prime}$, denoted $\\mathrm{B} \\nsim \\mathrm{B}^{\\prime}$, if there is no chain that contains both $\\mathrm{B}, \\mathrm{B}^{\\prime}$. That is, neither Chain(B) $\\subseteq$ Chain $\\left(\\mathrm{B}^{\\prime}\\right)$ nor Chain $\\left(\\mathrm{B}^{\\prime}\\right) \\subseteq$ Chain(B). Given a block B and a set of blocks $\\mathcal{A}$, if $\\nexists \\mathrm{B}^{\\prime} \\in \\mathcal{A}$ such that $\\mathrm{B} \\nsim \\mathrm{B}^{\\prime}$ we say that B does not conflict with $\\mathcal{A}$, written $\\mathrm{B} \\sim \\mathcal{A}$. We write $\\mathrm{B} \\nsim \\mathcal{A}$ if $\\exists \\mathrm{B}^{\\prime} \\in \\mathcal{A}$ such that $\\mathrm{B} \\nsim \\mathrm{B}^{\\prime}$.\n\nThe protocol may instruct a node to halt if the node detects a potential conflict between its local view and the local view of another honest node. When a node halts it stops its attempts to mine any new blocks and stops certifying any new blocks (as described below). If the node has already certified some blocks, it completes the steps below to determine whether these blocks should be finalized.\n\nThe Stubborn Nakamoto protocol relies on the following definition, which specifies the first step a node takes toward finalizing a block. The conditions for this first step closely resemble the conditions for finalizing a block in the Nakamoto protocol. However, unlike the Nakamoto protocol, the required confirmation depth $k$ is explicitly defined within the protocol, and all nodes use the same confirmation depth $k$.\n\nDefinition 3. Node $i$ certifies block B at time $t$, written $\\mathrm{B} \\in \\mathcal{C}_{i}^{t}$, if at time $t$ there is a chain $\\left(\\mathrm{B}_{0}, \\ldots, \\mathrm{~B}, \\ldots, \\overline{\\mathrm{B}}\\right)$ in View $_{t}^{i}$ such that\n\n1. Block B is at least $k$-deep in the chain $\\operatorname{Chain}(\\overline{\\mathrm{B}})$, i.e., $h(\\overline{\\mathrm{~B}})-h(\\mathrm{~B})+1 \\geq k$.\n2. The chain $\\operatorname{Chain}(\\overline{\\mathrm{B}})$ is a longest chain in view, meaning $h(\\overline{\\mathrm{~B}}) \\geq h(\\overline{\\mathrm{~B}})$ for any $\\overline{\\mathrm{B}} \\in$ View $_{i}^{t}$.\n\nAdditionally, if in the view of node $i$ at time $t$ there is no certified block $\\mathrm{B}^{\\prime}$ that conflicts with B , then B is also clear-certified, denoted $\\mathrm{B} \\in \\mathcal{C C}_{i}^{t} .{ }^{49}$\n\nThe protocol relies on the following definition to characterize each node's knowledge of what other nodes may have certified.\n\nDefinition 4. For $\\gamma \\geq 0$, a block B becomes $\\gamma$-potentially certified by node $i$ at time $t$, written $\\mathrm{B} \\in \\mathcal{P C}_{i}^{t}(\\gamma)$, if at time $t$ there is a chain $\\left(\\mathrm{B}_{0}, \\ldots, \\mathrm{~B}, \\ldots, \\overline{\\mathrm{B}}\\right)$ in View $_{t}^{i}$ such that\n\n[^0]\n[^0]:    ${ }^{48}$ For example, we have $\\mathcal{C}_{i}^{t} \\subseteq \\mathcal{C}_{i}^{\\tau}$ for $\\tau \\geq t$ (and analogously for all other block labels defined below).\n    ${ }^{49}$ If two conflicting blocks both become certified at time $t$, neither is clear-certified.\n\n1. block B is at least $k$-deep in the chain $\\operatorname{Chain}(\\overline{\\mathrm{B}})$, that is $h(\\overline{\\mathrm{B}})-h(\\mathrm{~B})+1 \\geq k$;\n2. the chain $\\operatorname{Chain}(\\overline{\\mathrm{B}})$ would have been a longest chain in $i$ 's view at time $t-\\gamma$, meaning $h(\\overline{\\mathrm{~B}}) \\geq h(\\overline{\\mathrm{~B}})$ for any $\\overline{\\mathrm{B}} \\in \\operatorname{View}_{i}^{t-\\gamma}$.\n\nWe can now state the definition of the Stubborn Nakamoto. Recall that each node $i$ maintains $\\log _{i}^{t}$, a local copy of the ledger that consists of all finalized blocks. The local copy of the ledger $\\log _{i}^{t}$ is required to agree with the local copy of the ledger $\\log _{j}^{\\top}$ of any other honest node $j$.\n\nThe Stubborn Nakamoto protocol requires the same communication assumptions as Bitcoin's Nakamoto: synchronous communication with late joiners. We make the standard \"implicit echoing\" assumption (which is also assumed for standard Nakamoto). ${ }^{50}$ It also shares the same setup assumption as Bitcoin's Nakamoto: all nodes know the genesis block and the protocol. Stubborn Nakamoto is parameterized by a confirmation depth $k$.\n\nThe Stubborn Nakamoto protocol directs nodes to take two steps before finalizing a block and adding it to their local copy of the ledger. First, the block needs to be certified. Second, the node waits to see that no other node could have certified a conflicting block. If the node does not observe any potential conflicts, the node can finalize the block and add it to the ledger.\n\nDefinition 5 (The Stubborn Nakamoto Protocol). As in Nakamoto, the protocol directs nodes (miners) to attempt to mine a block that extends the longest chain in view. Each node $i$ takes the following steps ${ }^{51}$ towards finalizing blocks:\n\n1. Node $i$ certifies blocks according to definition 3. If a block B is certified but is not clear-certified (that is, in the local view of node $i$ there is a block $\\mathrm{B}^{\\prime}$ that is certified and conflicts with B), then node $i$ halts.\n2. If $i$ certified block B at time $t_{1}$, then at time $t_{2}=t_{1}+2 \\Delta$ node $i$ checks if there is a block $\\mathrm{B}^{\\prime}$ in $i$ 's local view that conflicts with B and is $2 \\Delta$-potentially certified. If yes,\n[^0]\n[^0]:    ${ }^{50}$ That is, every node (including observer nodes that do not mine) echoes every fresh message they see. This implies that if an honest node sees a message at time $t$, then every honest node will have seen it by $t+\\Delta$.\n    ${ }^{51}$ Using notation: Let $t_{1}$ be the earliest time such that $\\mathrm{B} \\in \\mathcal{C}_{i}^{t_{1}}$.\n\n    1. If $\\mathrm{B} \\neq \\mathcal{C}_{i}^{t_{1}}$, then node $i$ halts at time $t_{1}$.\n    2. Let $t_{2}=t_{1}+2 \\Delta$. If $\\mathrm{B} \\nsim \\mathcal{P} \\mathcal{C}_{i}^{t_{2}}(2 \\Delta)$, then node $i$ halts at time $t_{2}$. If $\\mathrm{B} \\sim \\mathcal{P} \\mathcal{C}_{i}^{t_{2}}(2 \\Delta)$, then $\\mathrm{B} \\in \\log _{i}^{t_{2}}$.\n    3. Let $t_{3}=t_{1}+4 \\Delta$. If $\\mathrm{B} \\nsim \\mathcal{P} \\mathcal{C}_{i}^{t_{3}}(4 \\Delta)$, then node $i$ halts at time $t_{3}$.\n\nnode $i$ halts. If B does not conflict with any $2 \\Delta$-potentially certified block in $i$ 's local view, then node $i$ finalizes B , written $\\mathrm{B} \\in \\log _{i}^{t_{2}}$.\n3. If $i$ certified block B at time $t_{1}$, then at time $t_{3}=t_{1}+4 \\Delta$ node $i$ checks if there is a block $\\mathrm{B}^{\\prime}$ in $i$ 's local view that conflicts with B and is $4 \\Delta$-potentially certified. If yes, node $i$ halts.\n\nThe definition of the Stubborn Nakamoto protocol is conceptually simple yet carefully designed. On one hand, the protocol ensures that nodes can detect and prevent conflicts with other nodes. On the other hand, nodes must not be overly cautious, as halting too easily would hinder progress and compromise the protocol's liveness. The protocol's design, along with the definition of $\\gamma$-potentially confirmed blocks, carefully balances these competing requirements.\n\nOne interpretation of the protocol is that it incorporates the community response (discussed in Section 3.5) into the protocol itself. Because the Stubborn Nakamoto protocol is permissionless, it cannot prevent an attacker with sufficient resources from creating a conflicting ledger (as described in Section 3.2). Despite this, the protocol prevents consistency violations by allowing nodes to identify attacks. If a node can identify received blocks as attack blocks that could only have been mined by an attacker, it can simply ignore them. However, to maintain agreement, we must ensure that if node $i$ ignores a block, it can be confident that any honest node $j$ will also ignore that block.\n\nTo ensure agreement among all honest nodes, the Stubborn Nakamoto protocol differs from the standard Nakamoto in two key ways. First, it specifies an explicit condition for finality, ensuring that an honest node can reliably predict the behavior of other honest nodes. Second, before finalizing a block, nodes wait for a conflict-discovery period, allowing them to learn if another node receives a conflicting ledger. While an attacker with unlimited resources may still create a conflicting ledger, honest nodes will be able to detect the existence of multiple potential ledgers, identify the risk of disagreement, and halt if necessary. More generally, the protocol guarantees that an honest node finalizes a block only if that node is assured that no other honest node could have finalized a conflicting block.\n\nThe Stubborn Nakamoto protocol prioritizes consistency and instructs nodes to finalize a block only if consistency is assured. Given the known impossibility of consensus without an honest majority (Pass and Shi, 2017a, Lewis-Pye and Roughgarden, 2023, Sridhar et al., 2024), any protocol must, under some attacks, sacrifice either consistency or liveness. The protocol may lose liveness under some attacks that cause nodes to detect a conflict and halt. We discuss how the protocol can regain liveness after an attack in Section 4.4.\n\nRemark 1. The Stubborn Nakamoto protocol can be made more resilient by instructing nodes to become \"stubborn\" on any block for which they completed step 3, meaning a node ignores any block that conflicts with a block that completed step 3 without halting. This modification allows online nodes to completely ignore the attack described in the Section 3.2, and it does not affect the protocol's security and liveness guarantees for online nodes (which are formally stated and proved in the following section). However, such a modification will require careful treatment of late joiners, which we discuss in Section 4.3 and Section 4.4.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 17,
      "text": "# 4.2 Consistency and liveness of Stubborn Nakamoto \n\nWe turn to prove that Stubborn Nakamoto guarantees consistency and liveness for online nodes. Treatment of late joiners is in Section 4.3. Before presenting our main theorem, we first establish formal results that characterize the knowledge an honest online node has about other honest online nodes under the Stubborn Nakamoto protocol.\n\nLemma 1. If an honest node $i$ certifies block B at time $t$, then by time $t+\\Delta$ block B is $2 \\Delta$-potentially certified by any honest node $j$.\nIf an honest node $i$ $\\gamma$-potentially certifies block B at time $t$, then by time $t+\\Delta$ block B is $(\\gamma+2 \\Delta)$-potentially certified by any honest node $j$.\n\nProof. Because $\\mathcal{C}_{i}^{t}=\\mathcal{P C}_{i}^{t}(0)$, it is sufficient to prove the second part of the lemma. Assume that block B is $\\gamma$-potentially certified by honest node $i$ at time $t$. That is, there is a chain $\\operatorname{Chain}(\\overline{\\mathrm{B}})=\\left(\\mathrm{B}_{0}, \\ldots, \\mathrm{~B}, \\ldots, \\overline{\\mathrm{~B}}\\right) \\subseteq \\operatorname{View}_{i}^{t}$ that satisfies the conditions of definition 4 given the local view of node $i$ at time $t$, namely: $h(\\overline{\\mathrm{~B}})-h(\\mathrm{~B})+1 \\geq k$, and $h(\\overline{\\mathrm{~B}}) \\geq h(\\overline{\\mathrm{~B}})$ for any $\\overline{\\mathrm{B}} \\in \\operatorname{View}_{i}^{t-\\gamma}$.\n\nConsider arbitrary honest node $j$. Because node $i$ receives all the blocks in Chain( $\\overline{\\mathrm{B}})$ by time $t$, node $j$ receives all blocks in Chain( $\\overline{\\mathrm{B}})$ by time $\\tau \\leq t+\\Delta$. We have that B is $k$-deep in Chain( $\\overline{\\mathrm{B}})$, satisfying $h(\\overline{\\mathrm{~B}})-h(\\mathrm{~B})+1 \\geq k$. To see that $h(\\overline{\\mathrm{~B}}) \\geq h(\\overline{\\mathrm{~B}})$ for any $\\overline{\\mathrm{B}} \\in \\operatorname{View}_{j}^{\\tau-\\gamma-2 \\Delta}$, observe that\n\n$$\n\\operatorname{View}_{j}^{\\tau-\\gamma-2 \\Delta} \\subseteq \\operatorname{View}_{j}^{t+\\Delta-\\gamma-2 \\Delta}=\\operatorname{View}_{j}^{t-\\gamma-\\Delta} \\subseteq \\operatorname{View}_{i}^{t-\\gamma}\n$$\n\nwhere the first inclusion follows because $\\tau \\leq t+\\Delta$, and the last inclusion follows from communication between two honest nodes. Thus, we have that $\\mathrm{B} \\in \\mathcal{P C}_{j}^{\\tau}(2 \\Delta+\\gamma) \\subseteq$ $\\mathcal{P C}_{j}^{t+\\Delta}(2 \\Delta+\\gamma)$.\n\nWe can now state our main result, showing that Stubborn Nakamoto is economically secure.\n\nTheorem 1 (Consistency of Stubborn Nakamoto). Under synchrony, Stubborn Nakamoto satisfies consistency even in the presence of an adversary with unbounded computational power ${ }^{52}$ and any number of corrupted nodes.\n\nProof. Suppose that honest node $i$ finalized block $B$ at time $t_{2}$. Let $t_{1}=t_{2}-2 \\Delta$ denote the time when node $i$ certified block B. We need to show that if some honest node $j$ finalized a block $\\mathrm{B}^{\\prime}$ then it must be that $\\mathrm{B}^{\\prime} \\sim \\mathrm{B}$. It is immediate from definition 3 that node $i$ never clear-certifies a block $\\mathrm{B}^{\\prime} \\nsim \\mathrm{B}$, and therefore node $i$ cannot finalize a block $\\mathrm{B}^{\\prime}$ that conflicts with B.\n\nFor the sake of contradiction, consider an honest node $j \\neq i$ that finalized a block $\\mathrm{B}^{\\prime} \\nsim \\mathrm{B}$ at time $t_{2}^{\\prime}$, and let $t_{1}^{\\prime}=t_{2}^{\\prime}-2 \\Delta$ denote the time node $j$ certified block $\\mathrm{B}^{\\prime}$. By Lemma 1, node $j$ must have $2 \\Delta$-potentially certified block $B$ by time $t_{1}+\\Delta$. Because node $j$ finalized block $\\mathrm{B}^{\\prime} \\nsim \\mathrm{B}$, we must have that $t_{1}^{\\prime}+2 \\Delta=t_{2}^{\\prime}<t_{1}+\\Delta$. Symmetrically, by Lemma 1 we have that node $i$ must have $2 \\Delta$-potentially certified block $\\mathrm{B}^{\\prime}$ by time $t_{1}^{\\prime}+\\Delta$. Because node $i$ finalized block $\\mathrm{B} \\nsim \\mathrm{B}^{\\prime}$, we must have that $t_{1}+2 \\Delta=t_{2}<t_{1}^{\\prime}+\\Delta$. But this implies that $t_{1}<t_{1}^{\\prime}-\\Delta$ and $t_{1}^{\\prime}<t_{1}-\\Delta$, a contradiction.\n\nThe consistency guarantee provided by Theorem 1 is notable for two key reasons. First, it demonstrates that the Stubborn Nakamoto protocol is maximally economically secure, as even an attacker with unlimited resources cannot violate consistency and deceive the protocol's users. Second, the protocol's security does not rely on mining rewards or other monetary incentives. ${ }^{53}$\n\nOf course, a protocol is only useful if it also satisfies liveness. To see why Stubborn Nakamoto also satisfies liveness, observe that Stubborn Nakamoto differs from Nakamoto only when, in the local view of some honest node $i$, there are two conflicting blocks $\\mathrm{B}^{\\prime} \\nsim \\mathrm{B}$ that are both $\\gamma$-potentially certified for $\\gamma \\leq 4 \\Delta$. In other words, nodes will act differently under the two protocols only in realizations that are close to the Nakamoto protocol's consistency violations. Under approximately the same conditions that guarantee consistency and\n\n[^0]\n[^0]:    ${ }^{52}$ That is, the attacker can control arbitrarily mining resources with an unbounded hash rate. We maintain the standard assumption that the attacker cannot break cryptographic primitives.\n    ${ }^{53}$ Mining rewards play a role in deterring attackers from compromising the protocol's liveness; see Section 4.4 .\n\nliveness of the Nakamoto protocol, such realizations do not arise, and Stubborn Nakamoto satisfies consistency and liveness.\n\nTheorem 2 builds on these ideas to formally establish that Stubborn Nakamoto satisfies consistency and liveness under a sufficient honest majority assumption, the same assumption required for Nakamoto to satisfy consistency and liveness. The exact technical statement of the network-aware honest majority assumption and the proof can be found in Appendix A.\n\nTheorem 2 (Liveness of Stubborn Nakamoto). Under synchrony, Stubborn Nakamoto satisfies consistency and liveness if the network-aware honest majority assumption holds.\n\nRoughly speaking, the theorem states both Nakamoto and Stubborn Nakamoto require the same honest majority assumption to guarantee both consistency and liveness. The protocols differ when this assumption is not satisfied. ${ }^{54}$ Under the Nakamoto protocol, an attack that controls sufficiently many nodes can cause consistency violations. In contrast, the Stubborn Nakamoto protocol prevents consistency violations by allowing nodes to detect when consistency might be at risk. Rather than allowing transactions to be added to the ledger only to be later reverted, Stubborn Nakamoto instructs nodes to halt and wait for a safe recovery. Effectively, the Stubborn Nakamoto protocol transforms Nakamoto's consistency violations into liveness violations. This behavior is particularly desirable in financial systems, where transaction integrity is paramount.\n\nNote that the version of Stubborn Nakamoto outlined in Remark 1 can completely avoid some of Nakamoto's consistency violations without suffering a liveness violation. In particular, this version of the protocol maintains both consistency and liveness under the attack outlined in Section 3.2.\n\nThe proof of Theorem 2 uses the intermediate stochastic bounds used to prove the consistency and liveness of Nakamoto. While the scenarios under which liveness of Stubborn Nakamoto is violated are very close to those under which consistency of Nakamoto is violated, it is possible to have a liveness violation of Stubborn Nakamoto without a corresponding consistency violation of Nakamoto. For this reason, the proof of Theorem 2 requires subtle changes to the analysis of Nakamoto consensus of Pass et al. (2017) and Shi (2022). We state the technical details, required lemmas, and the proof of Theorem 2 in Appendix A.\n\n[^0]\n[^0]:    ${ }^{54}$ Some trade-offs in protocol design are necessary, as no protocol can guarantee both consistency and liveness under corrupt majority (Pass and Shi, 2017a, Lewis-Pye and Roughgarden, 2023, Sridhar et al., 2024).",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 18,
      "text": "# 4.3 Late joiners \n\nThis section establishes guarantees for late joiners under Stubborn Nakamoto. A late joiner is a node that joins the system at some time $t$, after the protocol has already been running for some time and some blocks may already have been finalized. We adopt the standard communication assumption that by time $t+\\Delta$ the late joiner receives all messages sent by honest nodes by time $t$ or earlier (Pass and Shi, 2017b). ${ }^{55}$ However, a late joiner node cannot distinguish the time at which earlier messages were sent. ${ }^{56}$ Additionally, a late joiner may also receive arbitrarily many messages from adversarial nodes.\n\nAllowing late joiners is crucial for the free entry of nodes. Without this capability, all nodes would be required to join at the protocol's inception and remain continuously online. However, ensuring consistency for late joiners presents significant challenges. For example, the well-known Dolev-Strong protocol guarantees consistency and liveness for online nodes but fails to provide these guarantees for late joiners (see, e.g., Pass and Shi (2017a)).\n\nThe following definition formalizes the process by which a late joiner node becomes an online node. We refer to these steps as the node's wake-up procedure.\n\nDefinition 6 (Node Awakening). Let honest node $i$ be a late joiner that awakens at time $t_{w}$. Node $i$ waits until time $t_{o n}>t_{w}$ such that node $i$ does not receive any new blocks between $t_{o n}-6 \\Delta$ and $t_{o n}$. If there are two conflicting blocks $\\mathrm{B}, \\mathrm{B}^{\\prime} \\in \\operatorname{View}_{i}^{t_{o n}}$ that are both $k$-deep in some longest chain in View ${ }_{i}^{t_{o n}}$, then node $i$ halts. Otherwise, node $i$ certifies and finalizes all blocks that are $k$-deep in a longest chain in view, and becomes an online honest node.\n\nThe following result establishes the protocol's consistency guarantee for late joiners. The Stubborn Nakamoto protocol requires an additional assumption to ensure consistency for late joiners: namely, a late joiner must rely on at least one online honest node to maintain consistency with blocks that were finalized before the late joiner woke up.\n\nTheorem 3. Suppose that node $i$ is a late joiner that wakes up according to Definition 6, and there is some honest node $j$ that is online throughout and did not halt by time $t_{o n}$.\n\n[^0]\n[^0]:    ${ }^{55}$ The same communication assumption is also used by the standard Nakamoto protocol, which requires late-joining nodes to receive and verify the entire chain of previous blocks, linking back to the genesis block. The delivery of past messages is essential in any protocol to ensure that newly joining nodes can correctly establish and continue the ledger.\n    ${ }^{56}$ That is, if $\\tau_{1}, \\tau_{2}<t$, a late joiner cannot tell whether a message was sent at time $\\tau_{1}$ or at time $\\tau_{2}$. This is in contrast to online nodes, which are able to observe when any message is sent by an honest node up to a $\\Delta$ time lag. In particular, late joiners cannot recreate the finalization steps taken by online nodes under Stubborn Nakamoto, as they cannot determine which blocks were received within $4 \\Delta$ of a block's certification.\n\nThen consistency holds for node $i$ even in the presence of an adversary with unbounded computational power and any number of corrupted nodes.\n\nRemark 2. Theorem 3 does not hold under the protocol modification outlined in Remark 1. The reason is that while online nodes can detect and ignore the attack chain described in Section 3.2, late joiners lack the ability to distinguish between the attack chain and the honest chain. In other words, late joiners do not have sufficient information to select the correct chain after online nodes ignore an attack chain. These challenges are addressed by the recovery oracle, introduced in Section 4.4.\n\nProof. Suppose that $i$ is a late joiner, and became online at time $t_{o n}$. Let $j$ be an honest node that is online and did not halt by time $t_{o n}$.\n\nFirst, let us show that $\\log _{i}^{t_{o n}}=\\log _{j}^{t_{o n}}$. Let $\\mathrm{B}_{j} \\in \\log _{j}^{t_{o n}}$ be a block finalized by $j$. Let $t_{j}$ denote the time at which block $\\mathrm{B}_{j}$ was certified by $j$ and let $\\operatorname{Chain}\\left(\\tilde{\\mathrm{B}}_{\\mathrm{j}}\\right)$ denote the corresponding chain that certified $\\mathrm{B}_{j}$. Because $\\mathrm{B}_{j}$ is finalized by $j$ by time $t_{o n}$, we have that $t_{j} \\leq t_{o n}-2 \\Delta$. Therefore, $\\operatorname{Chain}\\left(\\tilde{\\mathrm{B}}_{\\mathrm{j}}\\right) \\subseteq \\operatorname{View}_{\\mathrm{i}}^{t_{o n}}$. If a longest chain in $\\operatorname{View}_{i}^{t_{o n}}$ contains $\\mathrm{B}_{j}$, it must be as at least as long as $\\operatorname{Chain}\\left(\\tilde{\\mathrm{B}}_{\\mathrm{j}}\\right) \\subseteq \\operatorname{View}_{\\mathrm{i}}^{t_{o n}}$, and therefore include $\\mathrm{B}_{j}$ at least $k$-deep. This implies that $\\mathrm{B}_{j} \\in \\log _{i}^{t_{o n}}$, as required.\n\nOtherwise, assume for the sake of contradiction that $\\operatorname{Chain}\\left(\\tilde{\\mathrm{B}}^{\\prime}\\right)$ is a longest chain in $\\operatorname{View}_{i}^{t_{o n}}$ that does not include $\\mathrm{B}_{j}$. Since Chain $\\left(\\tilde{\\mathrm{B}}^{\\prime}\\right)$ is at least as long as Chain $\\left(\\tilde{\\mathrm{B}}_{\\mathrm{j}}\\right)$, it must include some block $\\mathrm{B}^{\\prime} \\nsim \\mathrm{B}$ that is at least $k$-deep in Chain $\\left(\\tilde{\\mathrm{B}}^{\\prime}\\right)$. We have that\n\n$$\n\\operatorname{View}_{i}^{t_{o n}-6 \\Delta} \\subseteq \\operatorname{View}_{j}^{t_{o n}-5 \\Delta} \\subseteq \\operatorname{View}_{j}^{t_{o n}-\\Delta} \\subseteq \\operatorname{View}_{i}^{t_{o n}}\n$$\n\nand therefore Chain $\\left(\\tilde{\\mathrm{B}}^{\\prime}\\right)$ is a longest chain in $j$ 's view at time $t_{o n}-5 \\Delta$. But this implies that node $j$ must halt before time $t_{o n}$, having seen a conflicting certified block.\n\nTo show $\\log _{i}^{t_{o n}} \\subseteq \\log _{j}^{t_{o n}}$, let $\\log _{i}^{t_{o n}}=\\operatorname{Chain}\\left(\\mathrm{B}_{\\mathrm{i}}\\right)$ and let Chain $\\left(\\tilde{\\mathrm{B}}_{\\mathrm{i}}\\right)$ denote a chain that certified $\\mathrm{B}_{i}$. We have that $h\\left(\\tilde{\\mathrm{~B}}_{i}\\right) \\geq h(\\tilde{B})$ for all $\\tilde{\\mathrm{B}} \\in \\operatorname{View}_{i}^{t_{o n}}$. Moreover, because $i$ does not halt by time $t_{o n}, \\mathrm{~B}_{i}$ is $k$ deep in any longest chain in $\\operatorname{View}_{i}^{t_{o n}}$. We have that\n\n$$\n\\operatorname{Chain}\\left(\\tilde{\\mathrm{B}}_{\\mathrm{i}}\\right) \\subseteq \\operatorname{View}_{\\mathrm{i}}^{t_{o n}}=\\operatorname{View}_{\\mathrm{i}}^{t_{o n}-6 \\Delta} \\subseteq \\operatorname{View}_{\\mathrm{j}}^{t_{o n}-5 \\Delta}\n$$\n\nTherefore, node $j$ certified $\\mathrm{B}_{i}$ by time $t_{o n}-5 \\Delta$. Because $j$ did not halt by time $t_{o n}$, we have that $j$ finalized $\\mathrm{B}_{i}$ and every block in Chain $\\left(\\mathrm{B}_{\\mathrm{i}}\\right)$ by time $t_{o n}$. Thus, we have that $\\log _{i}^{t_{o n}}=\\log _{j}^{t_{o n}}$.\n\nNow, suppose that node $i$ certifies block B at time $t_{1}>t_{o n}$ and finalizes it at time\n\n$t_{2}=t_{1}+2 \\Delta$. It is immediate that $B$ does not conflict with any block certified or finalized by $i$. Suppose, for the sake of contradiction, that honest node $j$ finalizes a conflicting block $\\mathrm{B}^{\\prime}$ at time $t_{2}^{\\prime}$. If $t_{2}^{\\prime} \\leq t_{o n}$, we have $\\mathrm{B}^{\\prime} \\in \\log _{j}^{t_{o n}}=\\log _{i}^{t_{o n}}$ by the first part of the proof, and we have a contradiction.\n\nIf $t_{2}^{\\prime}>t_{o n}$, it must be that $j$ certifies the block $\\mathrm{B}^{\\prime}$ at time $t_{1}^{\\prime}>t_{o n}-\\Delta$. Let $\\operatorname{Chain}\\left(\\tilde{\\mathrm{B}}^{\\prime}\\right)$ be the corresponding chain in $j$ 's view at time $t_{1}^{\\prime}$. We have that $\\operatorname{Chain}\\left(\\tilde{\\mathrm{B}}^{\\prime}\\right)$ must be longer than any chain in $j$ 's view at time $t_{1}^{\\prime}$, and therefore it is longer than any chain in View $_{i}^{t_{o n}}$. Node $i$ receives $\\operatorname{Chain}\\left(\\tilde{\\mathrm{B}}^{\\prime}\\right)$ by time $\\tau \\leq t_{1}^{\\prime}+\\Delta$. Because $\\operatorname{View}_{i}^{\\tau-2 \\Delta} \\subseteq \\operatorname{View}_{j}^{\\tau-\\Delta} \\subseteq \\operatorname{View}_{j}^{t_{1}^{\\prime}}$, we have that $\\mathrm{B}^{\\prime} \\in \\mathcal{P C}_{i}^{\\tau}(2 \\Delta)$. Since node $i$ finalized block B , we must have $\\tau>t_{2}$.\n\nLet $\\operatorname{Chain}(\\tilde{\\mathrm{B}})$ be the chain in $i$ view that certified B at time $t_{1}$. Again, we have that Chain $(\\tilde{\\mathrm{B}})$ is longer than any chain in View $_{i}^{t_{o n}}$. Node $j$ receives Chain $(\\tilde{\\mathrm{B}})$ by time $\\nu \\leq t_{1}+\\Delta$. Because $\\operatorname{View}_{j}^{\\nu-2 \\Delta} \\subseteq \\operatorname{View}_{i}^{\\nu-\\Delta} \\subseteq \\operatorname{View}_{i}^{t_{1}}$, we have that $\\mathrm{B} \\in \\mathcal{P C}_{j}^{\\nu}(2 \\Delta)$. But this implies that $t_{1}+\\Delta \\geq \\nu>t_{1}^{\\prime}+2 \\Delta$ and $t_{1}^{\\prime}+\\Delta \\geq \\tau>t_{1}+2 \\Delta$, and we have reached a contradiction.\n\nWhen the honest majority assumption holds, late joiners can reliably identify previously finalized blocks that must be in the longest chain in their view. The following theorem provides the protocol's guarantees for late joiners in the absence of an attack.\n\nTheorem 4. If the honest majority assumption holds, Stubborn Nakamoto satisfies consistency and liveness for online nodes and late joiners.\n\nProof. The proof follows from Theorem 2 together with the observation that if consistency and liveness hold for online nodes, then Stubborn Nakamoto and the standard Nakamoto protocol generate identical executions for late joiners (in the sense that any honest node maintains the same finalized ledger).",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 19,
      "text": "# 4.4 Recovery \n\nWe turn to consider the recovery of Stubborn Nakamoto after an attack. An attacker with sufficient resources can cause nodes to halt and the protocol to lose liveness. But suppose that the attacker ends their efforts after some time, and the protocol regains honest majority. Can the protocol recover and regain liveness while maintaining consistency? In particular, can the protocol ensure that any block finalized by a node before or during the attack does not conflict with new blocks that are finalized after recovery?\n\nWe show that the Stubborn Nakamoto protocol can recover with external assistance that we model as a recovery oracle and that such external assistance is necessary. The recovery\n\noracle models a community response to the attack, allowing us to evaluate the necessary capabilities required from the community. Any protocol requires some community action to establish agreement on its rules. In particular, the Nakamoto protocol relies on an external agreement on a genesis block. ${ }^{57}$ We show that Stubborn Nakamoto can recover from an attack with a new genesis block provided by the recovery oracle.\n\nThe following defines a recovery oracle that enables the recovery of the Stubborn Nakamoto protocol. This definition formalizes the exact function the community (or another external source) must provide to the protocol. The recovery oracle is practical only if its capabilities are limited to those the community can plausibly implement. While we do not formally model the community's capabilities to achieve consensus, we bear in mind that the community must have been able to initiate the protocol and provide the genesis block (potentially through a costly process) but is unlikely to maintain real-time knowledge of every honest node's local view. Therefore, our definition of the recovery oracle relies solely on having access to the view of a single honest node.\n\nDefinition 7 (Recovery Oracle). A call to a recovery oracle at time $t$ updates the protocol's setup by creating a new genesis block $\\mathrm{B}_{G}$, which extends all clear-certified blocks in the view of some arbitrarily selected honest node. The call also awakes honest nodes that halted.\n\nIn other words, a call to the recovery oracle restarts the protocol in a similar manner to the initial launch of the Nakamoto protocol: the call announces a genesis block that any future chain must extend. All honest nodes ignore blocks that do not extend the new genesis block. The recovery oracle requires some contemporary knowledge of the state of honest nodes running the protocol, as it needs to maintain consistency with all finalized blocks. However, the recovery oracle is only required to know the state of a single (arbitrarily selected) honest node. Thus, we argue that this recovery oracle can be plausibly implemented by the community. ${ }^{58}$\n\nTheorem 5 (Consistency and liveness after recovery). Under synchrony, consider Stubborn Nakomoto with a call to the recovery oracle at time T. Suppose that the network-aware honest majority assumption holds from time $T$ onwards. Then, Stubborn Nakamoto satisfies consistency at any time and liveness after time $T$.\n\n[^0]\n[^0]:    ${ }^{57}$ That is, the participants of the protocol must achieve agreement on the genesis block by means that are out of protocol.\n    ${ }^{58}$ The Stubborn Nakamoto protocol is specifically designed to allow a recovery oracle that uses only limited capabilities (that the community can plausibly implement); see Lemma 2 and the discussion below.\n\nAn attacker with sufficient resources can cause the Stubborn Nakamoto protocol to lose liveness. Even after a call to the recovery oracle, the attacker can repeat its attack to cause the protocol to lose liveness again. Given the impossibility results mentioned above, such a loss of liveness is unavoidable for any protocol that maintains consistency. However, it is costly for the attacker to continuously violate liveness: each liveness violation requires the attacker to create an attack chain that certifies or potentially certifies a conflicting block, and all blocks in the attack chain are discarded after the call to the recovery oracle. Theorem 5 guarantees that when the attacker stops and Stubborn Nakamoto regains an honest majority, Stubborn Nakamoto recovers liveness (while maintaining consistency throughout).\n\nRemark 3. Theorem 5 holds under the protocol modification described in Remark 1. If online nodes detect an attack chain and ignore it without halting-while invoking the recovery oracle - then late joiners will be directed to the correct ledger by the recovery oracle, ensuring consistency.\n\nThe following lemma provides the key argument for the consistency of Stubborn Nakamoto after recovery. A genesis block establishes agreement on an initial ledger. Lemma 2 implies that the recovery oracle establishes a ledger that maintains consistency with any transactions finalized by honest nodes before recovery.\n\nLemma 2 (Consistency guarantees for recovery). If some honest node $i$ finalizes block B, then every honest node $j$ clear-certifies block B. If some honest node $i$ finalizes block B and does not halt, then all honest nodes finalize block B.\n\nProof. Suppose that honest node $i$ certified block $B$ at time $t_{1}$ and finalized block $B$ at time $t_{2}=t_{1}+2 \\Delta$. Let Chain $(\\widehat{\\mathrm{B}})$ be a logest chain in the view of node $i$ at time $t$ such that B is at least $k$-deep in Chain $(\\widehat{\\mathrm{B}})$.\n\nSuppose for the sake of contradiction that some honest node $j$ does not clear-certify B. Node $j$ receives Chain $(\\widehat{\\mathrm{B}})$ by time $t+\\Delta$. If Chain $(\\widehat{\\mathrm{B}})$ (or an extension of it) is a longest chain in the view of node $j$, then it must be that there is some block $\\mathrm{B}^{\\prime}$ such that $\\mathrm{B}^{\\prime} \\nsim \\mathrm{B}$ and $\\mathrm{B}^{\\prime} \\in \\mathcal{C}_{j}^{t+\\Delta}$. But then we have by Lemma 1 that $\\mathrm{B}^{\\prime} \\in \\mathcal{P} \\mathcal{C}_{i}^{t+2 \\Delta}(2 \\Delta)$, which is a contradiction to $i$ finalizing $B$.\n\nSuppose then that there is a longer chain $\\operatorname{Chain}\\left(\\widehat{\\mathrm{B}}^{\\prime}\\right)$ in the view of node $j$ at time $t+\\Delta$. Suppose that block B does not appear $k$-deep in Chain $\\left(\\widehat{\\mathrm{B}}^{\\prime}\\right)$ (otherwise, we reach a contradiction using the previous argument). Then there must be a block $\\mathrm{B}^{\\prime}$ that is at least $k$-deep in Chain $\\left(\\widehat{\\mathrm{B}}^{\\prime}\\right)$ and $\\mathrm{B}^{\\prime} \\nsim \\mathrm{B}$. Again, we have $\\mathrm{B}^{\\prime} \\in \\mathcal{C}_{j}^{t+\\Delta}$, leading to a contradiction.\n\nFor the second part of the proof, suppose that honest node $i$ certified block B at time $t_{1}$, finalized block B at time $t_{2}=t_{1}+2 \\Delta$, and did not halt at time $t_{3}=t_{1}+4 \\Delta$. By the previous part of the proof, every honest node $j$ clear-certified block B. Suppose for the sake of contradiction that some node $j$ did not finalize block B. Observe that node $j$ certified block B by time $t_{1}+\\Delta$, and therefore it must be that node $j$ halts without finalizing $B$ at some time $t^{\\prime} \\leq t_{1}+3 \\Delta$. But this implies that there exists some $\\mathrm{B}^{\\prime} \\in \\mathcal{P C}_{j}^{t^{\\prime}}(2 \\Delta)$ such that $\\mathrm{B}^{\\prime} \\nsim \\mathrm{B}$, and by Lemma 1 we have that $\\mathrm{B}^{\\prime} \\in \\mathcal{P C}_{i}^{t^{\\prime}+\\Delta}(4 \\Delta) \\subseteq \\mathcal{P C}_{i}^{t_{3}}(4 \\Delta)$ in contradiction to $i$ not halting at time $t_{3}$.\n\nThe proof of Theorem 5 follows from the lemma. A call to the recovery oracle maintains consistency and helps the protocol regain liveness when the attacker no longer controls a majority of the nodes. We remark that the theorem holds even when there are arbitrarily many calls to the recovery oracle.\n\nProof of Theorem 5. By Theorem 2, the protocol satisfies liveness after it recovers. By Theorem 1, if nodes $i, j$ finalize blocks $\\mathrm{B}, \\mathrm{B}^{\\prime}$ of the same height before recovery, then $\\mathrm{B}=\\mathrm{B}^{\\prime}$. Likewise, by Theorem 1, if nodes $i, j$ finalize blocks $\\mathrm{B}, \\mathrm{B}^{\\prime}$ of the same height after recovery, then $\\mathrm{B}=\\mathrm{B}^{\\prime}$. Suppose that node $i$ finalizes block B before recovery. By Lemma 2, every honest node clear-certified block B. Therefore, after recovery, the block B is part of the chain of the new genesis block $\\mathrm{B}_{G}$ and is finalized by any honest node $j$.\n\nThe Stubborn Nakamoto with a recovery oracle provides strong guarantees to users. Consistency is always guaranteed, and protocol participants cannot be deceived. An attacker can disrupt liveness, but only temporarily. An attacker can force the community to take potentially costly actions to implement the recovery oracle, but attacks are costly for the attacker (who needs to create blocks that are discarded). Because the existence of a recovery oracle limits the harm an attacker can cause, the recovery oracle may completely deter attackers without ever being used.\n\nThe protocol relies on the recovery oracle, but the recovery oracle's influence over the system is highly constrained. First, this dependence is necessary only after the protocol is attacked. Second, any honest node can assume the role of the recovery oracle. Third, the ambiguity that the recovery oracle addresses is minimal, as the protocol ensures agreement on all blocks except those finalized within a brief time window.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 20,
      "text": "# 4.5 Necessity of the recovery oracle \n\nCan an alternative protocol design achieve the same properties without reliance on an external recovery oracle? Can the functionality of the recovery oracle be provided within the protocol? This section shows that the answers to these questions are negative.\n\nThe recovery oracle serves several functions. It resolves some potential ambiguity among online nodes. ${ }^{59}$ It resolves potential ambiguity for late-joining nodes. It discards previous conflicting blocks by providing a new genesis block. Last, it informs nodes that halted that they should resume being active.\n\nIt may be possible to implement many of these roles within the protocol. Still, without an external recovery oracle, no protocol can guarantee that late-joining nodes adopt the correct ledger, potentially violating consistency for late joiners.\n\nAs an illustration, consider a late-joining node $i$ that attempts to join Bitcoin and become a miner. Several similar blockchains use Nakamoto consensus (for example, Dogecoin and Litecoin), and node $i$ must determine which of the chains is the Bitcoin blockchain. Formally, nodes are able to identify the Bitcoin blockchain by using the genesis block provided to it from the protocol's setup.\n\nHowever, there are also different blockchains that share Bitcoin's genesis block and its blockchain up to a certain block. For example, Bitcoin Cash was created by a so-called \"hard fork\" that split off from Bitcoin and created a new blockchain. The initial portions of the ledgers of Bitcoin and Bitcoin Cash are identical, but they are independent systems, and the later parts of their ledgers diverge. Node $i$ needs more recent information to determine whether it connects to Bitcoin or Bitcoin Cash, as these are separate blockchains that share the same initial genesis block. ${ }^{60}$ In particular, the total hash rate of each chain cannot provide the required identification, as node $i$ may be interested in connecting to the chain with a lower hash rate. The recovery oracle allows us to capture the fact that, in practice, users and nodes are able to access resources (external to the protocol) that can identify the two chains.\n\nMore generally, the following impossibility result asserts the necessity of the recovery oracle.\n\n[^0]\n[^0]:    ${ }^{59}$ Under corrupt majority, it is possible that some nodes finalize block $B$ and other nodes halt without finalizing $B$, and it is possible that some honest nodes certified block $B$ and other honest nodes certified block $\\mathrm{B}^{\\prime} \\neq \\mathrm{B}$ (and no node finalizes either block B or block $\\mathrm{B}^{\\prime}$ ).\n    ${ }^{60}$ The hard fork that created Bitcoin Cash included technical changes to the protocol. Bitcoin itself also adopted some technical changes at a later time. We assume that node $i$ arrives after both protocols have made these technical changes, and node $i$ must rely on an external resource to identify the correct chain.\n\nTheorem 6 (Necessity of the Recovery Oracle). Even under synchrony, there is no permissionless protocol that allows late joiners, always satisfies consistency, and for some $\\rho>0$ and $\\tau \\geq 0$ satisfies liveness after time $T+\\tau$ if from time $T$ onwards at least $1-\\rho$ of the nodes are honest.\n\nThe intuition for the proof is that under any permissionless protocol, the attacker can create a parallel copy of the ledger. We show that an attacker can simulate the execution to the point of recovery and bring a late-joining node to adopt a parallel copy that creates a consistency violation. Conceptually, such an attack is similar to a phishing attack which misdirects users to a malicious copy of a website. The attacks on Bitcoin discussed in Section 3 can be seen as instances of this general attack.\n\nProof. For the sake of contradiction, suppose that such a protocol exists for some $\\tau \\geq 0$ and $\\rho>0$. We show that an attacker can violate consistency for some late joiners.\n\nBy liveness, there is an execution in which all nodes are honest and some honest node $i$ finalizes a ledger Log at some time $t$. We can extend this execution by having the attacker create a conflicting ledger $\\log ^{\\prime}$ and send it to all nodes at time $t+1$. To do so, the attacker runs a parallel copy of the protocol by running $\\lceil 1 / \\rho\\rceil$ corrupt nodes for each honest node, where each corrupt node runs the protocol except for not communicating with honest nodes and ignoring messages from honest nodes. This allows the attacker to create a conflicting ledger $\\log ^{\\prime}$ that is finalized by the corrupt nodes.\n\nBecause the protocol is permissionless and the corrupt nodes simulate a different possible execution of the protocol, the ledgers Log, Log' are indistinguishable for late joiners. That is, a late joiner cannot know which ledger, Log or $\\log ^{\\prime}$, has been created by corrupt nodes that do not communicate and ignore messages.\n\nThe attacker continues to run $\\lceil 1 / \\rho\\rceil$ corrupt nodes for each honest node, where from time $T=t+1$ onwards, each corrupt node runs the protocol wholly and fully communicates with honest nodes (except that all the corrupt nodes have finalized $\\log ^{\\prime}$ instead of Log). At time $T$, a late joiner joins the protocol. Observe that for the late joiner, this execution is indistinguishable from an execution in which the corrupt and honest nodes swap roles (that is, honest nodes finalize $\\log ^{\\prime}$ and corrupt nodes finalize $\\log$ ) and at most a fraction $1 /(1+1 / \\rho)<\\rho$ are corrupt. Thus, at time $T+\\tau$, a late joiner believes the protocol regains liveness and finalizes a ledger that extends $\\log ^{\\prime}$, violating consistency.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 21,
      "text": "# 5 Partial Synchrony and Proof-of-Stake \n\nIn the years since Nakamoto (2008) showed the possibility of permissionless consensus, there has been extensive work exploring protocol designs. An influential alternative class of protocols is commonly known as Proof-of-Stake (PoS). This class includes a wide range of protocols, which differ in their approach to consensus and the extent to which nodes can freely enter and exit. ${ }^{61}$ The distinctive property of PoS protocols is the use of identities and stakes: each protocol node has an identifier and an associated account with a balance that can be controlled by the protocol (commonly called the stake).\n\nEstablishing node identifiers is helpful for both the consensus protocol and the incentives within the protocol. Identifiers allow the use of classical consensus approaches (for example, the Hotstuff protocol (Yin et al., 2019)), which require nodes to sign messages cryptographically. Signed messages can provide evidence of a node's actions, potentially allowing the protocol to identify faulty nodes (see Sheng et al. 2021, Neu et al. 2022) and punish them by reducing the balances in the node's associated accounts (commonly called slashing).\n\nOur framework offers two observations on PoS protocols. First, PoS protocols can deliver better economic security under weaker communication requirements. Second, we present a variation of Theorem 6 for PoS protocols.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 22,
      "text": "### 5.1 Economic security for a partitioned merchant\n\nThe ability to penalize nodes is particularly beneficial when communication is not synchronous. ${ }^{62}$ Consider an attacker attempting to deceive a merchant whose node is partitioned from the network. The partitioned merchant's node follows the protocol but only receives messages from the attacker. The merchant's node does not receive messages from other honest nodes in the network. Moreover, assume the merchant is unaware that it is partitioned (i.e., it cannot detect the lack of communication and halt). Assume that the merchant\n\n[^0]\n[^0]:    ${ }^{61}$ See Lewis-Pye and Roughgarden (2023) for a classification of the level of permissionlessness of different PoS protocols.\n    ${ }^{62}$ For example, a payment system may want to allow a merchant to accept payment even if they are offline (e.g., a farmers market). However, even traditional payment services may find it challenging to secure offline merchants. For example, the payment processor Square states on its website:\n    \"There is additional risk when accepting payments offline. Square is not responsible for any loss due to declined cards or expired payments taken while offline.\"\n    (https://squareup.com/help/us/en/article/7777-process-card-payments-with-offline-mode, accessed July 2024)\n\nremains partitioned for the duration of the attack but eventually reconnects to the network. ${ }^{63}$\nDefine the economic security for a partitioned merchant as the attacker's minimal cost of inflicting a consistency violation on a partitioned merchant.\n\nObserve that, under any permissionless protocol, the attacker can deceive a partitioned merchant by creating a conflicting copy of the ledger. To do so, the attacker simulates a parallel execution of the protocol that is indistinguishable from the protocol's correct operation to the partitioned merchant (recall that the merchant cannot communicate with honest nodes and hence cannot detect the existence of another, conflicting ledger). This observation implies an immediate upper bound on the economic security for a partitioned merchant.\n\nRemark 4. Under a permissionless protocol, the economic security for a partitioned merchant is upper bounded by the cost of simulating an execution of the protocol that leads the merchant's node to finalize a transaction, plus the potential costs of punishments incurred when the merchant reconnects and communicates with other honest nodes.\n\nUnder both Nakamoto and Stubborn Nakamoto, the attacker needs to create a conflicting chain of $k$ blocks to get the partitioned merchant to finalize a transaction and violate consistency. In the rental model, the attacker's cost of creating $k$ blocks is $k \\cdot p_{\\mathrm{B}}$. The two protocols differ in the response of honest nodes after the partition ends. Under Nakamoto, the attacker can induce all honest nodes to adopt its conflicting ledger, enabling the attacker to collect block rewards and recoup its costs (as described in Section 3.2). By contrast, under Stubborn Nakamoto, the net cost to the attacker remains $k \\cdot p_{\\mathrm{B}}$. The attacker can deceive a partitioned merchant, but conflicting blocks cannot become part of the consensus chain. Note that under Stubborn Nakamoto, nodes are anonymous, and there is no additional punishment for creating a conflicting chain.\n\nUnder many PoS protocols, the cost of simulating a (conflicting) execution of the protocol is negligible. Instead, the protocol may be able to detect and penalize nodes that create a conflicting ledger (for example, by witnessing the node's signature on the conflicting ledger). In particular, if the protocol can detect nodes that have deviated from the protocol, it may punish only the deviating nodes and thus avoid the tragedy of the commons ${ }^{64}$ described in Section 3.4.\n\n[^0]\n[^0]:    ${ }^{63}$ Such partitioned merchant is possible under both the asynchronous communication model and the partial synchrony communication model (Dwork et al., 1988), as the attacker may delay the delivery of messages (both to and from the merchant) for an arbitrary (but finite) length of time.\n    ${ }^{64}$ To completely avoid the tragedy of the commons, the protocol should punish deviating nodes even when there is no successful attack.\n\nTo establish an upper bound, consider a hypothetical PoS protocol that can perfectly identify all the nodes that create a conflicting ledger (and assume that the cost of protocol execution is 0 ). The maximal possible punishment that can be imposed on a node is the slashing of its entire stake (clearing the balance in the node's associated account). Thus, an upper bound for the attacker's total cost is the entire stake of all the nodes that created the conflicting ledger. In other words, the economic security for a partitioned merchant is bounded by the total amount of stake required to create an execution of the protocol that finalizes a transaction.\n\nA simple comparison suggests that punishment in PoS can lead to much greater economic security for a partitioned merchant than the cost of execution in Stubborn Nakamoto. If the Stubborn Nakamoto protocol spends $p_{\\mathrm{B}}$ per block, under the rental model, it achieves economic security for a partitioned merchant of $k \\cdot p_{\\mathrm{B}}$. A PoS protocol can potentially achieve greater economic security by requiring nodes to stake. Suppose that the cost of executing the protocol is negligible, and the protocol only needs to compensate nodes for forgone interest. In that case, block rewards should equal forgone interest on the total stake, and nodes provide a total stake of $p_{\\mathrm{B}} / r$, where $r$ is the interest rate per block. ${ }^{65}$ If the attacker suffers losses equal to a fraction $\\lambda$ of the total stake, the attacker's cost is $\\lambda p_{\\mathrm{B}} / r$.\n\nHowever, note that PoS protocols face several challenges that are omitted from the above discussion. It may be challenging to detect deviating nodes, and the protocol may detect only some of the deviating nodes (Sheng et al., 2021, Neu et al., 2022). If the protocol mistakenly slashes honest nodes, it must compensate all nodes for this potential harm. Moreover, the attacker may cause further deviations from the protocol to prevent the protocol from enacting the punishment (Budish et al., 2024).",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 23,
      "text": "# 5.2 Necessity of Recovery Oracles \n\nWe provide a version of the impossibility result given in Theorem 6 for PoS protocols. Consider a PoS protocol that guarantees consistency. Concurrent work of Sridhar et al. (2023) shows the feasibility of such PoS protocols under synchronous communication. But no protocol can always guarantee consistency and liveness under synchronous communication with late joiners (Pass and Shi, 2017a, Lewis-Pye and Roughgarden, 2023). ${ }^{66}$ Can a PoS\n\n[^0]\n[^0]:    ${ }^{65}$ The protocol can avoid these costs if it can invest the staked funds. We thank Niels Gormsen for this observation.\n    ${ }^{66}$ If all nodes are online and communication is synchronous, then the Dolev-Strong protocol guarantees consistency and liveness even without honest majority. But honest majority is necessary for the consistency of the Dolev-Strong protocol when late joiners are allowed.\n\nprotocol only lose liveness temporarily, halting progress while there is no honest majority, and regain liveness once honest majority is restored?\n\nBy Theorem 6, a recovery oracle is necessary if the protocol is permissionless. In practice, many PoS protocols require that active nodes approve late-joining nodes. ${ }^{67}$ This required approval can help secure the protocol by limiting the attacker's ability to simulate a conflicting protocol execution. However, such a limitation is helpful only if it introduces a different problem: the protocol can get stuck if no late-joining nodes are allowed to enter. We state this tension in the following corollary.\n\nCorollary 1. Consider a protocol that, under synchrony, allows late joiners, always satisfies consistency, and for some $\\rho>0$ and $\\tau \\geq 0$ satisfies liveness after time $T+\\tau$ if from time $T$ onwards at least a fraction $1-\\rho$ of the nodes are honest.\n\nThen there exists some $\\gamma \\leq 1$ such that if a fraction $\\gamma$ of the nodes crash, the protocol loses liveness forever.\n\nThe proof follows a similar argument to the proof of Theorem 6.\nProof. Suppose, for the sake of contradiction, that such a protocol exists and regains liveness at some time after all nodes crash at time $t$. Then, it must be possible for late-joining nodes to join the protocol at some time $\\tau>t$ despite all previous nodes crashing. Similarly to the proof of Theorem 6, the attacker can exploit this possibility to create a conflicting ledger $\\log ^{\\prime}$ by launching a separate collection of nodes that follow the protocol, except that they run as if all nodes crashed at time $t$.\n\nAlternatively, suppose that the attacker controls all existing nodes at time $t$. The attacker continues running the nodes but makes it appear as if all nodes crashed. New late-joining honest nodes enter the protocol and generate the ledger Log. Because a late joiner cannot distinguish between the two scenarios, the protocol cannot guarantee consistency for late joiners.\n\nCorollary 1 and Theorem 6 show that any protocol must require some external help under some scenarios: either to recover from attacks or to recover after all active nodes halt. In other words, some dependency on the community is unavoidable. Still, protocols can minimize this dependency by relying on external help only in rare scenarios and reducing the requirements needed for implementing such external help.\n\n[^0]\n[^0]:    ${ }^{67}$ For example, a node may be required to issue a transaction that establishes its stake before participating in the protocol. If such transactions are written to the ledger, and active nodes must process them (and can censor them), late-joining nodes will require approval from active nodes.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 24,
      "text": "# 6 Discussion \n\nOur results demonstrate the feasibility of an open-source record-keeping service that operates without a trusted record keeper. While users may not be concerned with the internal structure of the system, they can observe its beneficial properties: it protects its users from deception, allows for free entry and exit of operators, and protects users from monopoly's harm.\n\nCentral to our design is prioritizing consistency (security) over liveness (timely ledger updates). Roughly speaking, the Stubborn Nakamoto protocol either completely avoids the consistency violations of the Nakamoto protocol or converts them into liveness violations. We argue that financial applications should prioritize consistency over liveness. Recording a transaction in a financial ledger is beneficial only if other parties recognize that record. If the ledger is updated with records that are not recognized or are later invalidated, users do not receive any benefit and are exposed to deception and financial loss. Another justification for prioritizing consistency is that an attacker can clearly benefit from consistency violations that enable deception. By contrast, liveness violations do not offer the attacker such direct gains.\n\nMany questions about the design of payment systems are beyond the scope of this paper. The Stubborn Nakamoto protocol provides a general ledger, enabling users to record arbitrary data. Bitcoin is one example of such a payment system. The technology allows for many others. For example, the ledger could be used to record balances in USD or document land ownership. The system may allow users to be pseudoanonymous, or may requier that every user is fully identifiable. Such design choices raise a significant host of issues, including privacy concerns and anti-money laundering challenges. For a discussion of such challenges, see, for example, Rogoff (2017) and Makarov and Schoar (2022).\n\nFinally, one significant benefit of open-source technology is its inherent openness and modularity. Much like how anyone can join a permissionless protocol as a node, open-source frameworks enable developers to build upon existing services. This approach encourages innovation and competition in the market for higher-level services. For instance, while foundational Internet protocols such as TCP/IP may not be of much use to end users alone, they establish a crucial infrastructure enabling user-friendly commercial applications. Similarly, even permissionless protocols that provide limited functionality can be beneficial as foundational rails that allow firms to build more complex services, fostering a competitive market where diverse and innovative services can thrive.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 25,
      "text": "# References \n\nAbadi, J. and Brunnermeier, M. (2022). Blockchain economics. Working Paper.\nAbraham, I., Dolev, D., Gonen, R., and Halpern, J. (2006). Distributed computing meets game theory: robust mechanisms for rational secret sharing and multiparty computation. In Proceedings of the twenty-fifth annual ACM symposium on Principles of distributed computing, pages $53-62$.\n\nAdmati, A. and Hellwig, M. (2014). The bankers' new clothes: What's wrong with banking and what to do about it. Princeton University Press.\n\nAlvarez, F., Argente, D., and Van Patten, D. (2023). Are cryptocurrencies currencies? bitcoin as legal tender in el salvador. Science, 382(6677):eadd2844.\n\nAuer, R. (2019). Beyond the doomsday economics of 'proof-of-work' in cryptocurrencies. BIS working paper.\n\nAuer, R., Cornelli, G., Doerr, S., Frost, J., and Gambacorta, L. (2023). Crypto trading and bitcoin prices: evidence from a new database of retail adoption. CESifo Working Paper.\n\nBadertscher, C., Lu, Y., and Zikas, V. (2021). A rational protocol treatment of $51 \\%$ attacks. In Advances in Cryptology-CRYPTO 2021: 41st Annual International Cryptology Conference, CRYPTO 2021, Virtual Event, August 16-20, 2021, Proceedings, Part III 41, pages $3-32$. Springer.\n\nBiais, B., Bisiere, C., Bouvard, M., and Casamatta, C. (2019). The blockchain folk theorem. The Review of Financial Studies, 32(5):1662-1715.\n\nBIS (2023). The crypto ecosystem: key elements and risks. Report submitted to the G20 Finance Ministers and Central Bank Governors, July 2023.\nhttps://www.bis.org/publ/othp72.pdf (accessed Aug 2024).\nBonneau, J. (2016). Why buy when you can rent? bribery attacks on bitcoin-style consensus. In International Conference on Financial Cryptography and Data Security, pages 19-26. Springer.\n\nBudish, E., Lewis-Pye, A., and Roughgarden, T. (2024). The economic limits of permissionless consensus. arXiv preprint arXiv:2405.09173.\n\nBudish, E. B. (2022). The economic limits of bitcoin and anonymous, decentralized trust on the blockchain. University of Chicago, Becker Friedman Institute for Economics Working Paper.\n\nButerin, V. (2016). A proof of stake design philosophy. Blog post, https://medium.com/@VitalikButerin/a-proof-of-stake-design-philosophy-506585978d51. Accessed: Feb 2025.\n\nButerin, V. (2023). Don't overload ethereum's consensus. https://vitalik.eth.limo/general/2023/05/21/dont_overload.html. Blog post [Online; accessed 25-Feb-2025].\n\nButerin, V. and Griffith, V. (2017). Casper the friendly finality gadget. arXiv preprint arXiv:1710.09437.\n\nButerin, V. and Zamfir, V. (2015). Casper. https://blog.ethereum.org/2015/08/01/introducing-casper.\n\nCai, L., Liu, J., Weinberg, S. M., and Zhou, C. (2024). Profitable manipulations of cryptographic self-selection are statistically detectable. arXiv preprint arXiv:2407.16949.\n\nCarlsten, M., Kalodner, H., Weinberg, S. M., and Narayanan, A. (2016). On the instability of bitcoin without the block reward. In Proceedings of the 2016 ACM SIGSAC conference on computer and communications security, pages 154-167.\n\nCastro, M., Liskov, B., et al. (1999). Practical byzantine fault tolerance. In OsDI, volume 99, pages $173-186$.\n\nChiu, J. and Koeppl, T. V. (2022). The economics of cryptocurrency: Bitcoin and beyond. Canadian Journal of Economics/Revue canadienne d'\u00e9conomique, 55(4):1762-1798.\n\nCNBC (2024). Buyers during berkshire price glitch can't keep their big bargains. https://link.cnbc.com/public/35649502. [Online; accessed 25-Feb-2025].\n\nDaian, P., Pass, R., and Shi, E. (2019). Snow white: Provably secure proofs of stake. In $F C$.\nDixon, C. (2024). Read Write Own: Building the Next Era of the Internet. Random House.\nDOJ (2010). U.s. and plaintiff states v. american express co., et al., no. 104496 (e.d.n.y. 2010). United States Department of Justice, Antitrust Division https://www.justice.gov/atr/case/us-and-plaintiff-states-v-american-express-co-et-al. Accessed: 2024-09-09.\n\nDOJ (2020). DOJ blocks Visa's acquisition of Plaid. https://www.justice.gov/opa/pr/justice-department-sues-block-visas-proposed-acquisition. Accessed: 2024-09-09.\n\nDolev, D. and Strong, H. R. (1983). Authenticated algorithms for byzantine agreement. SIAM Journal on Computing, 12(4):656-666.\n\nDonmez, A. and Karaivanov, A. (2022). Transaction fee economics in the ethereum blockchain. Economic Inquiry, 60(1):265-292.\n\nDwork, C., Lynch, N., and Stockmeyer, L. (1988). Consensus in the presence of partial synchrony. Journal of the ACM (JACM), 35(2):288-323.\n\nEasley, D., O\u2019Hara, M., and Basu, S. (2019). From mining to markets: The evolution of bitcoin transaction fees. Journal of Financial Economics, 134(1):91-109.\n\nEthereum Classic (2022). Code is law. https://ethereumclassic.org/why-classic/code-is-law. Web page [Online; accessed 25-Feb-2025].\n\nEthereum Foundation (2016). Hard fork completed. https://blog.ethereum.org/2016/07/20/hard-fork-completed. Blog post [Online; accessed 25-Feb-2025].\n\nEthereum Foundation (2023). Weak subjectivity. Ethereum Blog, https://ethereum.org/en/developers/docs/consensus-mechanisms/pos/weak-subjectivity/.\n\nEuropean Parliament and Council (2015). Regulation (eu) 2015/751 on interchange fees for card-based payment transactions. https://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX\\ 15RO751. Accessed: 2024-09-09.\n\nEyal, I. and Sirer, E. G. (2018). Majority is not enough: Bitcoin mining is vulnerable. Communications of the ACM, 61(7):95-102.\n\nFischer, M. J., Lynch, N. A., and Paterson, M. S. (1985). Impossibility of distributed consensus with one faulty process. Journal of the ACM (JACM), 32(2):374-382.\n\nGans, J. S. and Halaburda, H. (2024). \"zero cost\" majority attacks on permissionless proof of work blockchains. Management Science.\n\nGaray, J., Katz, J., Maurer, U., Tackmann, B., and Zikas, V. (2013). Rational protocol design: Cryptography against incentive-driven adversaries. In 2013 IEEE 54th Annual Symposium on Foundations of Computer Science, pages 648-657. IEEE.\n\nGaray, J., Kiayias, A., and Leonardos, N. (2015). The bitcoin backbone protocol: Analysis and applications. In Annual international conference on the theory and applications of cryptographic techniques, pages 281-310. Springer.\n\nGarratt, R. J. and van Oordt, M. R. (2023). Why fixed costs matter for proof-of-work-based cryptocurrencies. Management Science, 69(11):6482-6507.\n\nGreenwood, R. and Scharfstein, D. (2013). The growth of finance. Journal of Economic perspectives, 27(2):3-28.\n\nGuiso, L., Sapienza, P., and Zingales, L. (2004). The role of social capital in financial development. American economic review, 94(3):526-556.\n\nGuiso, L., Sapienza, P., and Zingales, L. (2008). Trusting the stock market. the Journal of Finance, 63(6):2557-2600.\n\nGuo, D. and Ren, L. (2022). Bitcoin's latency-security analysis made simple. arXiv preprint arXiv:2203.06357.\n\nHalaburda, H., Haeringer, G., Gans, J., and Gandal, N. (2022). The microeconomics of cryptocurrencies. Journal of Economic Literature, 60(3):971-1013.\n\nHalaburda, H., He, Z., and Li, J. (2021). An economic model of consensus on distributed ledgers. Technical report, National Bureau of Economic Research.\n\nHayashi, F. and Maniff, J. L. (2019). Public authority involvement in payment card markets: Various countries-august 2019 update. Federal Reserve Bank of Kansas City.\n\nHerkenhoff, K. F. and Raveendranathan, G. (2020). Who bears the welfare costs of monopoly? the case of the credit card industry. Technical report, National Bureau of Economic Research.\n\nHuberman, G., Leshno, J. D., and Moallemi, C. (2021). Monopoly without a monopolist: An economic analysis of the bitcoin payment system. The Review of Economic Studies, 88(6):3011-3040.\n\nJudmayer, A., Stifter, N., Zamyatin, A., Tsabary, I., Eyal, I., Gazi, P., Meiklejohn, S., and Weippl, E. (2021). Pay to win: Cheap, crowdfundable, cross-chain algorithmic incentive manipulation attacks on pow cryptocurrencies. In FC WTSC.\n\nKarakostas, D. and Kiayias, A. (2021). Securing proof-of-work ledgers via checkpointing. In 2021 IEEE International Conference on Blockchain and Cryptocurrency (ICBC).\n\nKiayias, A., Koutsoupias, E., Kyropoulou, M., and Tselekounis, Y. (2016). Blockchain mining games. In Proceedings of the 2016 ACM Conference on Economics and Computation, pages $365-382$.\n\nKocherlakota, N. R. (1998). Money is memory. journal of economic theory, 81(2):232-251.\nLa Porta, R., Lopez-de Silanes, F., and Shleifer, A. (2006). What works in securities laws? The journal of finance, 61(1):1-32.\n\nLamport, L. (2001). Paxos made simple. ACM SIGACT News (Distributed Computing Column) 32, 4 (Whole Number 121, December 2001), pages 51-58.\n\nLamport, L., Shostak, R., and Pease, M. (1982). The byzantine generals problem. ACM Transactions on Programming Languages and Systems, 4(3):382-401.\n\nLeslie, L. (1998). The part-time parliament. ACM Trans. on Computer Systems, 16:133-169.\nLewis-Pye, A. and Roughgarden, T. (2023). Permissionless consensus. arXiv preprint arXiv:2304.14701.\n\nMakarov, I. and Schoar, A. (2021). Blockchain analysis of the bitcoin market. Technical report, National Bureau of Economic Research.\n\nMakarov, I. and Schoar, A. (2022). Cryptocurrencies and decentralized finance (defi). Brookings Papers on Economic Activity, 2022(1):141-215.\n\nMcCorry, P., Hicks, A., and Meiklejohn, S. (2018). Smart contracts for bribing miners. In Financial Cryptography Workshops, volume 10958 of Lecture Notes in Computer Science, pages 3-18. Springer.\n\nMcKinsey and Company (2023). The 2023 mckinsey global payments report.\nMoroz, D. J., Aronoff, D. J., Narula, N., and Parkes, D. C. (2020). Double-spend counterattacks: Threat of retaliation in proof-of-work systems. arXiv preprint arXiv:2002.10736.\n\nNakamoto, S. (2008). Bitcoin: A Peer-to-Peer Electronic Cash System. http://bitcoin.org/bitcoin.pdf.\n\nNesbitt, M. (2019). Deep chain reorganization detected on ethereum classic (etc). Coinbase Blog, https://www.coinbase.com/blog/deep-chain-reorganization-detected-on-ethereum-classic-realization-00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n\nPrat, J. and Walter, B. (2021). An equilibrium model of the market for bitcoin mining. Journal of Political Economy, 129(8):2415-2452.\n\nRajan, R. and Zingales, L. (1998). Financial dependence and growth. American Economic Review, 88(3):559-86.\n\nRogoff, K. (2017). The curse of cash: How large-denomination bills aid crime and tax evasion and constrain monetary policy. Princeton University Press.\n\nSankagiri, S., Wang, X., Kannan, S., and Viswanath, P. (2021). Blockchain cap theorem allows user-dependent adaptivity and finality. In Financial Cryptography and Data Security: 25th International Conference, FC 2021, Virtual Event, March 1-5, 2021, Revised Selected Papers, Part II 25, pages 84-103. Springer.\n\nSchumpeter, J. A. (1911). A theory of economic development. Harvard University Press.\nShanaev, S., Shuraeva, A., Vasenin, M., and Kuznetsov, M. (2019). Cryptocurrency value and $51 \\%$ attacks: evidence from event studies. The Journal of Alternative Investments, 22(3):65-77.\n\nSheng, P., Wang, G., Nayak, K., Kannan, S., and Viswanath, P. (2021). BFT protocol forensics. In CCS '21: 2021 ACM SIGSAC Conference on Computer and Communications Security, Virtual Event, Republic of Korea, November 15 - 19, 2021, pages 1722-1743. ACM.\n\nShi, E. (2022). Foundations of distributed consensus and blockchains. Textbook, https://www.distributedconsensus.net/.\n\nSridhar, S., Tas, E. N., Neu, J., Zindros, D., and Tse, D. (2024). Consensus under adversary majority done right. arXiv preprint arXiv:2411.01689.\n\nSridhar, S., Zindros, D., and Tse, D. (2023). Better safe than sorry: Recovering after adversarial majority. arXiv preprint arXiv:2310.06338.\n\nTabarrok, A. (2019). Bitcoin is less secure than most people think. https://marginalrevolution.com/marginalrevolution/2019/01/bitcoin-much-less-secure-people-think.html, Retrieved Mar, 2024.\n\nWinzer, F., Herd, B., and Faust, S. (2019). Temporary censorship attacks in the presence of rational miners. In 2019 IEEE European Symposium on Security and Privacy Workshops (EuroS PW), pages 357-366.\n\nYermack, D. (2019). Blockchain technology's potential in the financial system. In Proceedings of the 2019 Financial Market's Conference.\n\nYin, M., Malkhi, D., Reiter, M. K., Gueta, G. G., and Abraham, I. (2019). Hotstuff: Bft consensus with linearity and responsiveness. In Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing, pages 347-356.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 26,
      "text": "# A Distributed Consensus Formal Execution Model \n\nThe proof of Theorem 2 uses a similar approach to the proof of consistency and liveness of the Nakamoto protocol of Pass et al. (2017), Shi (2022). The proof requires a few additional definitions and utilizes several stochastic bounds that were proved in earlier works (Pass et al., 2017, Shi, 2022). We state these here.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 27,
      "text": "## A. 1 Execution model\n\nWe introduce some notation regarding the protocol's execution model in order to formally state the conditions under which Nakamoto has provable guarantees.\n\nWe assume that $n$ nodes participate in the consensus protocol, all with equal mining power. ${ }^{68}$ Time is discrete and divided into rounds. Each round corresponds to one calculation of a hash by a miner. Let $p$ be the probability that a single node finds a valid block in a round, where the probability $p$ is related to the mining difficulty parameter. We use the notation $\\rho \\in[0,1)$ to denote the fraction of nodes controlled by the adversary.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 28,
      "text": "## A. 2 Definitions\n\nBecause the Nakamoto consensus protocol requires randomness, a small probability of failure may be inevitable. The formal definition of liveness for the Nakamoto and Stubborn Nakamoto protocols bounds the failure probability by a security parameter $\\lambda$. The protocol\n\n[^0]\n[^0]:    ${ }^{68} \\mathrm{~A}$ node with larger mining power can be viewed as multiple nodes.\n\ncan tune its security parameter $\\lambda$ by selecting a required block depth $k$, such that $k=$ $\\omega(\\log \\lambda)$.\n\nFor the sake of simplicity, we assume that an honest node that mines a block can include all the outstanding valid transactions (not included in the longest chain) given its local view. Let $T_{\\text {conf }}=T_{\\text {conf }}(\\lambda, \\Delta, n, \\rho)$ be a function of the security parameter $\\lambda$, network delay $\\Delta$, number of nodes $n$, and fraction of adversary nodes $\\rho$. We call $T_{\\text {conf }}$ the confirmation time.\n\nDefinition 8 ( $T_{\\text {conf }}$-Liveness). The protocol satisfies $T_{\\text {conf }}$-Liveness if there is some negligiblessfunction $\\operatorname{negl}(\\cdot)$ such that with $1-\\operatorname{negl}(\\lambda)$ probability when some honest node receives a transaction $\\mathrm{tx}$ at some time $t$, then by time $t+T_{\\text {conf }}$ all honest nodes' finalized ledgers include tx.\n\nWe can now formally state the network-aware honest majority assumption used in Theorem 2 .\n\nDefinition 9 (Network-Aware Honest Majority). Consider a polynomial length execution of Stubborn Nakamoto with a required block depth $k$ that is super-logarithmic function in the desired security parameter $\\lambda$. Let $\\nu=2 p n \\Delta$. The Network-Aware Honest Majority assumption is satisfied if $\\nu<1 / 2$ and there exists some (arbitrarily small) constant $\\phi \\in(0,1)$ such that\n\n$$\n(1-\\rho)(1-\\nu) \\geq(1+\\phi) \\rho\n$$\n\nThe term $(1-\\rho)(1-\\nu)$ can be viewed as the fraction of honest mining power discounted by the network delay $\\Delta$. Therefore, this assumption requires that the honest mining power, even after accounting for network delay, exceeds the corrupt mining power by a small constant margin.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 29,
      "text": "# A. 3 Stochastic bounds \n\nThe following stochastic bounds proved in earlier works (Pass et al., 2017, Shi, 2022) are used in the proof of Theorem 2. We state them here for completeness.\n\nDefine convergence opportunity in the same way as Section 17.3 of Shi (2022). Specifically, round $t$ is a convergence opportunity if a single honest block is mined in round $t$ and no honest blocks are mined in the surrounding $\\Delta$ rounds before and after. Given a run of\n\n[^0]\n[^0]:    ${ }^{69}$ We say that negl $: \\mathbb{R} \\rightarrow \\mathbb{R}_{+}$is a negligible function iff for any fixed polynomial function $p(\\lambda)$, there exists $\\lambda_{0}$ such that for any $\\lambda>\\lambda_{0}$, negl $(\\lambda)<1 / p(\\lambda)$. In other words, a negligible function is one that vanishes faster than any inverse-polynomial function.\n\nNakamoto or Stubborn Nakamoto, let $\\mathbf{C}\\left[t: t^{\\prime}\\right]$ denote the number of convergence opportunities between $t$ and $t^{\\prime}$, and let $\\mathbf{A}\\left[t: t^{\\prime}\\right]$ denote the number of adversarial blocks ${ }^{70}$ mined between $t$ and $t^{\\prime}$. Let $\\alpha:=p \\cdot(1-\\rho) n$ denote the expected number of honest nodes that mine a block in a given round, and let $\\beta:=p \\cdot \\rho n$ denote the expected number of corrupt nodes that mine a block in each round.\n\nLemma A. 1 (Lower bound on convergence opportunities (Pass et al., 2017, Shi, 2022)). For any positive constant $\\varepsilon>0$ and any $k$ that is a super-logarithmic function in $\\lambda$, except with negligibly small in $\\lambda$ probability over the choice of the execution, the following holds: for any $t_{0}, t_{1} \\geq 0$ such that $t:=t_{1}-t_{0}>k / \\alpha$, we have that\n\n$$\nC\\left[t_{0}: t_{1}\\right]>(1-\\varepsilon)(1-2 p n \\Delta) \\alpha t\n$$\n\nLemma A. 2 (Upper bound on adversarially mined blocks (Pass et al., 2017, Shi, 2022)). For any constant $0<\\varepsilon<1$, for any $k$ that is a super-logarithmic function in $\\lambda$, except with negligibly small in $\\lambda$ probability over the choice of the execution, the following holds: for any $t_{0}, t_{1} \\geq 0$ such that $t:=t_{1}-t_{0}>k / \\beta$, we have that\n\n$$\nA\\left[t_{0}: t_{1}\\right] \\leq(1+\\varepsilon) \\beta t\n$$\n\nfor any $t \\geq k / \\beta$. That is, the number of adversarially mined blocks in any $t$-sized window is upper bounded by $(1+\\epsilon) \\beta t$.\n\nLemma A. 3 (Total block upper bound (Pass et al., 2017, Shi, 2022)). For any positive constant $\\varepsilon$ and any $k$ that is a super-logarithmic function in $\\lambda$, except with negligibly small in $\\lambda$ probability over the choice of the execution, the following holds: for any $t_{0}$ and $t_{1}$ such that $n p\\left(t_{1}-t_{0}\\right) \\geq k$, the total number of blocks successfully mined during $\\left(t_{0}, t_{1}\\right]$ by all nodes (honest and corrupt alike) is upper bounded by $(1+\\varepsilon) n p\\left(t_{1}-t_{0}\\right)$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 30,
      "text": "# A. 4 Proof of Theorem 2 \n\nProof of Theorem 2. Given an execution of the Stubborn Nakamoto protocol, we can construct an execution of the Nakamoto ${ }^{71}$ protocol. If the two executions are identical, in the sense that any honest node maintains the same finalized ledger at any point during the run,\n\n[^0]\n[^0]:    ${ }^{70}$ That is, blocks mined by nodes that are not honest nodes.\n    ${ }^{71}$ We use the same confirmation depth $k$ as our Stubborn Nakamoto for the execution of the Nakamoto protocol.\n\nthen Stubborn Nakamoto's properties follow from those of Nakamoto. We show that under the network-aware honest majority assumption, the two executions are identical except for a negligible probability, and therefore the $T_{\\text {conf }}$-Liveness of Stubborn Nakamoto follows from the $T_{\\text {conf }}$-Liveness and consistency of Nakamoto (Pass et al., 2017, Shi, 2022).\n\nThe reason the executions may differ is that an honest node $i$ may halt under Stubborn Nakamoto. Consider the first round $t_{1}$ such that some honest node $i$ certifies a block B and by round $t_{1}+4 \\Delta$ node $i$ halts having seen a $4 \\Delta$-potentially certified block $\\mathrm{B}^{\\prime}$ that conflicts with B. (That is, node $i$ halted at either steps 1,2 or 3 )\n\nLet $\\operatorname{Chain}(\\overline{\\mathrm{B}})$ be the chain in node $i$ 's local view in round $t_{1}$ containing B at least $k$-deep. Let $\\mathrm{B}^{\\prime} \\in \\mathcal{P C}_{i}^{t_{1}+4 \\Delta}(4 \\Delta)$ be a block that conflicts with B , and let $t_{1} \\leq t \\leq t_{1}+4 \\Delta$ be the fist time at which $\\mathrm{B}^{\\prime} \\in \\mathcal{P C}_{i}^{t}(4 \\Delta)$. Let Chain $\\left(\\overline{\\mathrm{B}}^{\\prime}\\right)$ be the chain in node $i$ 's local record such that $h\\left(\\overline{\\mathrm{~B}}^{\\prime}\\right)-h\\left(\\mathrm{~B}^{\\prime}\\right)+1 \\geq k$ and $h\\left(\\overline{\\mathrm{~B}}^{\\prime}\\right) \\geq h(\\overline{\\mathrm{~B}})$ for any $\\overline{\\mathrm{B}} \\in \\operatorname{View}_{i}^{t-4 \\Delta}$. That is, block $\\mathrm{B}^{\\prime}$ is at least $k$-deep in the chain $\\operatorname{Chain}\\left(\\overline{\\mathrm{B}}^{\\prime}\\right)$, and the chain $\\operatorname{Chain}\\left(\\overline{\\mathrm{B}}^{\\prime}\\right)$ is longer than any chain in the view of node $i$ as of $t-4 \\Delta$.\n\nLet $\\mathrm{B}_{\\text {common }}$ the last block shared in common by Chain $(\\overline{\\mathrm{B}})$ and Chain $\\left(\\overline{\\mathrm{B}}^{\\prime}\\right)$. Suppose that $\\mathrm{B}_{\\text {common }}$ is mined in round $s-1$. It holds that all blocks in Chain( $\\overline{\\mathrm{B}}$ ) and Chain( $\\overline{\\mathrm{B}}^{\\prime}$ ) after $\\mathrm{B}_{\\text {common }}$ are mined in round $s$ or later. Let $\\tau=t-s$. Because the chains Chain( $\\overline{\\mathrm{B}}$ ) and Chain $\\left(\\overline{\\mathrm{B}}^{\\prime}\\right)$ differ by at least $k$ blocks, by total block upper bound (see Lemma A.3), it must be that $\\tau>\\frac{k}{2 p n}$.\n\nObserve that it must be that $\\mathbf{C}[s: t-5 \\Delta] \\leq \\mathbf{A}[s: t]$. Otherwise, there would have been a block B mined by an honest node during a convergence opportunity within $[s, t-4 \\Delta-\\Delta]$, and that block B would have to appear in both Chain( $\\overline{\\mathrm{B}}$ ) and Chain( $\\overline{\\mathrm{B}}$ ) (see Section 17.3 of Shi 2022). Therefore, it suffices to prove that, except with negligible $\\lambda$ probability, it must be that $\\mathbf{C}[s: t-5 \\Delta]>\\mathbf{A}[s: t]$.\n\nLet there be some $\\varepsilon, \\varepsilon^{\\prime} \\in(0,1)$. By the lower bound on convergence opportunity (see Lemma A.1), except with negligible probability, we have that\n\n$$\n\\mathbf{C}[s: t-5 \\Delta]>(1-\\varepsilon)(1-2 p n \\Delta) \\alpha(\\tau-5 \\Delta)\n$$\n\nwhere $\\alpha:=p \\cdot(1-\\rho) n$ denotes the expected number of honest nodes that mine a block in a given round. By adversarial block upper bound, (see Lemma A.2) we have that for any positive constant $\\varepsilon_{a}$, it holds that\n\n$$\n\\mathbf{A}[s: t]<\\left(1+\\epsilon_{a}\\right) \\beta \\tau\n$$\n\nwhere $\\beta=p \\cdot \\rho n$ denotes the expected number of corrupt nodes that mine a block in each round.\n\nThus, for any positive constant $\\phi>0$, as long as $0<2 p n \\Delta<0.5$, there exist sufficiently small positive constants $\\varepsilon, \\varepsilon^{\\prime}$, and $\\varepsilon_{1}$ such that the following holds for sufficiently large $k$ :\n\n$$\n\\begin{aligned}\n\\mathbf{C}[s: t-5 \\Delta] & >(1-\\varepsilon)(1-\\nu) \\alpha(\\tau-5 \\Delta) \\\\\n& >\\left(1-\\varepsilon_{1}\\right)(1-\\nu) \\alpha \\tau \\\\\n& >\\left(1-\\varepsilon_{1}\\right)(1+\\phi) \\beta \\tau \\\\\n& >\\left(1+\\varepsilon^{\\prime}\\right)\\left(1+\\frac{\\phi}{2}\\right) \\beta \\tau \\\\\n& >\\left(1+\\varepsilon^{\\prime}\\right) \\beta \\tau\n\\end{aligned}\n$$\n\nwhere the last inequality holds for sufficiently large $k$ because $\\alpha \\Delta=O(1)$ and $\\alpha \\tau=\\Theta(k)$.\nThis implies that except with negligible in $\\lambda$ probability we have that $\\mathbf{C}[s: t-5 \\Delta]>$ $\\mathbf{A}[s: t]$, completing the proof.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 31,
      "text": "# B Other Omitted Proofs \n\nProof of Proposition 1. Suppose that the transaction of interest to the attacker and merchant is in block $\\mathrm{B}_{n}$. The attacker waits for the merchant to confirm the transaction, which (by liveness) occurs at some time $t$. Suppose that at time $t$ the longest chain recorded by any honest miner is $\\left(B_{0}, \\ldots, B_{n-1}, B_{n}, \\ldots, B_{n+K}\\right)$.\n\nAt time $t$, the attacker mines the attack chain $\\left(B_{0}, \\ldots, B_{n-1}, B_{n}^{\\prime}, \\ldots, B_{n+L}^{\\prime}\\right)$ for some $L>K$ and communicates it immediately to all other miners. If the attack chain is the longest chain known to any miner, it becomes the consensus chain and is adopted by all honest miners.\n\nThe attacker pays $D \\cdot c$ in expectation per mined block. If honest miners adopt the attack chain, the attacker receives $p_{\\mathrm{B}}$ per mined block. Because honest miners also pay $D \\cdot c$ in expectation per mined block and are profit-maximizing, it must be that $p_{\\mathrm{B}} \\geq D \\cdot c$, and the attacker's net cost is zero. Finally, the probability that the attack chain of height $n+L$ becomes the longest chain can be arbitrarily close to one if the attacker computes the same number of hashes over a shorter time.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 32,
      "text": "# C Examples of Profitable Consistency Violations \n\nAttackers can profit from consistency violations by deceiving and taking advantage of a counterparty. We give a few examples.\n\nDouble spend The commonly considered double-spend attack is a form of consistency violation. In it, the attacker sends the same funds to two different parties in two different transactions, but only one of the two can be valid. If consistency holds, the receiving party can detect which transaction is valid. Conversely, if the attacker can deceive a merchant who follows the protocol into accepting a transaction that conflicts with the consensus ledger, then consistency is violated.\n\nHistory rewrite Consistency requires that any node's local ledger agrees with any previously finalized data. In particular, it implies that the ledger cannot revert finalized transactions. A dishonest attacker can gain if they can undo a finalized transaction. For example, consider a transaction that transfers ownership of an asset from the attacker to a merchant. If the price of the asset increases after the sale, the attacker can benefit from reverting the transaction and retroactively canceling the transfer of ownership.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 33,
      "text": "## D Other Factors Deterring Attacks\n\nThis section explores additional factors that deter attacks. Despite numerous attacks on cryptocurrencies using the Nakamoto protocol, major cryptocurrencies such as Bitcoin and Ethereum have remained secure. The rental model and the bribery model discussed in Section 3 fail to explain why attacks on these protocols are not commonplace. This indicates that, in practice, other factors contribute to deterring attacks. We discuss such factors and identify elements that can be incorporated into protocol design to enhance security.\n\nWe categorize these factors into three groups. First is the user community's reaction to an attack on the protocol. The second category encompasses economic frictions that hinder the execution of an attack. The third category includes reasons for the system's security that suggest that the system is secure because it is not in fact decentralized. Altogether, the discussion suggests that Bitcoin's economic security comes not from the cost of mining but rather from these external deterrents described below.\n\nCommunity response Even if the attack is not detectable within the protocol, the community can detect an attack. Much of the literature (e.g., Budish 2022, Auer 2019, Garratt and van Oordt 2023) considers that an attack will trigger a decline in the cryptocurrency exchange rate. This assumption inherently relies on the public's awareness that an attack has occurred.\n\nIn practice, the community can identify the attack fork and the honest fork under the attack described in 3.2. As described in Section 3, in the view of an honest node, an attack appears to be a reconciliation after a network partition. That is, an honest node will receive the blocks in the attack fork significantly later than blocks of comparable height in the honest fork. ${ }^{72}$ Any honest node active during the attack can recognize the attack chain as either a deliberate attack or a highly improbable event of partition reconciliation.\n\nThe community can collectively decide to undo the attack. If the community agrees that the miners were attacked and the ledger was changed illegally, the community can direct all miners to follow with the correct honest fork and ignore the attack fork. Doing so reverts any effect of the attack, leaving the ledger unchanged by the attack. The community response poses a significant risk to the attacker, who is left to pay all costs of the attack, but without the attack having any eventual effect on the ledger.\n\nWhile community-driven interventions in blockchain networks are rare, they are not without precedent. A notable instance is the Ethereum community's decision to amend the Ethereum ledger in response to the DAO attack. ${ }^{73}$ Such measures, however, necessitate a community that possesses both the capability and the willingness to undertake manual interventions. For example, Ethereum Classic rejects such manual interventions. ${ }^{74}$ Interestingly, Ethereum did not suffer any consistency attacks, whereas Ethereum Classic suffered from multiple attacks. ${ }^{75}$\n\nNote that a community response can deter attacks even if the community can only detect an attack (without agreeing on the correct ledger that should be restored). As discussed in Section 3.4, preventing the attacker from collecting the block rewards after the attack lowers the payment to attackers relative to honest miners (when there is no attack). This creates\n\n[^0]\n[^0]:    ${ }^{72}$ The attacker must keep hidden the blocks in the attack chain $\\left(\\mathrm{B}_{n}^{\\prime}, \\ldots, \\mathrm{B}_{n+L}^{\\prime}\\right)$ until the merchant finalizes the block $\\mathrm{B}_{n}$ (otherwise, the merchant will not finalize $\\mathrm{B}_{n}$ ). Thus, an honest miner receives block $\\mathrm{B}_{n}^{\\prime}$ only after receiving block $\\mathrm{B}_{n+k}$, which it receives significantly later than block $\\mathrm{B}_{n}$. Recall that honest nodes mine conflicting blocks $\\mathrm{B}_{n}, \\mathrm{~B}_{n}^{\\prime}$ only if these blocks are mined simultaneously (up to network delays).\n    ${ }^{73}$ See, for example, https://blog.ethereum.org/2016/07/20/hard-fork-completed, accessed February 2024 .\n    ${ }^{74}$ https://ethereumclassic.org/why-classic/code-is-law\n    ${ }^{75}$ https://www.coinbase.com/blog/deep-chain-reorganization-detected-on-ethereum-classic-etc, accessed February 2024.\n\na penalty for an attack that generates some detterance.\n\nFrictions In practice, it may be difficult to operationalize an attack. For example, even if a bribery contract is financially beneficial for miners, it may be difficult to inform and recruit miners. Moreover, miners may not be fully profit-driven, or may be altruistic. This poses a risk to the attacker. A bribery attack needs to commit to paying miners who mine blocks in the attack chain. If the bribery attack fails to solicit enough mining power to cooperate, the attacker faces financial risk from paying for blocks on the attack chain only for the attack to fails.\n\nThe analysis in Section 3 assumes that block rewards are fixed and there is no difficulty adjustment. Gans and Halaburda (2024) show that an attacker can gain by affecting block rewards and, in particular, transaction fees. The attacker is advantaged as it can observe all the transactions processed by honest miners, and can collect all fees from transactions that are not invalidated by the attack. ${ }^{76}$\n\nThe difficulty adjustment can also be exploited by the attacker. For example, mining difficulty increases over time as mining equipment becomes more efficient, and the attacker can benefit from forking old blocks with lower difficulty using current mining equipment.\n\nCentralized factors An attacker may be deterred by the threat of legal prosecution. In practice, to cash out from an attack, the attacker will need to withdraw fiat money from some exchange. However, exchanges are subject to know-your-customer (KYC) rules that require them to know the identities of their customers. ${ }^{77}$\n\nThe analysis in Section 3.4 of the bribery model assumes small players with infinitesimally small mining power, whose actions are non-pivotal to the outcome whether the attack succeeds or not. In practice, mining power is more concentrated in the form of mining farms and mining pools. For a big miner, whether it cooperates in the attack may be pivotal to whether the attack is successful. For example, consider the extreme case where the attack is guaranteed to succeed if a big miner cooperates and to fail otherwise. To bribe such a big miner, it is no longer sufficient for the attacker to offer only a slightly higher than the normal block reward; it must also compensate for the individual cost to the big miner should the\n\n[^0]\n[^0]:    ${ }^{76}$ This may pose a limitation on an attacker that attempts to fork a very old transaction, as the fork will invalidate all the new coins given to miners in the forked blocks and all subsequent transactions these funds are exchanged in.\n    ${ }^{77}$ There are many examples of hackers returning illicitly obtained funds; for example: https://www.reuters.com/technology/defi-platform-poly-network-reports-hacking-loses-estimated-600-mill accessed August 2024.\n\nattack succeed (e.g., the loss suffered from currency devaluing). Therefore, although mining power concentration hurts the decentralized nature of the cryptocurrency, it actually helps enhance economic security in this respect.\n\nWe point that while these factors may be effective in practice, they call into question the claims of the system's \"decentralization\". ${ }^{78}$\n\nDiscussion It is commonly believed that higher mining rewards and more mining power increase the economic security of a cryptocurrency. However, our economic analysis reveals interesting subtleties challenging this claim. Both of the economic environments we analyze suggest that higher mining rewards do not actually increase the cost of the attack. Overall, the connection between economic security and mining rewards may be more subtle or dependent on specific circumstances.\n\n[^0]\n[^0]:    ${ }^{78}$ Huberman et al. (2021) find that Bitcoin offers users protection from monopoly's harm even if there are large miners, as long as free entry of miners is possible. It is technically possible for a system to have both large pivotal miners for security and free entry of miners. However, in Nakamoto a sufficiently large miner is able to block free entry of miners.",
      "tables": {},
      "images": {}
    }
  ],
  "id": "2409.08951v2",
  "authors": [
    "Jacob D. Leshno",
    "Elaine Shi",
    "Rafael Pass"
  ],
  "categories": [
    "cs.GT",
    "econ.TH"
  ],
  "abstract": "Bitcoin demonstrated the possibility of a financial ledger that operates\nwithout the need for a trusted central authority. However, concerns persist\nregarding its security and considerable energy consumption. We assess the\nconsensus protocols that underpin Bitcoin's functionality, questioning whether\nthey can ensure economically meaningful security while maintaining a\npermissionless design that allows free entry of operators. We answer this\naffirmatively by constructing a protocol that guarantees economic security and\npreserves Bitcoin's permissionless design. This protocol's security does not\ndepend on monetary payments to miners or immense electricity consumption, which\nour analysis suggests are ineffective. Our framework integrates economic theory\nwith distributed systems theory, and formalizes the role of the protocol's user\ncommunity.",
  "updated": "2025-03-01T03:06:37Z",
  "published": "2024-09-13T16:12:19Z"
}