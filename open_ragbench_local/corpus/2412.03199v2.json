{"title": "A Lower Bound on Unambiguous Context Free Grammars via Communication\n  Complexity", "sections": [{"section_id": 0, "text": "## 1 INTRODUCTION\n\nOver recent years, the succinct representation of query results has become a prominent topic within database theory. This raises a fundamental question: how do different representation formats compare to one another? In this paper, we compare context free grammars (CFG) to their unambiguous variant (uCFG). In a nutshell, we show that enforcing unambiguity-which is useful for applications like counting and enumeration-comes at a heavy price in terms of succinctness.\n\nAt this point some readers may wonder what CFGs have to do with representing query answers. In fact, recent work by Kimelfeld, Martens and Niewerth [20] observed a close connection between CFGs and $d$-representations-a form of factorised representations introduced over a decade ago by Olteanu and Z\u00e1vodn\u00fd in a landmark paper [29]. To be precise, CFGs representing finite languages are isomorphic to d-representations in the unnamed perspective, see [20] for details.\n\nLet us highlight two nice features of d-representations. Firstly, given a query and a database we can often directly compute a d-representation which moreover, may be exponentially smaller than the materialisation of all query answers [29]. And secondly, we can carry out many algorithms directly on d-representations [4]. These representations, and close variants thereof, have been used in various settings e.g. databases under updates [5, 27], representing provenance [28] and machine learning [34]. More broadly, d-representations can be placed within the framework of circuits originating in knowledge compilation, a sub-field of artificial intelligence concerning the efficient representation of various forms of knowledge and data [13, 26]. Techniques from knowledge compilation have been widely deployed in database theory in recent years, see [2] for a survey. Moreover, the circuits corresponding to uCFGs have been used in the context of enumeration [1].\n\nFrom an algorithmic perspective, uCFGs offer several advantages over CFGs. For example, it is well know that while counting is in polynomial time for uCFGs, it is \\#P-complete for CFGs. Similarly, uCFGs allow for more efficient enumeration, e.g. via [1, 24]. Different variants of CFGs have also been used in information extraction [3, 30] and unambiguity is also crucial there. But are there finite languages which are accepted by a small CFG and not by any small uCFG? This is a\n\n[^0]\n[^0]:    Authors' addresses: Stefan Mengel, Univ. Artois, CNRS, Centre de Recherche en Informatique de Lens (CRIL), Lens, France, mengel@cril.fr; Harry Vinall-Smeeth, Technische Universit\u00e4t Ilmenau, Ilmenau, Germany, harry.vinall-smeeth@ tu-ilmenau.de.\n\nquestion left open by Kimelfeld, Martens and Niewerth [20]. They conjecture a double exponential separation for CFGs for a concrete language. However, they say '[t]o the best of our knowledge, the literature does not yet have well-developed methods for proving size lower bounds for uCFGs.' In this paper, we develop such methods and prove the conjecture from [20] via the following theorem.\n\nTheorem 1. For every $n \\in \\mathbb{N}$, there is finite language $L_{n}$ over a binary alphabet in which all words have length $2 n$ such that:\n(1) $L_{n}$ is accepted by a CFG of size $\\Theta(\\log (n))$,\n(2) $L_{n}$ is accepted by a non-deterministic finite automaton of size $\\Theta(n)$ and\n(3) every $u C F G$ accepting $L_{n}$ has size $2^{O(n)}$.\n\nMoreover, we may take $L_{n}$ to be exactly the language from the conjecture of Kimelfeld, Martens and Niewerth [20]. This language is very natural: it consists exactly of those strings of length $2 n$ over the alphabet $\\{a, b\\}$ such that there are two $a$ symbols at distance exactly $n$ from one-another.\n\nConceptually, our techniques not only answer the call for size lower bound methods for uCFGs but contribute more generally to our understanding of the role of unambiguity within computation. This is an area which has received quite some attention within the formal language community. For example, unambiguity within automata theory was the subject of a recent Dagstuhl seminar [12], see [11] for a survey on this topic. It is not only in the context of CFGs that unambiguity has proved difficult to deal with. One reason for this is probably that unambiguity is a semantic property, not a syntactic one, making it hard to 'get your hands on' in a proof.\n\nAs a result, basic questions about unambiguity remain open and others have only recently been resolved. For example, whether unambiguous finite automata admit polynomial time complementation was only relatively recently answered in the negative [16,32]. Similarly, within knowledge compilation, whether d-DNNF circuits admit polynomial time negation has been open for over twenty years and even the special case of structured d-DNNF has only recently been resolved [42].\n\nOn the Naturalness of $L_{n}$. Let us quickly comment on the naturalness of the language $L_{n}$ that we consider. Of course, the lower bound on $L_{n}$ is not directly a result in a practical setting. However, it encapsulates in a prototypical fashion a problem of unambiguous representations: how can one unambiguously deal with unions of highly non-disjoint sets? This is the underlying difficulty for many problems, e.g. the hardness of counting for NFAs and CFGs, and here we show that it is also hard for a type of succinct representation.\n\nAn advantage of studying $L_{n}$ as a very bare-bones version of the problem is that one can hopefully then use it to show hardness of other, more practical problems. This is the reason why different versions of Set Disjointness (essentially a complement of $L_{n}$ ) have been studied extensively in the communication complexity literature and then used in many lower bounds, see e.g. the applications for lower bounds on data structures, streaming algorithms, distributed computing, and the extension complexity of polytopes in [31] and the survey [39].\n\nOne somewhat natural concrete setting for the use of $L_{n}$ in information extraction might be the following: consider data in a CSV file with fixed columns from which we want to extract all pairs of lines that have identical entries in at least one column from a column set $S$. This can easily be modelled with the CFG formalisms proposed for information extraction in [3, 30], but if the algorithm requires unambiguous CFGs (as those in [3,30] do), then an easy reduction from $L_{n}$ shows that any such grammar must be of exponential size in the number of considered columns in $S$. This lower bound remains true if instead of equality we require other natural comparison of the columns, say lexicographic order, similarity measures, and so on.\n\nThus, while $L_{n}$ is not itself natural from a data management perspective, we still feel that it might have practical applications. We will discuss these aspects in future versions of our paper.\n\nProof Outline. As mentioned, we consider the language $L_{n}$ from [20]. There, it was already shown that for some $n$ the language $L_{n}$ admits a CFG of size $\\Theta(\\log (n))$; for completeness we give such a grammar for all $n$ in Appendix A (see also the discussion in Section 2). It was also remarked in [20] that $L_{n}$ admits a nondeterministic finite automaton of size $\\Theta(n)$; the idea is that the automaton first nondeterministically 'guesses' the positions of the matching $a$ symbols and then verifies this guess. Therefore, to prove Theorem 1 it suffices to prove the lower bound (3) for $L_{n}$.\n\nThus far the best tools to analyse unambiguity seem to come from communication complexity, see [31] for an introduction. Our paper is no different. We make a connection to communication complexity, motivated by work in knowledge compilation [6], by relating the size of uCFGs and so-called rectangles (see Section 3). To be precise, we show that if we cannot split up a language $L$ into a small number of disjoint rectangles, then $L$ does not admit a small uCFG. Since rectangles have been studied extensively in communication complexity, one may hope to use results from that area as a 'black box.' Unfortunately, this cannot be done since our setting is more general than the one normally studied in communication complexity. The main technical contribution of this paper is that we overcome this difference in settings.\n\nTo do this we build on an approach from [40], by defining disjoint $A, B \\subset L_{n}$, such that any rectangle contains roughly the same number of words from $A$ and $B$. On the other hand, $L_{n}$ contains many more words from $A$ than $B$, so we need many disjoint rectangles to cover the whole language. This type of argument is known as a discrepancy argument in the communication complexity literature, see e.g. the textbook description [31, Chapter 5].\n\nRelated Work. It has long been known that for infinite languages CFGs are far more succinct than uCFGs. More than 40 years ago, Schmidt and Szymanski [38] showed that in general the size of a uCFG representing a language $L$ cannot be bounded by any computable function in the size of a CFG for the same language $L$. However, this result is not true for finite languages, which are more interesting in the database setting that we consider. There, our doubly exponential separation is optimal, in the sense that every CFG accepting a finite language can be transformed into an equivalent uCFG with at most a double-exponential blow-up [20].\n\nThis is not the first time that different representations of finite languages have been compared qualitatively. In fact, since the influential paper [7], the representation of finite languages has been an active research field, see e.g. [8, 9, 17]. Actually, in [7] uCFGs and CFGs are also compared for succinctness. However, they measure the size of a grammar in terms of the total number of rules whereas we measure the sum of the sizes of all rules. Our size measure corresponds to the size of factorised representations while the measure in [7] is far smaller: a constant number of rules can create languages that need linear size factorised representations. Consequently, our results, are quite different. Perhaps the paper closest in flavour to ours is by Filmus [15], where lower bounds on the sizes of CFGs for various finite languages are shown, with respect to our size model.\n\nAnother influential research strand considering representation by CFGs is that of grammar based compression [18, 19, 43]. There one aims to find a small CFG representing a single word $w$; we may think of this process as compressing a long document. ${ }^{1}$ Algorithms can then be applied directly to the compressed document [21]. This paradigm has become increasingly influential in database theory in recent years, see e.g. [22, 25, 35-37]. Since we are interested in CFGs that represent many strings our results are quite different from this line of work.\n\n[^0]\n[^0]:    ${ }^{1}$ Note, that in this context CFGs are often called straight-line programs.", "tables": {}, "images": {}}, {"section_id": 1, "text": "# 2 PRELIMINARIES \n\nWe write $[n]:=\\{1,2, \\ldots, n\\}$ and for integers $i, j$ with $i \\leq j$, we write $[i, j]:=\\{\\ell \\in \\mathbb{Z} \\mid i \\leq \\ell \\leq j\\}$. For a set $U$ we write $\\mathcal{P}(U)$ to denote its power set, i.e., the set containing every subset of $U$. Moreover, let $U$ and $V$ be sets of sets, such that $A \\cap B=\\varnothing$ for all $A \\in U, B \\in V$. Then we may identify each pair $(A, B)$ with the set $A \\cup B$ and so reflecting this we will write $U \\times V:=\\{A \\cup B \\mid A \\in U, B \\in V\\}$.\n\nWe assume that the reader is familiar with some basics of context free grammars, see e.g. [41]. Let $\\Sigma$ be a set of symbols which we call an alphabet. A word over $\\sigma$ is a finite string of symbols from $\\Sigma$. For a word $w$ we write $|w|$ to denote its length. We write $\\Sigma^{*}$ for the set of all words over $\\Sigma$. Then a language over $\\Sigma$ is defined to be a set $L \\subseteq \\Sigma^{*}$. This paper is only concerned with finite languages which means that $L$ is a finite set.\n\nDefinition 2. A context free grammar $(\\mathrm{CFG})$ is a four-tuple $G=(\\Sigma, N, R, S)$ where\n\n- $\\Sigma$ is a finite set of symbols called the terminals,\n- $N$ is a finite set called the non-terminals,\n- $R$ is a set of rules of the form $A \\rightarrow W$ where $A \\in N$ and $W \\in(\\Sigma \\cup N)^{*}$, and\n- $S \\in N$ is the start symbol.\n\nWhen we have two rules $A \\rightarrow W$ and $A \\rightarrow W^{\\prime}$ with $W \\neq W^{\\prime}$, we sometimes write them more compactly as $A \\rightarrow W \\mid W^{\\prime}$. This notation always has to be interpreted as two rules and not as a single, more complex rule.\n\nCFGs generate a language over the alphabet $\\Sigma$ as follows. Let $A \\rightarrow W$ be a rule in $R$ and let $u, v \\in \\Sigma^{*}$. Then we say that $u A v$ yields $u W v$, in symbols $u A v \\rightarrow u W v$. For $W, W^{\\prime} \\in(\\Sigma \\cup N)^{*}$, we say that $W$ derives $W^{\\prime}$ if there is a finite sequence $\\left(w_{i}\\right)_{i \\in[k]}$ such that $w_{1}=W, w_{k}=W^{\\prime}$ and $w_{i} \\rightarrow w_{i+1}$ for all $i \\in[k-1]$. We write $W \\rightarrow^{*} W^{\\prime}$. Then the language of a grammar $G$ is defined as $L(G):=\\left\\{w \\in \\Sigma^{*} \\mid S \\rightarrow^{*} w\\right\\}$. We also say that the CFG accepts $L(G)$. We define the size of a CFG to be $|G|:=\\sum_{(A \\rightarrow W) \\in R}|W|$. Note that-in contrast to infinite languages-every finite language is accepted by some context free grammar, so the concern of our work is not expressivity of CFGs but succinctness of representation by CFGs.\n\nWe now give an example that we will use for our main result.\nExample 3. Define the language\n\n$$\nL_{n}:=\\left\\{(a+b)^{k} a(a+b)^{n-1} a(a+b)^{n-1-k} \\mid k \\leq n-1\\right\\}\n$$\n\nconsisting of words of length $2 n$ that contain two $a$ symbols with a word of length exactly $n-1$ between them. In [20] the following small CFGs are defined which accept $L_{2^{n}+1}$.\n\nLet $G_{n}$ be the grammar with terminals $\\{a, b\\}$, non-terminals $\\left\\{A_{i}, B_{i}\\right\\}_{0 \\leq i \\leq n}$, start symbol $A_{n}$ and rules,\n\n$$\n\\begin{array}{ll}\nA_{i} \\rightarrow B_{i-1} A_{i-1} \\mid A_{i-1} B_{i-1} & \\text { for } i \\in[n] \\\\\nA_{0} \\rightarrow B_{0} a B_{n} a \\mid a B_{n} a B_{0} & \\\\\nB_{i} \\rightarrow B_{i-1} B_{i-1} & \\text { for } i \\in[n] \\\\\nB_{0} \\rightarrow a \\mid b . &\n\\end{array}\n$$\n\nThen $G_{n}$ has size $\\Theta(n)$ and accepts $L_{2^{n}+1}$ see [20] for details.\nIn fact the above grammar can be adapted to give a $\\Theta(\\log (n))$ sized CFG accepting $L_{n}$ for every $n$. For completeness we give such a grammar in Appendix A.\n\nEach derivation in a context free-grammar may be associated with a tree, called a parse-tree, in the natural way (see Figure 1). We say that a CFG is unambiguous if every $w \\in L(G)$ has a unique\n\n![img-0.jpeg](img-0.jpeg)\n\nFig. 1. Two different parse trees for the word aaaaaa for the grammar of Example 3.\nparse tree; equivalently this means that every word in $L(G)$ has a unique derivation in $G$. We call such a grammar a uCFG.\n\nExample 4. The grammar from Example 3 is not unambiguous; see Figure 1 for two different parse trees of the same word. So let us construct an unambiguous grammar for $L_{n}$.\n\nIn a first step, it will be useful to generate all possible words of a given length $i$. To this end, we introduce non-terminals $C_{1}, \\ldots, C_{n}$ and rules\n\n$$\n\\begin{aligned}\n& C_{i} \\rightarrow a C_{i-1} \\mid b C_{i-1} \\\\\n& C_{1} \\rightarrow a \\mid b .\n\\end{aligned} \\quad \\text { for } i \\in[n], i>1\n$$\n\nClearly, any derivation from any $C_{i}$ is unambiguous. Next, for every word $w \\in \\Sigma^{\\leq n}$, we introduce a non-terminal $A_{w}$ and a rule\n\n$$\nA_{w} \\rightarrow w\n$$\n\nOne way to enforce unambiguity for $L_{n}$ is to ensure that each derivation of a word $w$ in $L_{n}$ determines the first pair of positions containing $a$ at distance $n$ in $w$. To this end, we introduce for every $i \\in[n]$ a way to generate words $u$ such that $i$ is the smallest integer for which the letters at position $i$ and $i+n$ in $u$ are both $a$. For every $i<n$, we thus introduce a non-terminal $A_{i}$ and for every $w \\in \\Sigma^{i-1}$ the rule\n\n$$\nA_{i} \\rightarrow A_{w} a C_{n-i} A_{\\bar{w}} a C_{n-i}\n$$\n\nwhere $\\bar{w}$ is the word we get from $w$ by complementing all its letters, i.e., by flipping all occurrences of $a$ to $b$ and vice-versa. For $i=n$, we introduce $A_{n}$ and the rules\n\n$$\nA_{n} \\rightarrow A_{w} a A_{\\bar{w}} a\n$$\n\nfor all $w \\in \\Sigma^{n-1}$. Clearly, all derivations from any $A_{i}$ are unambiguous. It only remains to add a starting symbol $S$ and the rules\n\n$$\nS \\rightarrow A_{1}|\\ldots| A_{n}\n$$\n\nNote that the grammar we have just constructed accepts $L_{n}$ but it has exponential size in $n$; in particular, there are exponentially many rules in (1). So the unambiguous grammar here is of double exponential size with respect to the ambiguous one from Example 3. Our main result will show that this is unavoidable because every grammar for $L_{n}$ has exponential size in $n$.\n\nWe say that a CFG is in Chomsky normal form if all rules are of the form $A \\rightarrow B C$ or $A \\rightarrow a$ where $A, B, C$ are non-terminals and $a$ is a terminal [10]. It is well-known that any CFG $G$ can be transformed into an equivalent one $G^{\\prime}$ in Chomsky normal form, such that $\\left|G^{\\prime}\\right| \\leq|G|^{2}$. Therefore, from now on we always assume that CFGs are in Chomsky normal form. Moreover, we assume\n\nthat we don't have any redundant non-terminals, i.e. that every non-terminal $A$ appears in at least one parse tree generated by the grammar. If this is not the case, we get a smaller grammar accepting the same language by deleting all rules containing $A$.", "tables": {}, "images": {"img-0.jpeg": "data:image/jpeg;base64,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gAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACkIzS0UAct/wr3w8NTfU1TUUv3Ty2uU1W6DlP7u4SZxwOOlaemeHNJ0e4luLK0xczALLcyyNNM49DI5LEe2cVrUxmAYDIBPA560Aec3PhTVG8O614SjtGNpqOoPNHfK6BIreWQSOCCd28fOoGMH5eRzj0aJVSJEUYVVAH0p2AcE0tABRRRQAVheIfCGjeKoxFrMFxcQjH7lbuaOMkEkEqjgE8nkjP5Vu0UAc8PBOhGWKS4t7m98lg0aX19PcopHQhJHZcj6VBr2mXaeKdG8QWVubr7HHNb3ECFQ5jkAIZdxAyrIOMjIJxnoemYkZx6UDDqCDkHkEGgDnPCOiz6XDql3eJ5d1ql/LeSRbg3lK2FRCRwSFUZwSMk8nrXS0YzRQAUUUUAFFFFABRRRQAVn6joek6w8D6nplneNA26I3EKyFD6jI4rQooAox6NpcWqy6pHp1qmoSqEkuliUSMoAABbGSOB+Q9KvdBRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAHN6D/AMjX4s/6+4P/AEmirpBXN6D/AMjV4s/6+4P/AEmirpKACiiigAooooAK5rxYP9M8N++rxg/9+pa6Wub8Wf8AH54a/wCwxH/6KloA6SiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArm9d/5G/wt/12uP8A0Q1dJXN67/yN/hb/AK7XP/ohqAOkooooAKKKKACiiigCnq3/ACCLz/rg5/8AHTVLwj/yJmh/9g+D/wBFrV3Vv+QRe/8AXvJ/6Cap+Ev+RM0L/sH2/wD6LWgDYooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKQnHegDE0iwurXxD4huZotsN3cwvA24HeqwIh4ByPmUjnFbY6U0t823Iz6U5eVFAC0UUUAFFFFABWF4isbq9udEe3i3rbaik8vzAbUEcik8nnlh+dbtRuwQ7icL3PagB46UtMyT0xg96cORQAtFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFYWrWN1c+JNBuoYt0FpLM0zbgNoaIqOCcnkjpmt2mO2zJPAHUmgB4opgYnODmnigAooooAKKKKAKuoRvNp91FGu53iZVGcZJBHeq3hu1nsfC+k2lymy4gs4opUyDtZUAIyODyK0T1PT86RXBGAQccHHagB9FAooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK5jx74mbwp4WuL6CMSXsjLb2kZ6NM5wufYcn8DXT1zPjjwp/wAJhoa2CXjWdxDcR3NvOE3hJEPBK5GRgkde+e1AHA+PvDOl2vh/RNAuFgvfEOs6jBDLfzoGuH+YGSQNjcFHTAwAGwPSvY1ACAAYHpXnOp/DfUNU1jStYl8SuNUtWkaadbRSGBXaqxKWxHsyxGd3zMWPSvRY12RqmSdoxljkn8TQA6iiigAooooAQnFeb6Ld2fjKfWvEuuFJNC0+aSCxtrgAwqkY+e4dTwzE5wf4QDjHNejscZx/OvNbT4WXFroepaCfEDto8zzS2tstttMUrj5S7bsuqHDBeMkAnNAFj4N2cUXgd9QjgSBNUvri9WJAFCIXKqoA6DCjAr0QVzng3w5ceF/D0GmXGpNftCixq3liNEVQFCqoJ9Mkkkkkn2HRigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigBruEVmZgABkk9BXmOi3un+J9D1Px54lSKfSlMv9n210oaK3t4ztL7Tx5jspyevQDFelzos0TxONyOpVhnGQR0rzO3+FF2ng+fwxceI3m0+NZRYx/Zgnls7E7pPmO8gk46AZzgkKQAavwi07+z/AIbaWWRY5bwPdsqjAAkYlcD0Cla7wVieGNFm0DQoLC4v3vXjVU8wx+WoVVCqqoCdoAA7+pPWtodKAFooooAKKKKAOF8TX8+teONO8GW00sNu1s1/qckTFWaANtWIEcjc33sYOKx9F03SJfjfeHSLKzt7fRtKWCYWsSovnu+Ru2jBIQEex+lb2teC7278ap4k0rXG02d7P7Dcr9mEpeLdu3IScKw45IYcDjqDD4Z+H7+GPE+o6nb6rI1ndyJILTywDuCFQZJCSXxuY9sk5OaAO6HSikHSloAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKQgGlooAMUYwMCiigAooooAKKKKAEwKAoHQY+lLRQAmBx7e9LRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAmKNo9BS0UAGKKKKACiiigAooooAQgHrS0UUAHSiiigAooooAKKKKACiiigAooooAKKKKACiiigD/2Q=="}}, {"section_id": 2, "text": "# 3 FROM UNAMBIGUOUS CFGS TO RECTANGLE COVERS \n\nIn this section, we show how one can prove lower bounds for unambiguous CFGs by means of communication complexity. In fact, we focus on CFGs whose languages are finite and, in particular, whose words are all of the same length. The following definition is crucial.\nDefinition 5 (Rectangle). We say that a language $L$ with words of length $n$ is a rectangle if there are numbers $n_{1}, n_{2}, n_{3}$ such that:\n\n$$\nL=\\bigcup_{\\substack{w_{1} w_{2} \\in L_{1} \\\\\\left|w_{1}\\right|=n_{1},\\left|w_{3}\\right|=n_{3}}}\\left\\{w_{1}\\right\\} \\times L_{2} \\times\\left\\{w_{3}\\right\\} \\text { where } L_{1} \\subseteq \\Sigma^{n_{1}+n_{3}}, L_{2} \\subseteq \\Sigma^{n_{2}}\n$$\n\nWe also say that $L$ is a rectangle with parameters $\\left(L_{1}, L_{2}, n_{1}, n_{2}, n_{3}\\right)$. We say that a rectangle is balanced if and only if $\\frac{n}{3} \\leq n_{2} \\leq \\frac{2 n}{3}$.\nExample 6. Consider the language\n\n$$\nL_{n}^{*}:=a^{n / 2}(a+b)^{n} a^{n / 2}\n$$\n\nof all words of length exactly $2 n$ which begin and end with $n / 2$ consecutive $a$ symbols. Then $L_{n}^{*}$ is a balanced rectangle. This follows by setting $n_{1}=n_{3}=n / 2, n_{2}=n, L_{1}=\\left\\{a^{n}\\right\\}$ and $L_{2}=(a+b)^{n}$.\nIt is easy to see that every language can be written as a union of balanced rectangles since any language containing a single word is a balanced rectangle. The aim of this section is to show that the number of rectangles needed to cover a language is closely related to the size of CFGs accepting the language. This is formalised by the following proposition.\n\nProposition 7. Let $L$ be a language in which all words have length $n$ and which is accepted by a CFG G. Then L can be written as\n\n$$\nL:=\\bigcup_{i \\in[\\ell]} L_{i}\n$$\n\nwhere every $L_{i}$ is a balanced rectangle and $\\ell \\leq n|G|$. Moreover, if $G$ is unambiguous, then the union in (2) is disjoint.\n\nWith Proposition 7 in hand, to prove that a language does not admit a small uCFG it suffices to show that whenever $L$ is equal to a disjoint union of rectangles, the number of rectangles in the union must be big. This gives a lower bound technique analogous to those which have been successfully deployed in knowledge compilation, see for example [6].\nExample 8. $L_{n}$ can be written as a union of $n$ balanced rectangles. To see this observe that for all fixed $0 \\leq k \\leq n-1$ the language\n\n$$\nL_{n}^{k}:=(a+b)^{k} a(a+b)^{n-1} a(a+b)^{n-1-k}\n$$\n\nis a balanced rectangle, setting $n_{1}=k, n_{2}=n+1, n_{3}=n-1-k, L_{1}=(a+b)^{n-1}$ and $L_{2}=a(a+b)^{n-1} a$. Moreover $L_{n}$ is by definition the union of all these languages. However, note that the $L_{n}^{k}$ languages are not disjoint. In fact, in Section 4 we will see that any union of balanced rectangles which equals $L$ must have size $2^{G(n)}$, which by Proposition 7 proves our main lower bound.\n\nIn the remainder of this section, we will prove Proposition 7. So fix a language $L$ in which all words have the same length $n$ and a context free grammar $G$ accepting $L$. We start with the following simple observation.\n\nObservation 9. For every non-terminal $A$ of $G$, the words that can be generated by a derivation in $G$ starting from $A$ all have the same length.\n\nProof. By way of contradiction, assume that this were not the case, so there is some $A$ from which we can generate words of different lengths. Then, by assumption, we know that $A$ appears in a parse tree of $G$. But in that parse tree we can substitute the derivation below $A$ by derivations for words of different lengths, and we get that $L$ contains words of different lengths, which contradicts the assumption on $L$.\n\nWith the help of Observation 9, we can rewrite $G$ into an equivalent grammar in the following way: for every non-terminal $A$ of $G$ introduce new non-terminals $A_{1}, \\ldots A_{n}$. For every rule $A \\rightarrow B C$ let $\\ell$ be the length of the words generated by $B$ and $i \\in[n]$. Then if $i+\\ell \\leq n$ the grammar $G^{\\prime}$ has rules $A_{i} \\rightarrow B_{i} C_{i+\\ell}$. Moreover, for every rule $A \\rightarrow a$, the grammar $G^{\\prime}$ has the rules $A_{i} \\rightarrow a$ for $i \\in[n]$. Finally, the start symbol of $G^{\\prime}$ is $S_{1}$.\n\nLemma 10. The grammars $G$ and $G^{\\prime}$ generate the same language and $\\left|G^{\\prime}\\right| \\leq n|G|$. Moreover, if $G$ is unambiguous then so is $G^{\\prime}$.\n\nProof. We build on the observation that in $G^{\\prime}$ the index $i$ of the non-terminals $A_{i}$ determines the position of the first letter of the word generated from $A_{i}$ in every word generated by $G$. We use this to show that there is a bijection between the parse trees for the grammar $G$ and $G^{\\prime}$. So fix a parse tree for a word $w$ in $G$. Let $A$ be a non-terminal symbol in this parse tree and say that $A$ generates the word $w^{\\prime}$. Let $i$ be the position of the first letter of $w^{\\prime}$ in $w$. Then we substitute $A$ by $A_{i}$ in the parse tree. Doing this for every non-terminal yields a new tree which is easily seen to be a parse tree of $G^{\\prime}$ for $w$. The inverse construction is simply deleting the indices that we introduced in the construction of $G^{\\prime}$. Overall, this shows that $G$ and $G^{\\prime}$ generate the same languages. Moreover, since we have a bijection of parse trees, if $G$ is unambiguous then so is $G^{\\prime}$.\n\nFor the size bound, observe that for every $i \\in[n]$ and every rule of $G$, we introduced a new rule of the same size. Thus, the size grows by a factor of $n$.\n\nWe now make a connection between non-terminals of $G^{\\prime}$ and rectangles.\nObservation 11. Let $A_{i}$ be a non-terminal of $G^{\\prime}$. Let $L^{\\prime}$ consist of all the words in the language of $G^{\\prime}$ with a parse tree containing $A_{i}$. Then $L^{\\prime}$ is a rectangle for some parameters $\\left(L_{1}, L_{2}, n_{1}, n_{2}, n_{3}\\right)$ where the words in $L_{2}$ are exactly those generated by $A_{i}$.\n\nProof. Consider any word $w$ in $L^{\\prime}$. Then $w=w_{1} w_{2} w_{3}$, where $w_{2}$ is generated from $A_{i}$. Then we can exchange $w_{2}$ by any other word $\\bar{w}_{2}$ generated from $A_{i}$ to get $\\bar{w}=w_{1} \\bar{w}_{2} w_{3}$ which is also in $L^{\\prime}$, so $\\left\\{w_{1}\\right\\} \\times L\\left(A_{i}\\right) \\times\\left\\{w_{3}\\right\\} \\subseteq L^{\\prime}$ where $L\\left(A_{i}\\right)$ consists of all words generated from $A_{i}$.\n\nBy Observation 9, we know that all words in $L\\left(A_{i}\\right)$ have the same length, that $\\left|w_{1}\\right|=i-1$ and $\\left|w_{3}\\right|=n-(i-1)-\\left|w_{2}\\right|$. Therefore, for all $w^{\\prime}=w_{1}^{\\prime} w_{2}^{\\prime} w_{3}^{\\prime} \\in L^{\\prime}$ with $w_{2}^{\\prime} \\in L\\left(A_{i}\\right)$ we have $\\left|w_{1}\\right|=\\left|w_{1}^{\\prime}\\right|$. $\\left|w_{2}\\right|=\\left|w_{2}^{\\prime}\\right|$ and $\\left|w_{3}\\right|=\\left|w_{3}^{\\prime}\\right|$. So we can write\n\n$$\nL^{\\prime}=\\bigcup_{\\substack{w_{1} w_{2} w_{3} \\in L^{\\prime} \\\\ w_{2} \\in L\\left(A_{i}\\right)}}\\left\\{w_{1}\\right\\} \\times L\\left(A_{i}\\right) \\times\\left\\{w_{3}\\right\\}\n$$\n\nwhich proves the observation.\nWe can now construct the set of rectangles in Proposition 7 iteratively via the following process. While the language of $G^{\\prime}$ is not empty, choose a word $w$ in it and a parse tree for $w$. We claim that this parse tree must contain a non-terminal $A_{i}$ that generates words of length between $\\frac{n}{3}$ and $\\frac{2 n}{3}$. To find this non-terminal, we use the following standard procedure: we descend in the parse tree from the root, iteratively always following the edge to the child whose subtree contains more\n\nleaves. We stop when the current node $v$ has less than $\\frac{2 n}{3}$ leaves in its subtree and claim that we have found the desired non-terminal which is the label of $v$. To see this, note that, since we have not stopped before, the subtree of the parent of $v$ contains more than $\\frac{2 n}{3}$ leaves, and since we go to the child with more children, $v$ must have at least $\\frac{n}{3}$ leaves in its subtree. Observing that the number of leaves below $v$ is the same as the length of the generated word proves the claim.\n\nWe put $L^{\\prime}$, defined as in Observation 11, into the set of rectangles we are constructing. Then we delete $A_{i}$ from $G^{\\prime}$ as well as all other non-terminals that no longer appear in any parse tree and continue the iteration with the resulting language.\n\nThis process terminates after at most $\\left|G^{\\prime}\\right| \\leq n|G|$ iterations and so produces some set of rectangles $\\left\\{R_{i}\\right\\}_{i \\in[\\ell]}$ with $\\ell \\leq n|G|$. Observe that, by construction, $\\bigcup_{i \\in[\\ell]} R_{i}=L$. Moreover, if $G$ is unambiguous then, by Lemma $10, G^{\\prime}$ is also unambiguous. This means that every word in $L$ appears in a unique parse tree in $G^{\\prime}$ and so the union $\\bigcup_{i \\in[\\ell]} R_{i}$ is disjoint. Therefore, this process really does produce a set of rectangles witnessing Proposition 7.", "tables": {}, "images": {}}, {"section_id": 3, "text": "# 4 A LOWER BOUND FOR DISJOINT RECTANGLE COVERS \n\nIn this section, we show our lower bound for representations by uCFGs via an exponential lower bound for the language $L_{n}$ from Example 3. This will provide the missing lower bound of Theorem 1 and thus prove our main result. Recall, that $L_{n}$ is defined as follows:\n\n$$\nL_{n}:=\\left\\{(a+b)^{k} a(a+b)^{n-1} a(a+b)^{n-k-1} \\mid k \\leq n-1\\right\\}\n$$\n\nWe will prove the following, confirming a conjecture from [20].\nTheorem 12. For every $n \\in \\mathbb{N}$, every $u C F G$ accepting $L$ has size $2^{\\Omega(n)}$.\nIn the rest of this section, we prove Theorem 12. Observe that every word in $L_{n}$ has length $2 n$ and that $L_{n}$ consists of all those words such that there are two $a$ symbols with distance exactly $n$ between them. To prove Theorem 12, we will use the rectangle based method presented in Section 3.\n\nNote that we may assume that $n$ is sufficiently big by choosing the constant hidden in the $\\Omega$ notation to be sufficiently small. To simplify some of our arguments, for now we only consider $L_{n}$ for values of $n$ which are divisible by 4 ; it will be easy to remove this condition at the end of this section.", "tables": {}, "images": {}}, {"section_id": 4, "text": "### 4.1 A Set Perspective\n\nBefore diving into our proof we first introduce a change of perspective. It will be helpful to think of each word over $\\{a, b\\}$ of length $2 n$ as defining a pair of subsets of $[n]$. Formally, we define a bijection which maps each $w=w_{1} \\ldots w_{2 n}$, where $w_{i} \\in\\{a, b\\}$ for each $i$ to a pair $\\left(X_{w}, Y_{w}\\right) \\subseteq\\left\\{x_{1}, \\ldots, x_{n}\\right\\} \\times$ $\\left\\{y_{1}, \\ldots, y_{n}\\right\\}$ where $\\left\\{x_{1}, \\ldots, x_{n}\\right\\}$ and $\\left\\{y_{1}, \\ldots, y_{n}\\right\\}$ are both sets of elements and $X_{w}$ contains every $x_{i}$ such that $w_{i}=a$ and $Y_{w}$ contains every $y_{i}$ such that $w_{i+n}=a$. We write $X:=\\left\\{x_{1}, \\ldots, x_{n}\\right\\}$ and $Y:=\\left\\{y_{1}, \\ldots, y_{n}\\right\\}$. Sometimes it will be useful to refer to the elements of $X \\cup Y$ in a unified way, hence we define\n\n$$\nz_{i}:= \\begin{cases}x_{i} & i \\in[n] \\\\ y_{i-n} & i \\in[n+1,2 n]\\end{cases}\n$$\n\nWe write $Z[i, j]:=\\left\\{z_{\\ell} \\mid i \\leq \\ell \\leq j\\right\\}$ and $Z:=Z[1,2 n]$. We similarly define $X[i, j]$ and $Y[i, j]$. Observe that each interval also induces a partition of $Z$ as follows.\n\nDefinition 13 (Ordered Partition). We say that a partition $\\left\\{\\Pi_{0}, \\Pi_{1}\\right\\}$ of $Z$ is induced by the interval $[i, j]$ if for some $\\ell \\in\\{0,1\\}$, we have $\\Pi_{\\ell}=Z[i, j]$. We call a partition which is induced by some\n\ninterval an ordered partition. Moreover, we call an ordered partition $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ balanced if\n\n$$\n\\frac{2 n}{3} \\leq\\left|\\Pi_{0}\\right|,\\left|\\Pi_{1}\\right| \\leq \\frac{4 n}{3}\n$$\n\nHaving these dual notions of intervals and the partitions they induce on $Z$ will be useful in our proofs. We next translate Definition 5 to fit the set perspective.\nDefinition 14 (Set Rectangle). Let $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ be an ordered partition of $Z$. We say that $R \\subseteq \\mathcal{P}(Z)$ is an ordered $\\left(\\Pi_{0}, \\Pi_{1}\\right)$-set rectangle if there are sets $S \\subseteq \\mathcal{P}\\left(\\Pi_{0}\\right)$ and $T \\subseteq \\mathcal{P}\\left(\\Pi_{1}\\right)$ such that $R=S \\times T .{ }^{2}$ We say that $R$ is a balanced set-rectangle if $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ is balanced. Moreover, if $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ is induced by $[i, j]$ we also call $R$ an $[i, j]$-set rectangle.\n\nThe following lemma justifies Definition 14 and therefore our use of the set perspective in the rest of the proof.\n\nLemma 15. Let $L$ be a language over the alphabet $\\{a, b\\}$ with words of length $2 n$, such that $L$ is a rectangle in the sense of Definition 5 with parameters $\\left(L_{1}, L_{2}, n_{1}, n_{2}, n_{3}\\right)$. Then $\\left\\{\\left(X_{w}, Y_{w}\\right) \\mid w \\in L\\right\\}$ is $a\\left[n_{1}+1, n_{1}+n_{2}\\right]$-set rectangle.\n\nConversely, for any language $L$ over the alphabet $\\{a, b\\}$ with words of length $2 n$ such that $\\left\\{\\left(X_{w}, Y_{w}\\right) \\mid\\right.$ $w \\in L\\}$ is an $[i, j]$-set rectangle, $L$ is a rectangle with $n_{1}=i-1, n_{2}=j-i+1$ and $n_{3}=2 n-j$.\n\nProof. Let\n\n$$\nL=\\bigcup_{\\substack{w_{1} w_{2} \\in L_{1} \\\\\\left|w_{1}\\right|=n_{1},\\left|w_{3}\\right|=n_{3}}}\\left\\{w_{1}\\right\\} \\times L_{2} \\times\\left\\{w_{3}\\right\\} \\text { where } L_{1} \\subseteq \\Sigma^{n_{1}+n_{3}}, L_{2} \\subseteq \\Sigma^{n_{2}}\n$$\n\nbe a rectangle with parameters $\\left(L_{1}, L_{2}, n_{1}, n_{2}, n_{3}\\right)$. Define\n\n$$\n\\begin{aligned}\n& S:=\\left\\{\\left(X_{w}, Y_{w}\\right) \\mid w=w_{1} b^{n_{2}} w_{3} \\text { for some } w_{1} w_{3} \\in L_{1}\\right\\} \\subseteq Z\\left[1, n_{1}\\right] \\cup Z\\left[n_{1}+n_{2}+1,2 n\\right] \\text { and } \\\\\n& T:=\\left\\{\\left(X_{w}, Y_{w}\\right) \\mid w=b^{n_{1}} w_{2} b^{n_{3}} \\text { for some } w_{2} \\in L_{2}\\right\\} \\subseteq Z\\left[n_{1}+1, n_{1}+n_{2}\\right]\n\\end{aligned}\n$$\n\nBy construction $U \\cap V=\\varnothing$ for all $U \\in S, V \\in T$, so it is easy to verify that $S \\times T=\\{U \\cup V \\mid U \\in$ $S, V \\in T\\}=\\left\\{\\left(X_{w}, Y_{w}\\right) \\mid w \\in L\\right\\}$ and that this is a $\\left[n_{1}+1, n_{1}+n_{2}\\right]$ rectangle. The converse direction is similar.\n\nSlightly abusing notation, we will from now on write $L_{n}$ to mean $\\left\\{\\left(X_{w}, Y_{w}\\right) \\mid w \\in L_{n}\\right\\}$. Also from now on we refer to ordered set-rectangles simply as ordered rectangles; that is, we will now completely switch to the set perspective. Seen this way, the language $L_{n}$ consists exactly of those pairs $\\left(X_{w}, Y_{w}\\right)$ of sets for which there is an $i$ such that $x_{i} \\in X_{w}$ and $y_{i} \\in Y_{w}$ are in the respective sets. Going one step further, if we identify the sets $X_{w}, Y_{w}$ with the corresponding index sets, $L_{n}$ consists of intersecting pairs of sets, so $L_{n}$ is essentially the complement of the famous set disjointness problem, which is widely regarded as the flagship problem of communication complexity, see e.g. the survey [39].\n\nFrom the above discussion along with Proposition 7, it follows that to prove Theorem 12 it suffices to prove the following proposition.\n\nProposition 16. If $R_{1}, \\ldots, R_{\\ell}$ is a set of ordered balanced rectangles such that $R_{i}$ and $R_{j}$ are disjoint for every $i \\neq j$ and such that\n\n$$\n\\bigcup_{t \\in[\\ell]} R_{i}=L_{n}\n$$\n\nthen $\\ell=2^{\\Omega(n)}$.\n${ }^{2}$ Remember that to simplify notation we read $S \\times T$ as $\\{U \\cup V \\mid U \\in S, V \\in T\\}$.\n\nWe call a set of rectangles as in Proposition 16 a disjoint rectangle cover for $L_{n}$. We will prove Proposition 16 in the next two subsections.", "tables": {}, "images": {}}, {"section_id": 5, "text": "# 4.2 A Lower Bound for Restricted Rectangles \n\nBefore showing Proposition 16 in full generality, it will be useful to first consider a special case in which all rectangles share a particular partition.\n\nTheorem 17. Any disjoint rectangle cover of $L_{n}$ by $[1, n]$-rectangles has size $2^{\\Omega(n)}$.\nTheorem 17 is an immediate consequence of the so-called rank bound from communication complexity pioneered in [23], see e.g. [31, Chapter 2] for a textbook introduction. However, to prove Proposition 16 we need to generalise Theorem 17, which unfortunately cannot directly be done using known results from communication complexity: in contrast to most of the literature, Proposition 16 is not in the standard setting in which the partitions for all rectangles are fixed. Rather, different rectangles may use different partitions. This setting is called multi-partition communication complexity [14] and is far less studied. In particular, there is only one known lower bound that explicitly works for disjoint rectangle covers [33], which we cannot directly apply here.\n\nAs a first step to proving Proposition 16 we thus give a new proof of Theorem 17. This proof will be more involved then the usual approach, but it has the advantage that we can later generalise it to Proposition 16. We use a discrepancy argument in the spirit of that given by Sherstov in the context of multiparty communication complexity ${ }^{3}$ [40]. The idea is to define disjoint $A, B \\subset L_{n}$, such that (1) any $[1, n]$-rectangle contains roughly the same number of sets from $A$ as from $B$ and (2) $L_{n}$ contains many more words from $A$ than $B$. Therefore, the size of any disjoint cover for $L_{n}$ by $[1, n]$-rectangles must be large.\n\nInformally, we split $X \\cup Y$ into intervals of size four and then define $\\mathcal{L}$ to be those sets $(U, V)$ containing exactly one element from each interval. Then $A$ is defined to be the set of $(U, V) \\in \\mathcal{L}$ such that the number of $i$ with $x_{i} \\in U$ and $y_{i} \\in V$ is odd and $B:=\\mathcal{L} \\backslash A$. We next give the formal definition.\n\nSo set $m:=n / 4$; note that $m$ is an integer since by assumption $n$ is divisible by four. Then for $i \\in[m]$ we define:\n\n$$\n\\begin{aligned}\nI_{i}^{X} & :=X[4(i-1)+1,4 i] \\\\\n\\mathcal{L}_{i}^{X} & :=\\left\\{U \\subset I_{i}^{X} \\mid|U|=1\\right\\} \\\\\n\\mathcal{L}^{X} & :=\\left\\{U \\subset X \\mid\\left|U \\cap I_{i}\\right|=1 \\text { for every } i \\in[m]\\right\\}\n\\end{aligned}\n$$\n\nWe analogously define $I_{i}^{Y}, \\mathcal{L}_{i}^{Y}$ and $\\mathcal{L}^{Y}$ exactly as above but with $Y$ playing the role of $X$. Then we set $\\mathcal{L}:=\\mathcal{L}^{X} \\times \\mathcal{L}^{Y}$ and $\\mathcal{L}_{i}=\\mathcal{L}_{i}^{X} \\times \\mathcal{L}_{i}^{Y}$. Since we often want to take a unified perspective we define for $i \\in[m], I_{i}:=I_{i}^{X}$ and $I_{i+m}=I_{i}^{Y}$. We call every $I_{j}$ an interval.\n\nWe next show that $\\mathcal{L}$ is big and that $L_{n}$ contains many more words from $A$ than from $B$. Recall, that $A \\subset \\mathcal{L}$ contains those $(U, V) \\in \\mathcal{L}$ such that the number of $i$ with $x_{i} \\in U$ and $y_{i} \\in V$ is odd and $B:=\\mathcal{L} \\backslash A$.\n\nLemma 18. The following holds:\n(1) $|\\mathcal{L}|=2^{4 m}$.\n(2) $\\left|A \\cap L_{n}\\right|-\\left|B \\cap L_{n}\\right|=|A|-\\left|B \\cap L_{n}\\right|>2^{\\frac{2 m}{2}}$.\n\n[^0]\n[^0]:    ${ }^{3}$ We warn the reader that despite superficially similar names multiparty and multipartition communication complexity are very different concepts!\n\nProof. For (1) observe that in total there are $2 m$ intervals each of length four and that for every such interval exactly one element is chosen for every $(U, V) \\in \\mathcal{L}$, so $|\\mathcal{L}|=4^{2 m}=2^{4 m}$.\n\nThe equality in (2) is trivial since $A \\subset L_{n}$. To prove the inequality it suffices to show that $\\left|B \\backslash L_{n}\\right|=$ $12^{m}$ and that $|B|-|A|=2^{3 m}$. To see this assume the aforementioned equalities, then\n\n$$\n\\begin{aligned}\n|A|-\\left|B \\cap L_{n}\\right| & =|A|-\\left(|B|-\\left|B \\backslash L_{n}\\right|\\right) \\\\\n& =\\left|B \\backslash L_{n}\\right|-(|B|-|A|) \\\\\n& =12^{m}-2^{3 m}>2^{\\frac{2 m}{2}}\n\\end{aligned}\n$$\n\nwhere in the last step we use that $n$ (and thus $m$ ) is sufficiently big.\nTo show that $\\left|B \\backslash L_{n}\\right|=12^{m}$, consider for each $i \\in[m]$ the 16 sets $\\left(U_{i}, V_{i}\\right) \\in \\mathcal{L}_{i}$. By the definition of $\\mathcal{L}_{i}$, the sets $U_{i}$ and $V_{i}$ contain a single element, respectively, so $U_{i}=\\left\\{x_{j}\\right\\}, V_{i}=\\left\\{y_{k}\\right\\}$, for some appropriate $j, k$. There are exactly four combinations such that $j=k$ and 12 with $j \\neq k$. Combining the latter for all $i \\in[m]$ gives exactly $B \\backslash L_{n}$, so $\\left|B \\backslash L_{n}\\right|=12^{m}$.\n\nFinally, $|B|-|A|=2^{3 m}$ is true since\n\n$$\n\\begin{aligned}\n2^{3 m} & =(12-4)^{m}=\\sum_{i=0}^{m}\\binom{m}{i} 12^{m-i}(-4)^{i} \\\\\n& =\\sum_{i=0}^{\\lfloor m / 2\\rfloor}\\left(\\binom{m}{2 i} 12^{m-2 i} 4^{2 i}\\right)-\\sum_{i=1}^{\\lfloor m / 2\\rfloor}\\left(\\binom{m}{2 i-1} 12^{m-(2 i-1)} 4^{2 i-1}\\right) \\\\\n& =|B|-|A|\n\\end{aligned}\n$$\n\nThe key to proving Theorem 17 is the following: in Lemma 18, we have seen that there are many more sets in $A \\cap L_{n}$ than in $B \\cap L_{n}$. However, we will next show that each $[1, n]$-rectangle cannot contain many more sets of $A$ than $B$. Therefore, any disjoint cover of $L_{n}$ by $[1, n]$-rectangles must by big.\n\nLemma 19. Let $R=S \\times T$ be a $[1, n]$-rectangle. Then\n\n$$\n||R \\cap A|-|R \\cap B|| \\leq 2^{3 m}\n$$\n\nProof. The key idea is to express $||R \\cap A|-|R \\cap B||$ in terms of an appropriate expectation calculation. To set this up we need some definitions.\n\nDefine for each $i \\in[m]$ random variables $X_{i}, Y_{i}$ that take a value uniformly at random from $\\mathcal{L}_{i}^{X}$ and $\\mathcal{L}_{i}^{Y}$ respectively. We let all these random variables be independent and define new random variables $X:=\\bigcup_{i=1}^{m} X_{i}, Y=\\bigcup_{i=1}^{m} Y_{i}$. Note that $X$ has the uniform distribution over $\\mathcal{L}^{X}$ and $Y$ the uniform distribution on $\\mathcal{L}^{Y}$. Moreover, $X$ and $Y$ are independent. Let $Y^{\\prime}$ be an independent copy of $Y$.\n\nFor $L \\subseteq \\mathcal{P}(Z)$ we write $\\chi_{L}$ for the indicator function of $L$, i.e. the function $\\chi_{L}: \\mathcal{P}(Z) \\rightarrow\\{0,1\\}$ that evaluates to one exactly on inputs contained in $L$. For $U \\in \\mathcal{L}^{X}$ and $V \\in \\mathcal{L}^{Y}$ let $\\operatorname{Int}(U, V):=1$ if there is some $i$ such that $x_{i} \\in U$ and $y_{i} \\in V$, otherwise $\\operatorname{Int}(U, V):=0$. Note that if $U \\in \\mathcal{L}^{X}$ and $V \\in \\mathcal{L}^{Y}$ then $(-1)^{\\chi_{A}(U, V)}=(-1)^{\\sum_{i=1}^{m} \\operatorname{Int}\\left(U_{i}, V_{i}\\right)}$, where $U_{i}:=U \\cap I_{i}^{X}$ and $V_{i}:=V \\cap I_{i}^{Y}$ for $i \\in[m]$. The following calculation borrows heavily from [31, Lemma 5.9] which in turn is inspired by an\n\napproach pioneered in [40].\n\n$$\n\\begin{aligned}\n\\left(\\frac{|R \\cap A|-|R \\cap B|}{2^{4 m}}\\right)^{2} & =\\left(\\mathbb{E}_{X, Y}\\left[\\chi_{R}(X, Y) \\cdot(-1)^{\\chi_{A}(X, Y)}\\right]\\right)^{2} \\\\\n& =\\left(\\mathbb{E}_{X, Y}\\left[\\chi_{S}(X) \\cdot \\chi_{T}(Y) \\cdot(-1)^{\\chi_{A}(X, Y)}\\right]\\right)^{2} \\\\\n& \\leq \\mathbb{E}_{X}\\left[\\chi_{S}(X)^{2}\\left(\\mathbb{E}_{Y}\\left[\\chi_{T}(Y) \\cdot(-1)^{\\chi_{A}(X, Y)}\\right]\\right)^{2}\\right] \\\\\n& \\leq \\mathbb{E}_{X, Y, Y^{\\prime}}\\left[\\chi_{T}(Y) \\cdot \\chi_{T}\\left(Y^{\\prime}\\right) \\cdot(-1)^{\\chi_{A}(X, Y)+\\chi_{A}\\left(X, Y^{\\prime}\\right)}\\right] \\\\\n& \\leq \\mathbb{E}_{Y, Y^{\\prime}}\\left[\\left|\\mathbb{E}_{X}\\left[(-1)^{\\chi_{A}(X, Y)+\\chi_{A}\\left(X, Y^{\\prime}\\right)}\\right]\\right|\\right] \\\\\n& =\\mathbb{E}_{Y, Y^{\\prime}}\\left[\\left|\\mathbb{E}_{X}\\left[(-1)^{\\sum_{i=1}^{m} \\operatorname{Int}\\left(X_{i}, Y_{i}\\right)+\\operatorname{Int}\\left(X_{i}, Y_{i}^{\\prime}\\right)}\\right]\\right|\\right]\n\\end{aligned}\n$$\n\nNow fix $Y, Y^{\\prime}$. We claim that if $Y \\neq Y^{\\prime}$ the inner expectation must evaluate to zero. First note that the probability that $Y=Y^{\\prime}$ is $1 /\\left|\\mathcal{L}^{Y}\\right|=2^{-2 m}$. Therefore, the claim implies the result via a simple calculation. We now prove the claim.\n\nSo fix $Y \\neq Y^{\\prime}$ while $X$ remains random as before. Let $C$ be the event that $\\sum_{i=1}^{m} \\operatorname{Int}\\left(X_{i}, Y_{i}\\right)+$ $\\operatorname{Int}\\left(X_{i}, Y_{i}^{\\prime}\\right)$ is even and $C_{i}$ be the event that $\\operatorname{Int}\\left(X_{i}, Y_{i}\\right)+\\operatorname{Int}\\left(X_{i}, Y_{i}^{\\prime}\\right)=1$. Then $C$ is true if and only if the number of $i \\in[m]$ such that $C_{i}$ is true is even. Note that if $Y_{i}=Y_{i}^{\\prime}$ then $C_{i}$ is false. So suppose $Y_{i} \\neq Y_{i}^{\\prime}$. Since all intervals are of size four and $\\left|X_{i}\\right|=\\left|Y_{i}\\right|=\\left|Y_{i}^{\\prime}\\right|=1$, we have $\\mathbb{P}\\left(C_{i}\\right)=\\frac{1}{2}$. Let $\\mathcal{I}:=\\left\\{i \\in[m] \\mid Y_{i} \\neq Y_{i}^{\\prime}\\right\\}$ and $\\alpha:=|\\mathcal{I}|$. Then\n\n$$\n\\mathbb{P}(C)=\\sum_{i=0}^{\\left\\lfloor\\frac{\\alpha}{2}\\right\\rfloor}\\binom{\\alpha}{2 i} 2^{-2 i} 2^{-(\\alpha-2 i)}=2^{-\\alpha} \\sum_{i=0}^{\\left\\lfloor\\frac{\\alpha}{2}\\right\\rfloor}\\binom{\\alpha}{2 i}=2^{-\\alpha} 2^{\\alpha-1}=\\frac{1}{2}\n$$\n\nwhere we use the fact that the sum of $\\binom{\\alpha}{i}$ over all even values of $i$ is $2^{\\alpha-1}$. The claim and therefore the result follows.\n\nFrom Lemma 19 we can deduce Theorem 17. In detail, let $R_{1}, \\ldots, R_{\\ell}$ be a disjoint set of $[1, n]$ rectangles whose union is $L_{n}$. Then\n\n$$\n\\begin{aligned}\n2^{\\frac{2 m}{2}} & <\\left|A \\cap L_{n}\\right|-\\left|B \\cap L_{n}\\right| \\\\\n& =\\sum_{i=1}^{\\ell}\\left|A \\cap R_{i}\\right|-\\left|B \\cap R_{i}\\right| \\\\\n& \\leq \\ell \\cdot 2^{3 m}\n\\end{aligned}\n$$\n\nwhere the first inequality is Lemma 18(2), the equality uses the fact the rectangles form a cover and are disjoint, and the second inequality follows by Lemma 19. It follows that $\\ell=2^{\\Omega(m)}=2^{\\Omega(n)}$ which completes the proof of Theorem 17.", "tables": {}, "images": {}}, {"section_id": 6, "text": "# 4.3 Proof of Theorem 12 \n\nTo prove Proposition 16, and therefore Theorem 12, it suffices to prove an analogue of Lemma 19 that applies to all balanced ordered rectangles. In fact we have already done much of the work. The main point is that for every balanced ordered partition $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ and 'most' values of $\\ell$, we have that $x_{\\ell}$ and $y_{\\ell}$ are on different sides of the partition. We now formalise the above idea, beginning\n\nwith the nice case where the partition splits $x_{\\ell}$ and $y_{\\ell}$ for every $\\ell$. Here using symmetry we may deduce the following corollary to the proof of Lemma 19.\n\nCorollary 20. Let $R=S \\times T$ be an $[i, j]$-rectangle such that $j-i=n-1$. Then\n\n$$\n\\|R \\cap A|-|R \\cap B| \\leq 2^{3 m}\n$$\n\nTo move from this to our more general case, we first elucidate some properties of balanced ordered partitions. So fix such a $\\left(\\Pi_{0}, \\Pi_{1}\\right)$. Let $G$ be the set containing those $i \\in[n]$ such that $x_{i}$ and $y_{i}$ are in different parts of the partition, i.e. $G$ contains those $i \\in[n]$ such that exactly one of $x_{i}$ and $y_{i}$ lies in $\\Pi_{0}$. Let $V_{G}$ contain all those $x_{i}$ and $y_{i}$ such that $i \\in G$. Moreover, let $I_{G}$ contain all intervals $I_{i}$ such that $I_{i} \\subseteq V_{G}$.\n\nIt will be convenient to assume that $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ is well-behaved with respect to the intervals $I_{\\ell}$ in the following sense: we call $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ neat if for every interval $I_{\\ell}$ we have that $I_{\\ell} \\subseteq \\Pi_{0}$ or $I_{\\ell} \\subseteq \\Pi_{1}$. In the remainder, we can largely restrict ourselves to neat partitions due to the following result.\n\nLemma 21. Let $R$ be an ordered balanced $\\left(\\Pi_{0}, \\Pi_{1}\\right)$-rectangle. Then there there is a neat ordered balanced partition $\\left(\\Gamma_{0}, \\Gamma_{1}\\right)$ and a set of disjoint $\\left(\\Gamma_{0}, \\Gamma_{1}\\right)$-rectangles $R_{1}, R_{2}, \\ldots, R_{k}$ with $k \\leq 256$ such that $R=\\bigcup_{\\ell \\in[k]} R_{\\ell}$.\n\nProof. Suppose w.l.o.g. that $\\left|\\Pi_{0}\\right| \\leq\\left|\\Pi_{1}\\right|$. There are at most two intervals $I_{i}, I_{j}$ which violate neatness, i.e. that contain elements from $\\Pi_{0}$ and $\\Pi_{1}$. Let $\\left(\\Gamma_{0}, \\Gamma_{1}\\right)$ be the partition of $Z$ that we get by putting all elements from $I_{i}$ and $I_{j}$ into $\\Pi_{0}$. Then, by construction, $\\left(\\Gamma_{0}, \\Gamma_{1}\\right)$ is neat and ordered. Moreover, it is balanced, since $\\Gamma_{0}$ gained at most the 8 elements from $I_{i} \\cup I_{j}$, so $\\left|\\Gamma_{0}\\right| \\leq\\left|\\Pi_{0}\\right|+8 \\leq$ $n+8 \\leq \\frac{2 n}{3}$, where for the last inequality we use that $n$ is sufficiently big.\n\nNow consider $\\alpha \\subseteq I_{i} \\cup I_{j}$. Then let $R_{\\alpha}$ contain exactly those sets $U$ from $R$ for which $U \\cap\\left(I_{i} \\cup I_{j}\\right)=\\alpha$. Then clearly $R_{\\alpha} \\cap R_{\\alpha^{\\prime}}=\\varnothing$ for $\\alpha \\neq \\alpha^{\\prime}$. Note that $R_{\\alpha}$ is both a $\\left(\\Pi_{0}, \\Pi_{1}\\right)$-rectangle and a $\\left(\\Gamma_{0}, \\Gamma_{1}\\right)$ rectangle since it is fully determined on $I_{i} \\cup I_{j}$ and thus on the difference between the two partitions. Moreover, we have\n\n$$\nR=\\bigcup_{\\alpha \\subseteq I_{i} \\cup I_{j}} R_{\\alpha}\n$$\n\nSince $\\left|I_{i} \\cup I_{j}\\right|=8$ and thus the disjoint union ranges over $2^{8}=256$ sets, the claim follows.\nNeat ordered partitions have the following useful properties.\nLemma 22. Let $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ be a neat, ordered and balanced partition such that $\\left|\\Pi_{0}\\right| \\leq\\left|\\Pi_{1}\\right|$. Then\n(1) $\\Pi_{0} \\subseteq V_{G}$ and\n(2) $\\left|\\Pi_{0}\\right|=|G|$.\n\nProof. Let $[i, j]$ be the interval which induces the partition. First, suppose $\\Pi_{0}=Z[i, j]$. Since $\\left|\\Pi_{0}\\right| \\leq n$ it follows that for every two elements $z_{k}, z_{\\ell}$ of $\\Pi_{0}$ the indices have distance at most $n-1$, i.e., if $z_{k}, z_{\\ell} \\in \\Pi_{0}$ then $|\\ell-k| \\leq n-1$. Since the distance between $x_{\\ell}$ and $y_{\\ell}$ is $n$ for every $\\ell$, it follows that $\\Pi_{0}$ cannot contain both $x_{\\ell}$ and $y_{\\ell}$ and thus $\\Pi_{0} \\subseteq V_{G}$.\n\nIf instead $\\Pi_{0}=Z \\backslash Z[i, j]$, then\n\n$$\n\\Pi_{0}=\\left\\{z_{\\ell} \\in Z \\mid \\ell<i\\right\\} \\cup\\left\\{z_{\\ell} \\in Z \\mid \\ell>j\\right\\}\n$$\n\nSo since $|Z[i, j]| \\geq n$, we know that $j-i \\geq n-1$ and it is easy to see that no two elements of $\\Pi_{0}$ are at distance $n$. So again $\\Pi_{0} \\subseteq V_{G}$; we have shown (1).\n\nFor (2), observe that for every $\\ell \\in G$ we must have either $x_{\\ell}$ or $y_{\\ell}$ in $\\Pi_{0}$, so $|G| \\leq\\left|\\Pi_{0}\\right|$. Moreover, from (1) we get that for every $\\ell \\in G$ the set $\\Pi_{0}$ cannot contain $x_{\\ell}$ and $y_{\\ell}$, so $\\left|\\Pi_{0}\\right| \\leq|G|$ and thus $\\left|\\Pi_{0}\\right|=|G|$.\n\nWe can now deploy Corollary 20 and Lemma 22 to prove a generalisation of Lemma 19.\nLemma 23. Let $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ be a neat, ordered and balanced partition and let $R=S \\times T$ be a $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ rectangle. Then\n\n$$\n||R \\cap A|-|R \\cap B|| \\leq 2^{10 m / 3}\n$$\n\nProof. Suppose w.l.o.g. that $\\left|\\Pi_{0}\\right| \\leq\\left|\\Pi_{1}\\right|$. Note that, since the partition is balanced, we have $\\left|\\Pi_{0}\\right| \\geq 2 n / 3$. Define $\\Pi_{1}^{q}:=\\Pi_{1} \\cap V_{G}$ and $\\Pi_{1}^{b}:=\\Pi_{1} \\backslash \\Pi_{1}^{q}$. Observe that, via Lemma 22, we get $\\left|\\Pi_{0}\\right|=\\left|\\Pi_{1}^{q}\\right|$ and thus $\\left|\\Pi_{1}^{b}\\right|=2 n-\\left|\\Pi_{0}\\right|-\\left|\\Pi_{1}^{q}\\right|=2 n-2\\left|\\Pi_{0}\\right| \\leq 2 n / 3$.\n\nNow let $\\alpha \\subseteq \\Pi_{1}^{b}$ be a subset of the 'bad elements', i.e. the elements $x_{\\ell}, y_{\\ell}$ that both lie in $\\Pi_{1}$. Let $T_{\\alpha}:=\\left\\{U \\in T \\mid U \\cap \\Pi_{1}^{b}=\\alpha\\right\\}$ and $T^{\\alpha}=\\left\\{U \\backslash \\alpha \\mid U \\in T_{\\alpha}\\right\\}$. Define $R^{\\alpha}=S \\times T^{\\alpha}$. By construction, every element of $S \\times T^{\\alpha}$ is a subset of $V_{G}$. By renaming elements we can view $S \\times T^{\\alpha}$ as a subset of $L_{|G|}$, since all elements in $\\Pi_{0}$ are in $V_{G}$ by Lemma 22(1). Then for every $\\alpha \\in U$, since $|G|=\\left|\\Pi_{0}\\right|$-by Lemma 22(2)-and by applying Corollary 20 to $R^{\\alpha}$ with $m^{\\prime}:=|G| / 4$, we obtain that\n\n$$\n\\left\\|R^{\\alpha} \\cap A\\right|-\\left|R^{\\alpha} \\cap B\\right\\| \\leq 2^{3 m^{\\prime}}=2^{\\frac{|G|}{4}}\n$$\n\nHere we use that our partition is neat and thus that $G$ is a union of $m^{\\prime}$ many intervals.\nMoreover, because $\\left(\\Pi_{0}, \\Pi_{1}\\right)$ is neat, $\\Pi_{1}^{b}$ is a union of intervals. Suppose there is some $\\ell$ such that $I_{\\ell} \\subseteq \\Pi_{1}^{b}$ and $\\left|\\alpha \\cap I_{\\ell}\\right| \\neq 1$. Then $\\alpha \\notin \\mathcal{L}$ and thus $T_{\\alpha} \\cap \\mathcal{L}=\\varnothing$. Let $U \\subseteq \\mathcal{L}$ be the set of $\\alpha \\subseteq \\Pi_{1}^{b}$ such that $T_{\\alpha} \\cap \\mathcal{L} \\neq \\varnothing$. Then for all $\\alpha \\in U$ we have that $\\left|\\alpha \\cap I_{\\ell}\\right|=1$, for every $\\ell$ such that $I_{\\ell} \\subseteq \\Pi_{1}^{b}$. We obtain that\n\n$$\n|U| \\leq 4^{\\frac{\\left|\\Pi_{1}^{b}\\right|}{4}}=4^{\\frac{(n-2|G|}{4}}=2^{n-|G|}\n$$\n\nIt follows that\n\n$$\n\\begin{aligned}\n|R \\cap A|-|R \\cap B|| & \\leq \\sum_{\\alpha \\in U}\\left\\|R^{\\alpha} \\cap A\\right|-\\left|R^{\\alpha} \\cap B\\right\\| \\\\\n& \\leq 2^{n-|G|} \\cdot 2^{\\frac{|G|}{4}}=2^{n-\\frac{|G|}{4}} \\leq 2^{\\frac{3 n}{6}}=2^{\\frac{10 m}{3}}\n\\end{aligned}\n$$\n\nas required, where we use that $|G|=\\left|\\Pi_{0}\\right| \\geq 2 n / 3$.\nProposition 16 now follows by a routine calculation similar to what we have already seen.\nProof of Proposition 16. We assume first, as before, that $n$ is divisible by four, so we can apply all results from Section 4. Let $R_{1}, \\ldots, R_{\\ell}$ be an ordered disjoint cover of $L_{n}$. With Lemma 21, we can assume that the partitions for all rectangles are neat, since this only changes the number of rectangles by a constant factor. Then\n\n$$\n\\begin{aligned}\n2^{\\frac{2 n}{3}} & <\\left|A \\cap L_{n}\\right|-\\left|B \\cap L_{n}\\right| \\\\\n& =\\sum_{i=1}^{\\ell}\\left|A \\cap R_{i}\\right|-\\left|B \\cap R_{i}\\right| \\\\\n& \\leq \\ell \\cdot 2^{\\frac{10 m}{3}}\n\\end{aligned}\n$$\n\nWhere the first equality is Lemma 18(2), the second uses the fact the $\\left\\{R_{i}\\right\\}_{i \\in[\\ell]}$ is a disjoint cover of $L_{n}$ and the inequality follows by Lemma 23. Since $\\frac{7}{2}>\\frac{10}{3}$, we obtain that $\\ell=2^{\\Omega(m)}=2^{\\Omega(n)}$.\n\nNow assume that $n$ is not divisible by four, so $n=4 t+a$ for some $a \\in[3]$. We call the elements of the form $x_{4 t+b}, y_{4 t+b}$, where $b \\in[a]$ the spare elements. For each $i \\in[\\ell]$, let $R_{i}^{\\prime}$ contain exactly those sets $U$ from $R_{i}$, that do not contain any spare elements. Then clearly $\\bigcup_{i \\in \\ell} R_{i}^{\\prime}=L_{4 t}$ and moreover, the union is disjoint. Suppose $R_{i}$ is a $\\left(\\Pi_{0}, \\Pi_{1}\\right)$-rectangle. Then for $i \\in\\{0,1\\}$ define $\\Pi_{i}^{\\prime}$ to be the set obtained from $\\Pi_{i}$ by removing all the spare elements. It follows that $R_{i}^{\\prime}$ is also a $\\left(\\Pi_{0}^{\\prime}, \\Pi_{1}^{\\prime}\\right)$\n\nrectangle. The only remaining problem is that $R_{t}^{\\prime}$ might not be balanced. But, by essentially the same argument as that used in Lemma 21, there is an ordered balanced partition $\\left(\\Gamma_{0}, \\Gamma_{1}\\right)$ and a set of disjoint $\\left(\\Gamma_{0}, \\Gamma_{1}\\right)$-rectangles $T_{1}, \\ldots, T_{k}$ with $k \\leq 2^{6}=64$ such that $R_{t}^{\\prime}=\\bigcup_{j \\in[k]} T_{j}$. We thus obtain an ordered disjoint cover of $L_{4 t}$ of size at most $64 \\ell$. It follows that $\\ell=2^{\\Omega(4 t)}=2^{\\Omega(n)}$.\n\nCombining Proposition 16 and Proposition 7 directly yields Theorem 12 and thus Theorem 1.", "tables": {}, "images": {}}, {"section_id": 7, "text": "# 5 CONCLUSIONS \n\nWe have shown an optimal double-exponential separation in terms of succinctness of CFGs from their unambiguous variant. Notably, this separation holds for a natural language over a binary alphabet. To obtain our separation we introduced a lower bound technique based on rectangles (Proposition 7), inspired by methods from knowledge compilation [6]. However, our argument has a different flavour to these lower bounds and so opens up interesting prospects for future work.\n\nIn particular, our lower bound applies to an unambiguous representation format. Dealing with such models poses a challenge and perhaps our techniques can be applied more widely to gain a better understanding of unambiguity. For example, in the context of document spanners it has been shown that rigid grammars can be made unambiguous in exponential time [3, Theorem 5]; can we show that this is optimal? Closer to the topic of our paper, can we prove that complementation is hard for uCFGs over finite languages? We should note that studying the complement operation for unambiguous representation formats can be challenging. The case of unambiguous finite automata $[16,32]$ and structured d-DNNF circuits [42] have only recently been solved, and even then the lower bounds are only quasi-polynomial. Moreover, the case of d-DNNF circuits has been open for over two decades. We hope that this paper marks a step towards a better understanding of unambiguity.", "tables": {}, "images": {}}, {"section_id": 8, "text": "## ACKNOWLEDGMENTS\n\nThe authors thank Florent Capelli for helpful discussions. The first author would also like to thank the Simons Institute Fall 2023 program 'Logic and Algorithms in Database Theory and AI'. Here, via discussions with Wim Martens, he learned about the conjecture from [20] that is solved in this paper.\n\nThe first author was partially supported by the Agence nationale de la recherche (ANR) project EQUUS ANR-19-CE48-0019. The second author was funded by the Deutsche Forschungsgemeinschaft (DFG, German Research Foundation) project number 414325841.", "tables": {}, "images": {}}, {"section_id": 9, "text": "# REFERENCES \n\n[1] Antoine Amarilli, Pierre Bourhis, Louis Jachiet, and Stefan Mengel. A circuit-based approach to efficient enumeration. In Ioannis Chatzigiannakis, Piotr Indyk, Fabian Kuhn, and Anca Muscholl, editors, 44th International Colloquium on Automata, Languages, and Programming, ICALP 2017, July 10-14, 2017, Warsaw, Poland, volume 80 of LIPIcs, pages 111:1-111:15. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2017. URL: https://doi.org/10.4230/LIPIcs.ICALP.2017.111, doi:10.4230/LIPICS.ICALP.2017.111.\n[2] Antoine Amarilli and Florent Capelli. Tractable circuits in database theory. SIGMOD Rec., 53(2):6-20, 2024. doi:10.1145/3685980.3685982.\n[3] Antoine Amarilli, Louis Jachiet, Martin Mu\u00f1oz, and Cristian Riveros. Efficient enumeration for annotated grammars. In Leonid Libkin and Pablo Barcel\u00f3, editors, PODS '22: International Conference on Management of Data, Philadelphia, PA, USA, June 12 - 17, 2022, pages 291-300. ACM, 2022. doi:10.1145/3517804.3526232.\n[4] Nurzhan Bakibayev, Tom\u00e1s Kocisk\u00fd, Dan Olteanu, and Jakub Zavodny. Aggregation and ordering in factorised databases. Proc. VLDB Endow., 6(14):1990-2001, 2013. URL: http://www.vldb.org/pvldb/vol6/p1990-zavodny.pdf, doi:10.14778/2556549.2556579.\n[5] Christoph Berkholz, Jens Keppeler, and Nicole Schweikardt. Answering conjunctive queries under updates. In Emanuel Sallinger, Jan Van den Bussche, and Floris Geerts, editors, Proceedings of the 36th ACM SIGMOD-SIGACTSIGAI Symposium on Principles of Database Systems, PODS 2017, Chicago, IL, USA, May 14-19, 2017, pages 303-318. ACM, 2017. doi:10.1145/3034786.3034789.\n[6] Simone Bova, Florent Capelli, Stefan Mengel, and Friedrich Slivovsky. Knowledge compilation meets communication complexity. In Subbarao Kambhampati, editor, Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI 2016, New York, NY, USA, 9-15 July 2016, pages 1008-1014. IJCAI/AAAI Press, 2016. URL: http://www.ijcai.org/Abstract/16/147.\n[7] Walter Bucher, Hermann A. Maurer, Karel Culik II, and Detlef Wotschke. Concise description of finite languages. Theor. Comput. Sci., 14:227-246, 1981. doi:10.1016/0304-3975(81)90044-X.\n[8] Cezar C\u00e2mpeanu and Wing Hong Ho. The maximum state complexity for finite languages. J. Autom. Lang. Comb., 9(2/3):189-202, 2004. URL: https://doi.org/10.25596/jalc-2004-189, doi:10.25596/JALC-2004-189.\n[9] Katrin Casel, Henning Fernau, Serge Gaspers, Benjamin Gras, and Markus L. Schmid. On the complexity of the smallest grammar problem over fixed alphabets. Theory Comput. Syst., 65(2):344-409, 2021. URL: https://doi.org/10.1007/s00224-020-10013-w, doi:10.1007/S00224-020-10013-W.\n[10] Noam Chomsky. On certain formal properties of grammars. Inf. Control., 2(2):137-167, 1959. doi:10.1016/S0019-9958(59)90362-6.\n[11] Thomas Colcombet. Unambiguity in automata theory. In Jeffrey O. Shallit and Alexander Okhotin, editors, Descriptional Complexity of Formal Systems - 17th International Workshop, DCFS 2015, Waterloo, ON, Canada, June 25-27, 2015. Proceedings, volume 9118 of Lecture Notes in Computer Science, pages 3-18. Springer, 2015. doi:10.1007/978-3-319-19225-3\\_1.\n[12] Thomas Colcombet, Karin Quaas, and Michal Skrzypczak. Unambiguity in automata theory (dagstuhl seminar 21452). Dagstuhl Reports, 11(10):57-71, 2021. URL: https://doi.org/10.4230/DagRep.11.10.57, doi:10.4230/DAGREP.11.10.57.\n[13] Adnan Darwiche and Pierre Marquis. A knowledge compilation map. J. Artif. Intell. Res., 17:229-264, 2002. URL: https://doi.org/10.1613/jair.999, doi:10.1613/JAIR.989.\n[14] Pavol Duris, Juraj Hromkovic, Stasys Jukna, Martin Sauerhoff, and Georg Schnitger. On multi-partition communication complexity. Inf. Comput., 194(1):49-75, 2004. URL: https://doi.org/10.1016/j.ic.2004.05.002, doi:10.1016/J.IC.2004.05.002.\n[15] Yuval Filmus. Lower bounds for context-free grammars. Inf. Process. Lett., 111(18):895-898, 2011. URL: https://doi.org/10.1016/j.ipl.2011.06.006, doi:10.1016/J.IPL.2011.06.006.\n[16] Mika G\u00f6\u00f6s, Stefan Kiefer, and Weiqiang Yuan. Lower bounds for unambiguous automata via communication complexity. In Mikolaj Bojanczyk, Emanuela Merelli, and David P. Woodruff, editors, 49th International Colloquium on Automata, Languages, and Programming, ICALP 2022, July 4-8, 2022, Paris, France, volume 229 of LIPIcs, pages 126:1126:13. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2022. URL: https://doi.org/10.4230/LIPIcs.ICALP.2022.126, doi:10.4230/LIPICS.ICALP.2022.126.\n[17] Markus Holzer and Simon Wolfsteiner. On the grammatical complexity of finite languages. In Stavros Konstantinidis and Giovanni Pighizzini, editors, Descriptional Complexity of Formal Systems - 20th IFIP WG 1.02 International Conference, DCFS 2018, Halifax, NS, Canada, July 25-27, 2018, Proceedings, volume 10952 of Lecture Notes in Computer Science, pages 151-162. Springer, 2018. doi:10.1007/978-3-319-94631-3\\_13.\n[18] John C. Kieffer and En-Hui Yang. Grammar-based codes: A new class of universal lossless source codes. IEEE Trans. Inf. Theory, 46(3):737-754, 2000. doi:10.1109/18.841160.\n\n[19] John C. Kieffer, En-Hui Yang, Gregory J. Nelson, and Pamela C. Cosman. Universal lossless compression via multilevel pattern matching. IEEE Trans. Inf. Theory, 46(4):1227-1245, 2000. doi:10.1109/18.850665.\n[20] Benny Kimelfeld, Wim Martens, and Matthias Niewerth. A formal language perspective on factorized representations. arXiv, 2025. Accepted for publication in the Proceedings of the 28th International Conference on Database Theory (ICDT 2025). URL: https://doi.org/10.48550/arXiv.2309.11663, arXiv:2309.11663, doi:10.48550/ARXIV. 2309.11663.\n[21] Markus Lohrey. Algorithmics on slp-compressed strings: A survey. Groups Complex. Cryptol., 4(2):241-299, 2012. URL: https://doi.org/10.1515/gcc-2012-0016, doi:10.1515/GCC-2012-0016.\n[22] Markus Lohrey and Markus L. Schmid. Enumeration for mso-queries on compressed trees. Proc. ACM Manag. Data, 2(2):78, 2024. doi:10.1145/3651141.\n[23] Kurt Mehlhorn and Erik Meineche Schmidt. Las vegas is better than determinism in VLSI and distributed computing (extended abstract). In Harry R. Lewis, Barbara B. Simons, Walter A. Burkhard, and Lawrence H. Landweber, editors, Proceedings of the 14th Annual ACM Symposium on Theory of Computing, May 5-7, 1982, San Francisco, California, USA, pages 330-337. ACM, 1982. doi:10.1145/800070.802208.\n[24] Martin Mu\u00f1oz and Cristian Riveros. Streaming enumeration on nested documents. In Dan Olteanu and Nils Vortmeier, editors, 25th International Conference on Database Theory, ICDT 2022, March 29 to April 1, 2022, Edinburgh, UK (Virtual Conference), volume 220 of LIPIcs, pages 19:1-19:18. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2022. URL: https://doi.org/10.4230/LIPIcs.ICDT.2022.19, doi:10.4230/LIPICS. ICDT.2022.19.\n[25] Martin Mu\u00f1oz and Cristian Riveros. Constant-delay enumeration for slp-compressed documents. In Floris Geerts and Brecht Vandevoort, editors, 26th International Conference on Database Theory, ICDT 2023, March 28-31, 2023, Ioannina, Greece, volume 255 of LIPIcs, pages 7:1-7:17. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2023. URL: https://doi.org/10.4230/LIPIcs.ICDT.2023.7, doi:10.4230/LIPICS.ICDT.2023.7.\n[26] Dan Olteanu. Factorized databases: A knowledge compilation perspective. In Adnan Darwiche, editor, Beyond NP, Papers from the 2016 AAAI Workshop, Phoenix, Arizona, USA, February 12, 2016, volume WS-16-05 of AAAI Technical Report. AAAI Press, 2016. URL: http://www.aaai.org/ocs/index.php/WS/AAAIW16/paper/view/12638.\n[27] Dan Olteanu. Recent increments in incremental view maintenance. In Floris Geerts and Wim Martens, editors, Companion of the 43rd Symposium on Principles of Database Systems, PODS 2024, Santiago, Chile, June 9-15, 2024, pages 8-17. ACM, 2024. doi:10.1145/3635138.3654763.\n[28] Dan Olteanu and Jakub Zavodny. Factorised representations of query results: size bounds and readability. In Alin Deutsch, editor, 15th International Conference on Database Theory, ICDT '12, Berlin, Germany, March 26-29, 2012, pages 285-298. ACM, 2012. doi:10.1145/2274576.2274607.\n[29] Dan Olteanu and Jakub Z\u00e1vodn\u00fd. Size bounds for factorised representations of query results. ACM Trans. Database Syst., 40(1):2:1-2:44, 2015. doi:10.1145/2656335.\n[30] Liat Peterfreund. Grammars for document spanners. In Ke Yi and Zhewei Wei, editors, 24th International Conference on Database Theory, ICDT 2021, March 23-26, 2021, Nicosia, Cyprus, volume 186 of LIPIcs, pages 7:17:18. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2021. URL: https://doi.org/10.4230/LIPIcs.ICDT.2021.7, doi:10.4230/LIPICS.ICDT.2021.7.\n[31] Anup Rao and Amir Yehudayoff. Communication Complexity: and Applications. Cambridge University Press, 2020.\n[32] Mikhail A. Raskin. A superpolynomial lower bound for the size of non-deterministic complement of an unambiguous automaton. In Ioannis Chatzigiannakis, Christos Kaklamanis, D\u00e1niel Marx, and Donald Sannella, editors, 45th International Colloquium on Automata, Languages, and Programming, ICALP 2018, July 9-13, 2018, Prague, Czech Republic, volume 107 of LIPIcs, pages 138:1-138:11. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2018. URL: https://doi.org/10.4230/LIPIcs.ICALP.2018.138, doi:10.4230/LIPICS. ICALP.2018.138.\n[33] Martin Sauerhoff. Approximation of boolean functions by combinatorial rectangles. Theor. Comput. Sci., 301(1-3):4578, 2003. doi:10.1016/S0304-3975(02)00568-6.\n[34] Maximilian Schleich, Dan Olteanu, and Radu Ciucanu. Learning linear regression models over factorized joins. In Fatma \u00d6zcan, Georgia Kontrika, and Sam Madden, editors, Proceedings of the 2016 International Conference on Management of Data, SIGMOD Conference 2016, San Francisco, CA, USA, June 26 - July 01, 2016, pages 3-18. ACM, 2016. doi:10.1145/2882903.2882939.\n[35] Markus L. Schmid and Nicole Schweikardt. Spanner evaluation over slp-compressed documents. In Leonid Libkin, Reinhard Pichler, and Paolo Guagliardo, editors, PODS'21: Proceedings of the 40th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, Virtual Event, China, June 20-25, 2021, pages 153-165. ACM, 2021. doi:10.1145/3452021.3450325.\n[36] Markus L. Schmid and Nicole Schweikardt. Document spanners - A brief overview of concepts, results, and recent developments. In Leonid Libkin and Pablo Barcel\u00f3, editors, PODS '22: International Conference on Management of Data, Philadelphia, PA, USA, June 12 - 17, 2022, pages 139-150. ACM, 2022. doi:10.1145/3517004.3526069.\n[37] Markus L. Schmid and Nicole Schweikardt. Query evaluation over slp-represented document databases with complex document editing. In Leonid Libkin and Pablo Barcel\u00f3, editors, PODS '22: International Conference on Management of\n\nData, Philadelphia, PA, USA, June 12 - 17, 2022, pages 79-89. ACM, 2022. doi:10.1145/3517804.3524158.\n[38] Erik Meineche Schmidt and Thomas G. Szymanski. Succinctness of descriptions of unambiguous context-free languages. SIAM J. Comput., 6(3):547-553, 1977. doi:10.1137/0206039.\n[39] Alexander A. Sherstov. Communication complexity theory: Thirty-five years of set disjointness. In Erzs\u00e9bet CsuhajVarj\u00fa, Martin Dietzfelbinger, and Zolt\u00e1n \u00c9sik, editors, Mathematical Foundations of Computer Science 2014 - 39th International Symposium, MFCS 2014, Budapest, Hungary, August 25-29, 2014. Proceedings, Part I, volume 8634 of Lecture Notes in Computer Science, pages 24-43. Springer, 2014. doi:10.1007/978-3-662-44522-8 $\\backslash . .3$.\n[40] Alexander A. Sherstov. The multiparty communication complexity of set disjointness. SIAM J. Comput., 45(4):14501489, 2016. doi:10.1137/120891587.\n[41] Michael Sipser. Introduction to the theory of computation. PWS Publishing Company, 1997.\n[42] Harry Vinall-Smeeth. Structured d-dnnf is not closed under negation. In Proceedings of the Thirty-Third International Joint Conference on Artificial Intelligence, IJCAI 2024, Jeju, South Korea, August 3-9, 2024, pages 3593-3601. ijcai.org, 2024. URL: https://www.ijcai.org/proceedings/2024/398.\n[43] En-Hui Yang and John C. Kieffer. Efficient universal lossless data compression algorithms based on a greedy sequential grammar transform - part one: Without context models. IEEE Trans. Inf. Theory, 46(3):755-777, 2000. doi:10.1109/10.841161.", "tables": {}, "images": {}}, {"section_id": 10, "text": "# A A SMALL CFG FOR $L_{n}$ \n\nFix an integer $n \\in \\mathbb{N}$. The idea will be to construct a word $w$ of length $n-1$ and then add another word $a w^{\\prime} a$ where $w^{\\prime}$ also has length $n-1$ at some position into $w$.\n\nFirst, it will be useful to create words of specific lengths. To this end, for all $i$ with $2^{i}<n$, we introduce a non-terminal $B_{i}$ that generates all possible words of length $2^{i}$ by the rules\n\n$$\n\\begin{aligned}\n& B_{i} \\rightarrow B_{i-1} B_{i-1} \\\\\n& B_{0} \\rightarrow a \\mid b\n\\end{aligned} \\quad \\text { for } i \\text { with } 1 \\leq 2^{i}<n\n$$\n\nFrom the binary representation of $n-1$, we can compute a set $I=\\left\\{i_{1}, \\ldots, i_{\\ell}\\right\\}$ of integers of size $O(\\log (n))$ such that $n-1=\\sum_{i \\in I} 2^{i}$. Then we can imagine that $w$ is decomposed into blocks of length $2^{i}$ for $i \\in I$, that is $w \\in\\{a, b\\}^{2^{i_{1}}} \\times \\ldots \\times\\{a, b\\}^{2^{i_{2}}}$. Creating the blocks of $w$ is easy with the $B_{i}$, but we still have to choose in which block we want to add $a w^{\\prime} a$. To this end, we introduce a binary tree $T=(V, E)$ whose leaves are bijectively labelled with the elements from $I$. For every node $v$ of $T$ we introduce two non-terminals $C_{v}, D_{v}$ where intuitively in a parse tree we will use $C_{v}$ if $a w^{\\prime} a$ is added in a subword corresponding to the blocks of the leaf labels below $v$ and $D_{v}$ otherwise. Concretely, for $v$ with children $u, w$, we add the rules\n\n$$\n\\begin{aligned}\n& C_{v} \\rightarrow C_{u} D_{w} \\mid D_{u} C_{w} \\\\\n& D_{v} \\rightarrow D_{u} D_{w}\n\\end{aligned}\n$$\n\nFor the leaves $v$, there are two cases: first we add for all leaves $v$ and all $i_{j}$ such that the label of $v$ is $i_{j}$ the rule\n\n$$\nD_{v} \\rightarrow B_{i_{j}}\n$$\n\nto generate all words of length $2^{i_{j}}$ from symbol $D_{v}$ (since there we do not want to add $a w^{\\prime} a$ ).\nFor the $C_{v}$, we want to create all words of length $2^{i_{j}}$ and insert $a w^{\\prime} a$ at some position. We proceed similarly to Example 3. For all leaves $v$ and all $i_{j}$ such that the label of $v$ is $i_{j}$ we add the rule\n\n$$\nC_{v} \\rightarrow A_{I_{j}}\n$$\n\nThen, we introduce symbols $A_{i}$ for all $i$ with $2^{i}<n$ and rules\n\n$$\n\\begin{array}{ll}\nA_{i} \\rightarrow B_{i-1} A_{i-1} & \\text { for } i \\text { with } 2^{i}<n \\\\\nA_{0} \\rightarrow B_{0} a S a \\mid a S a B_{0},\n\\end{array}\n$$\n\nwhere $S$ is a new symbol from which we create $w^{\\prime}$ by the rule\n\n$$\nS \\rightarrow B_{i_{1}} \\ldots B_{i_{r}}\n$$\n\nTaking $C_{r}$, where $r$ is the root of $T$, as the starting symbol completes the construction of the grammar. By the discussion above, it generates $L_{n}$. So it only remains to show that the size of the grammar is $O(\\log (n))$.\n\nFirst, observe that all rules but the last-which is of size $|I|=O(\\log (n))$-have constant size. So it suffices to bound the number of rules. Noting further, that for every non-terminal $T$ we have only a constant number of rules $T \\rightarrow W$, we can in fact just bound the number of non-terminals. By construction, we have $O(\\log (n))$ non-terminals $A_{i}$ and $B_{i}$. Moerover, we have $O(|V(T)|)=$ $O(|I|)=O(\\log (n))$ non-terminals $C_{v}$ and $D_{v}$. The only additional non-terminal is the single $S$, which completes the proof.", "tables": {}, "images": {}}], "id": "2412.03199v2", "authors": ["Stefan Mengel", "Harry Vinall-Smeeth"], "categories": ["cs.DB", "cs.FL"], "abstract": "Motivated by recent connections to factorised databases, we analyse the\nefficiency of representations by context free grammars (CFGs). Concretely, we\nprove a recent conjecture by Kimelfeld, Martens, and Niewerth (ICDT 2025), that\nfor finite languages representations by general CFGs can be\ndoubly-exponentially smaller than those by unambiguous CFGs. To do so, we show\nthe first exponential lower bounds for representation by unambiguous CFGs of a\nfinite language that can efficiently be represented by CFGs. Our proof first\nreduces the problem to proving a lower bound in a non-standard model of\ncommunication complexity. Then, we argue similarly in spirit to a recent\ndiscrepancy argument to show the required communication complexity lower bound.\nOur result also implies that a finite language may admit an exponentially\nsmaller representation as a nondeterministic finite automaton than as an\nunambiguous CFG.", "updated": "2025-03-31T12:30:26Z", "published": "2024-12-04T10:39:57Z"}