{
  "title": "ajdmom: A Python Package for Deriving Moment Formulas of Affine Jump\n  Diffusion Processes",
  "sections": [
    {
      "section_id": 0,
      "text": "#### Abstract\n\nWe introduce ajdmom, a Python package designed for automatically deriving moment formulae for the well-established affine jump diffusion processes with state-independent jump intensities. ajdmom can produce explicit closed-form expressions for conditional and unconditional moments of any order, significantly enhancing the usability of these models. Additionally, ajdmom can compute partial derivatives of these moments with respect to the model parameters, offering a valuable tool for sensitivity analysis. The package's modular architecture makes it easy for adaptation and extension by researchers. ajdmom is open-source and readily available for installation from GitHub or the Python package index (PyPI).\n\n\nKeywords: Affine jump diffusion, moment derivation, Heston model, stochastic volatility, Python.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 1,
      "text": "## 1. Introduction\n\nAffine jump diffusion (AJD) processes are distinguished by their aptitude for capturing the intricate dynamics of various stochastic systems while preserving a measure of analytical tractability. These processes are characterized by affine dependencies of the drift, the instantaneous covariance matrix, and the jump intensity on state vectors, as described by Duffie et al. (2000). There are several well-known classes of AJD processes, including the Ornstein-Uhlenbeck (OU) process and the square-root diffusion (SRD) process, the latter of which was introduced by Cox et al. (1985) for modelling the term structure of interest rates. The SRD model has also been integrated into the stochastic volatility (SV) setting, notably in the Heston SV model for option pricing as formulated by Heston (1993). This model has been further extended to incorporate jumps, addressing fat tails and volatility clustering through SV with jumps in returns (SVJ) and SV with contemporaneous jumps in returns and volatility (SVCJ), as investigated by Bates (1996), Duffie et al. (2000), Eraker et al. (2003), and Broadie et al. (2007). Although these models have predominantly been applied in the realm of financial asset pricing and econometrics, their applications may extend to other areas such as inventory management (Canyakmaz et al. 2019), queueing systems (Weinberg et al. 2007; Giesecke et al. 2011), electricity markets, neural activity and others as Gorj\u00e3o et al. (2023) pointed out.\n\nDespite their versatility, AJD processes generally lack closed-form transition and marginal densities - even for basic cases such as the SRD and Heston SV models. Consequently, de-\n\nriving their moments and covariances becomes a central challenge in their study, as these are crucial for modeling and parameter estimation. As shown by Kyriakou et al. (2024), the probability distributions of these models (including Heston SV, SVJ, and SVCJ) are uniquely determined by their moments under certain regularity conditions. Their work also demonstrates that moment-based simulation can yield significant computational savings compared to conventional methods relying on conditional characteristic function (CF) inversion. Furthermore, the method of moments has been widely adopted for parameter estimation in AJDs, as evidenced by Wu et al. (2019); Yang et al. (2021); Wu et al. (2022, 2024); Wu and Hu (2025b).\nUntil very recently, closed-form moments and covariances are only available for simple AJD models like SRD. The Heston SV model, for example, one of the most popular SV models, has only a known analytical conditional CF (Heston 1993), though Jiang and Knight (2002) developed a closed-form (unconditional) CF for a simplified version of the model. Bollerslev and Zhou (2002) derived conditional moments for the integrated state of the Heston SV model and its AJD extensions with jumps. For general affine diffusion and AJD models, conditional CFs have been established by Duffie et al. (2000), Singleton (2001), and Chacko and Viceira (2003). For polynomial processes, a broader class of models, Cuchiero et al. (2012) show that all finite-order conditional moments are analytically tractable, up to a matrix exponential. For a detailed discussion of moments in related processes, see Wu and Hu (2025a). The exact simulation of the Heston SV model and its AJD extensions via numerical inversion of conditional CFs is studied by Broadie and Kaya (2006). Kyriakou et al. (2024) propose a moment-based simulation procedure with moments evaluated from conditional CFs. Simulation of relevant models based on various approximations can be found in Choi and Kwok (2024); Giesecke et al. (2011); Zhang et al. (2015); Dassios and Zhao (2017).\nIn our recent work, we developed a recursive procedure that can in principle be used to derive moments and covariances for AJD models with state-independent jump intensities (Wu and Hu 2025a). This marks the first time that fully explicit closed-form moments and covariances can be derived for a broad range of AJD models. Although this procedure can easily produce lower-order moments and covariances, it becomes extremely complex as the order of moments and covariances grows. For instance, computing the fourth moment for a very simple AJD model requires approximately $12^{4}=20,736$ sub-steps, which makes manual calculation highly impractical. In addition, calculations for different AJD models, such as those having different jump distributions, are usually quite varied. Therefore, it would be very helpful to develop a software tool to calculate the moments and covariances based on our method automatically.\nSymbolic computation is typically employed for algebraic operations, differentiation, integration, and polynomial factorization, with support provided by programming languages and libraries such as Mathematica (Wolfram Research, Inc. 2024), MATLAB (The MathWorks Inc. 2022), and Python's (Van Rossum and Drake 2009) package SymPy (Meurer et al. 2017). However, to the best of our knowledge, none of these currently offers functionalities for manipulating It\u00f4 processes, which are essential to apply our method to calculating the moments and covariances of AJD models.\nCurrently, there are some packages offering varied functionalities for different types of jumpdiffusion processes. One of the most commonly supported functionalities is the simulation of these processes, mainly applied to financial option pricing. The MATLAB (The MathWorks Inc. 2022) package PROJ_Option_Pricing_Matlab (Justin et al. 2023) supports option pricing\n\nfor diffusions, jump diffusions, and some general L\u00e9vy processes models. Meanwhile, the C++ (Stroustrup 2013) project DerivativesPricing (Gosain 2020) and the R (R Core Team 2024) package Jdmbs (Okada 2020) have implemented option pricing algorithms only for the classical Black-Scholes (Black and Scholes 1973) geometric Brownian motion model and some simple extensions with jumps. The package JumpProcesses.jl (Zagatti et al. 2024) is available in Julia (Bezanson et al. 2017) for simulating point processes with time-varying intensities, and the Julia package DifferentialEquations.jl (Rackauckas and Nie 2017) supports numerical solving of general diffusion processes. Rinn et al. (2016) developed an R package for modeling Markov processes based on the Langevin approach. There are two Python packages implementing non-parametric modeling of jump diffusion processes through the KramersMoyal equation (Rydin Gorj\u00e3o et al. 2021): jumpdiff (Gorj\u00e3o et al. 2023) and kramersmoyal (Gorj\u00e3o and Meirinhos 2019). Although non-parametric models are more general compared with parametric ones, the AJD processes considered in our package ajdmom are parametric models and are mainly applied to option pricing, in which the parameters usually have specific economic meanings, therefore favored by economists for modeling certain economic behaviors. In order to recover the equations of the jump diffusion processes, the package jumpdiff uses conditional moments from data to infer the Kramers-Moyal coefficients. In contrast to the Markov settings in jumpdiff, our method contributes to the community by deriving both conditional and unconditional moment formulae for the AJD processes under hidden Markov model (HMM) settings. For instance, in the settings of SV models, the volatility process is usually unobservable.\nThis paper introduces ajdmom, a Python package we designed and implemented for automating the derivation of the moment and covariance formulae of AJDs with state-independent jump intensities - the most commonly used class of AJD models. The ajdmom package is predicated on the insight that all moments and intermediate conditional moments can be represented as generalized polynomials, leading us to create a custom dictionary data structure, the 'Poly' class. This class facilitates auto-derivation of the moments and covariances for the AJD models. The package offers several features, including its support for deriving moments, central moments, and covariances of any order, partial differentiation with respect to model parameters, and a modular design that easily extends to other AJD or even some non-affine jump diffusion models.\nThe remainder of this paper is organized as follows: Section 2 provides an overview of AJD models and the recursive procedure used in deriving the moments in the baseline model -Heston SV model. Section 3 discusses the design and code structure of the ajdmom package, in which the AJD extensions of the Heston SV model are included. Section 4 demonstrates the application of ajdmom to the Heston SV, SVJ and SVCJ models through experiments that confirm the method's accuracy and implementation. Finally, Section 5 concludes the paper. Readers who are familiar with AJD models but do not wish to delve into the details of moment derivation can skip Sections 2 and 3 and proceed directly to Section 4 for more generalized information. Comprehensive documentation of the package, built with the Python tool Sphinx (Sphinx Development Team 2020), is hosted at http://www.yyschools.com/ajdmom, and the source code repository is available on GitHub at https://github.com/xmlongan/ajdmom.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 2,
      "text": "# 2. AJD models and recursive equation \n\nThe general AJD process is an n-dimensional Markov process, denoted by $\\boldsymbol{x}(t)$ with state\n\nspace $D \\subset \\mathbb{R}^{n}$, and evolves according to the stochastic differential equation (SDE):\n\n$$\nd \\boldsymbol{x}(t)=\\boldsymbol{\\mu}(\\boldsymbol{x}(t)) d t+\\boldsymbol{\\sigma}(\\boldsymbol{x}(t)) d \\boldsymbol{w}(t)+d \\boldsymbol{z}(t)\n$$\n\nwhere\n\n- $\\boldsymbol{w}(t)$ is an n-dimensional standard Wiener process,\n- $\\boldsymbol{z}(t)$ is an inhomogeneous compound poisson process (CPP) with jump distribution $F_{\\boldsymbol{j}}(\\cdot)$ on $\\mathbb{R}^{n}$ and intensity $\\boldsymbol{\\lambda}(\\boldsymbol{x}(t)): D \\rightarrow \\mathbb{R}_{>0}$.\n\nThe drift $\\boldsymbol{\\mu}(\\cdot)$, instantaneous covariance matrix $\\boldsymbol{\\sigma}(\\cdot) \\boldsymbol{\\sigma}(\\cdot)^{T}$, and jump intensity $\\boldsymbol{\\lambda}(\\cdot)$ all have affine dependence on $\\boldsymbol{x}(t)$ (Duffie et al. 2000), parameterized by coefficients $(\\boldsymbol{K}, \\boldsymbol{H}, \\boldsymbol{l})$ as follows:\n\n- $\\boldsymbol{\\mu}(\\boldsymbol{x})=\\boldsymbol{K}_{0}+\\boldsymbol{K}_{1} \\boldsymbol{x}$, for $\\boldsymbol{K}=\\left(\\boldsymbol{K}_{0}, \\boldsymbol{K}_{1}\\right) \\in \\mathbb{R}^{n} \\times \\mathbb{R}^{n \\times n}$.\n- $\\left(\\boldsymbol{\\sigma}(\\boldsymbol{x}) \\boldsymbol{\\sigma}(\\boldsymbol{x})^{T}\\right)_{i j}=\\left(\\boldsymbol{H}_{0}\\right)_{i j}+\\left(\\boldsymbol{H}_{1}\\right)_{i j} \\cdot \\boldsymbol{x}$, for $\\boldsymbol{H}=\\left(\\boldsymbol{H}_{0}, \\boldsymbol{H}_{1}\\right) \\in \\mathbb{R}^{n \\times n} \\times \\mathbb{R}^{n \\times n \\times n}$.\n- $\\boldsymbol{\\lambda}(\\boldsymbol{x})=\\boldsymbol{l}_{0}+\\boldsymbol{l}_{1} \\cdot \\boldsymbol{x}$, for $\\boldsymbol{l}=\\left(\\boldsymbol{l}_{0}, \\boldsymbol{l}_{1}\\right) \\in \\mathbb{R}^{n} \\times \\mathbb{R}^{n \\times n}$.\n\nAJD models have been predominantly applied in financial asset valuation and econometric analysis. In this paper, we concentrate on the most typical class of AJDs - those with stateindependent jump intensities (i.e., $\\boldsymbol{\\lambda}(\\boldsymbol{x})=\\boldsymbol{l}_{0}$ ). This class includes widely used models such as the Heston SV, SVJ, and SVCJ. It also encompasses other variants, including two-factor SV, two-factor SV with jumps in returns, SV with jumps in volatility, SV with independent jumps in returns and volatility, square-root jump diffusion, superposition of square-root diffusion and so on.\nAmong these AJDs, SV models present the greatest theoretical and computational challenges: their volatility component is inherently unobservable, and the observable price process violates the Markov property. Consequently, deriving their transition and marginal densities has long been problematic. Recent work by Wu and Hu (2025a) overcome this issue through a recursive methodology that yields closed-form expressions for conditional and unconditional moments of arbitrary order. In the rest of this section, we present this recursive approach for the Heston SV model as a baseline case; extensions to other AJDs are provided in Wu and Hu (2025a). This theoretical framework underpins the design of the Python package ajdmom, which automates the derivation of moment formulae.\nThe Heston SV model, foundational to the ajdmom package, is formalized by the following system of SDEs (Heston 1993):\n\n$$\n\\begin{aligned}\nd p(t) & =(\\mu-v(t)) d t+\\sqrt{v(t)} d w^{s}(t) \\\\\nd v(t) & =k(\\theta-v(t)) d t+\\sigma_{v} \\sqrt{v(t)} d w^{v}(t)\n\\end{aligned}\n$$\n\nwhere $p(t)$ denotes the logarithm of asset price at time $t, \\mu$ is a constant return, $v(t)$ is the instantaneous variance of return at time $t, w^{s}(t)=\\rho w^{v}(t)+\\sqrt{1-\\rho^{2}} w(t)$, and $w^{v}(t)$ and $w(t)$ are two independent Wiener processes. The process $v(t)$ is an SRD, akin to the CoxIngersoll-Ross (CIR) process (Cox et al. 1985). Parameters $k>0, \\theta>0, \\sigma_{v}>0$, and initial\n\nvariance $v(0)>0$, and it is required to ensure the positivity of the variance process $v(t)$ that $2 k \\theta>\\sigma_{v}^{2}$. For notational simplicity, the following integrals are introduced:\n\n$$\nI_{s, t} \\equiv \\int_{s}^{t} \\sqrt{v(u)} d w^{v}(u), \\quad I_{s, t}^{*} \\equiv \\int_{s}^{t} \\sqrt{v(u)} d w(u), \\quad I E_{s, t} \\equiv \\int_{s}^{t} e^{k u} \\sqrt{v(u)} d w^{v}(u)\n$$\n\nSubsequently, $I_{n, t} \\equiv I_{n h, t}, I_{n, t}^{*} \\equiv I_{n h, t}^{*}, I E_{n, t} \\equiv I E_{n h, t}$, and $I_{n} \\equiv I_{(n-1) h, n h}, I_{n}^{*} \\equiv I_{(n-1) h, n h}^{*}$ and $I E_{n} \\equiv I E_{(n-1) h, n h}$.\nThe return over the $n$-th interval of length $h$ is defined as $y_{n} \\equiv p(n h)-p((n-1) h)$. To bridge discrete and continuous analysis, $y_{n-1, t}$ is introduced as an intermediary variable that captures the process dynamics between any time $t$ and the preceding discretization mark $(n-1) h, y_{n-1, t} \\equiv p(t)-p((n-1) h)$. Upon normalizing $y_{n-1, t}$ by its conditional expected value, with condition on $v_{n-1}(\\equiv v((n-1) h))$, we define the centralized process $\\bar{y}_{n-1, t}$ :\n\n$$\n\\bar{y}_{n-1, t} \\equiv y_{n-1, t}-\\mathrm{E}\\left[y_{n-1, t} \\mid v_{n-1}\\right]\n$$\n\nwhich can be decomposed into its constituent terms as:\n\n$$\n\\bar{y}_{n-1, t}=\\frac{\\sigma_{v}}{2 k} e^{-k t} I E_{n-1, t}+\\left(\\rho-\\frac{\\sigma_{v}}{2 k}\\right) I_{n-1, t}+\\sqrt{1-\\rho^{2}} I_{n-1, t}^{*}-\\beta_{n-1, t} \\bar{v}_{n-1}\n$$\n\nwhere coefficient $\\beta_{n-1, t} \\equiv\\left(1-e^{-k[t-(n-1) h]}\\right) /(2 k)$ and normalized variance $\\bar{v}_{n-1} \\equiv v_{n-1}-\\theta$. The moments of $\\bar{y}_{n}$ can be computed based on the moments of $\\bar{y}_{n-1, t}$ at $t=n h$, thereby simplifying the analysis to discrete time points. We will consider hereafter computing the moments of $\\bar{y}_{n-1, t}$.\nThe $m$-th central moment of $y_{n-1, t}$ can be derived by relying on a set of underlying components:\n\n$$\n\\mathrm{E}\\left[I E_{n-1, t}^{m_{1}} I_{n-1, t}^{m_{2}} I_{n-1, t}^{* m_{3}} \\bar{v}_{n-1}^{m_{4}}\\right]\n$$\n\nwhere $m_{i} \\geqslant 0$ for $i=1,2,3,4$ and the summation $\\sum_{i=1}^{4} m_{i}=m$. The component moment (3) can be computed via a two-step process:\n\n$$\n\\mathrm{E}\\left[\\mathrm{E}\\left[I E_{n-1, t}^{m_{1}} I_{n-1, t}^{m_{2}} I_{n-1, t}^{* m_{3}} \\mid v_{n-1}\\right] \\bar{v}_{n-1}^{m_{4}}\\right]\n$$\n\ni.e., first compute the inner conditional expectation, then follow with the unconditional expectation. Wu and Hu (2025a) construct a recursive equation for deriving the conditional product moment:\n\n$$\n\\begin{aligned}\n& \\mathrm{E}\\left[I E_{n-1, t}^{m_{1}} I_{n-1, t}^{m_{2}} I_{n-1, t}^{* m_{3}} \\mid v_{n-1}\\right] \\\\\n& =f\\left(\\mathrm{E}\\left[I E_{n-1, s}^{m_{1}-2} I_{n-1, s}^{m_{2}} I_{n-1, s}^{* m_{3}} \\mid v_{n-1}\\right], \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}-1} I_{n-1, s}^{m_{2}} I_{n-1, s}^{* m_{3}} \\mid v_{n-1}\\right]\\right. \\\\\n& \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}} I_{n-1, s}^{m_{2}-2} I_{n-1, s}^{* m_{3}} \\mid v_{n-1}\\right], \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}+1} I_{n-1, s}^{m_{2}-2} I_{n-1, s}^{* m_{3}} \\mid v_{n-1}\\right] \\\\\n& \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}-1} I_{n-1, s}^{m_{2}-1} I_{n-1, s}^{* m_{3}} \\mid v_{n-1}\\right], \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}} I_{n-1, s}^{m_{2}-1} I_{n-1, s}^{* m_{3}} \\mid v_{n-1}\\right] \\\\\n& \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}} I_{n-1, s}^{m_{2}} I_{n-1, s}^{* m_{3}-2} \\mid v_{n-1}\\right], \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}+1} I_{n-1, s}^{m_{2}} I_{n-1, s}^{* m_{3}-2} \\mid v_{n-1}\\right])\n\\end{aligned}\n$$\n\nwhere function $f$ is defined in the Appendix. The final formulae of the conditional product moments can be expressed as polynomials in $v_{n-1}$. This implies that the moment described\n\nin Equation (3) can be represented in terms of the moments of $v_{n-1}$. Meanwhile, the $m$-th moment of $v_{n-1}$ is given by\n\n$$\n\\mathrm{E}\\left[v_{n-1}^{m}\\right]=\\prod_{j=0}^{m-1}\\left(\\theta+\\frac{j \\sigma_{v}^{2}}{2 k}\\right), \\quad m=1,2, \\ldots\n$$\n\nunder the strict stationarity assumption of $v(t)$ (Overbeck and Ryd\u00e9n 1997). This solution emerges because the stationary process $v(t)$ follows a gamma distribution with mean $\\theta$ and variance $\\theta \\sigma_{v}^{2} /(2 k)$ (Cox et al. 1985). Consequently, equations (4) and (5) enable us to compute Equation (3) for any given $m$, hence the central moments of the variable $y_{n-1, t}$ of any desired order through a recursive procedure. The procedure begins with the simplest combinations of $\\left(m_{1}, m_{2}, m_{3}\\right)$ where $m=1$, and progresses sequentially to more complex combinations, such as $\\left(m_{1}, m_{2}, m_{3}\\right), m=2$, and continues accordingly, adhering to the condition that $m_{1}+m_{2}+m_{3}=$ $m$. Extensions of the recursive approach to more complex models are detailed in (Wu and Hu 2025a).\nWhile the computational process is conceptually straightforward, it becomes computationally demanding and practically unfeasible for high-order moments if done manually. This computational challenge serves as the impetus for the development of the ajdmom software package, which is designed to automate and streamline the derivation process.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 3,
      "text": "# 3. Code design and framework of ajdmom\n### 3.1. Code design\n\nOur discussion in the previous section has illustrated the importance of the conditional product moment $\\mathrm{E}\\left[I E_{n-1, t}^{m_{1}} I_{n-1, t}^{m_{2}} I_{n-1, t}^{* m_{3}}\\left|v_{n-1}\\right|\\right.$ in our recursive procedure to calculate the moments. We discover that for any non-negative integer pair $\\left(m_{1}, m_{2}, m_{3}\\right)$, the conditional product moment can be expressed as a generalized polynomial, in the following form:\n\n$$\n\\mathrm{E}\\left[I E_{n-1, t}^{m_{1}} I_{n-1, t}^{m_{2}} I_{n-1, t}^{* m_{3}}\\left|v_{n-1}\\right|=\\sum_{m_{1}, i, j, l, o, p, q} b_{m_{1} i j l o p q} \\cdot x_{m_{1} i j l o p q}\\right.\n$$\n\nwhere $i, j, l, o, p, q$ are integers, and $b_{m_{1} i j l o p q}$ denotes the coefficient associated with the monomial $x_{m_{1} i j l o p q}$ which is defined as\n\n$$\nx_{m_{1} i j l o p q} \\equiv e^{m_{1} k(n-1) h} e^{i k[t-(n-1) h]}[t-(n-1) h]^{j} v_{n-1}^{l} k^{-o} \\theta^{p} \\sigma_{v}^{q}\n$$\n\nTo manage the complexity of this polynomial form and enable efficient manipulations, we develop a new Python class named 'Poly'. This class is a specialized dictionary data structure, which extends the capabilities of the 'UserDict' class in the Python standard library's collections module. The 'Poly' class is designed specifically to handle the unique requirements of polynomial expressions in our context.\nIn the context of the polynomial representation given by Equation (6), the key computation step within the recursive formula in Equation (4) involves the integral:\n\n$$\n\\int_{(n-1) h}^{t} e^{i k[s-(n-1) h]}[s-(n-1) h]^{j} d s\n$$\n\nFor the indefinite integral, the solution can be expressed as:\n\n$$\n\\int e^{n k t} t^{m} d t= \\begin{cases}\\sum_{i=0}^{m} \\frac{c_{n m i}}{k^{i+1}} e^{n k t} t^{m-i} & \\text { if } n \\neq 0, m \\neq 0 \\\\ \\frac{1}{n k} e^{n k t} t^{0} & \\text { if } n \\neq 0, m=0 \\\\ \\frac{1}{m+1} e^{0 k t} t^{m+1} & \\text { if } n=0, m \\neq 0 \\\\ e^{0 k t} t^{1} & \\text { if } n=0, m=0\\end{cases}\n$$\n\nwhere $c_{n m 0}=1 / n$ and for $1 \\leq i \\leq m$ :\n\n$$\nc_{n m i}=\\frac{(-1)^{i}}{n^{i+1}} \\prod_{j=m-i+1}^{m} j\n$$\n\nThus, the definite integral can be succinctly described by a polynomial of the form:\n\n$$\n\\int_{(n-1) h}^{t} e^{i k[s-(n-1) h]}[s-(n-1) h]^{j} d s=\\sum_{i, j^{\\prime}, l} b_{i j^{\\prime} l} e^{i k[t-(n-1) h]}[t-(n-1) h]^{j^{\\prime}} k^{-l}\n$$\n\nwhich is represented by an instance of the 'Poly' class. This instance is essentially a customized dictionary with keys and values corresponding to the polynomial exponents $\\left(i, j^{\\prime}, l\\right)$ and coefficients $b_{i j^{\\prime} l}$, and an additional attribute keyfor as the following:\n>>> keyfor = ('e ${ }^{\\wedge}\\left\\{\\mathrm{k}[\\mathrm{t}-(\\mathrm{n}-1) \\mathrm{h}]\\right.$ ', '[t-(n-1)h]', 'k^{-}'-]')\n\nto capture the structure of the polynomial terms.\nThis approach is leveraged to compute the integral of the expectation,\n\n$$\n\\int_{(n-1) h}^{t} e^{m k s} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}} I_{n-1, s}^{m_{2}} I_{n-1, s}^{* m_{3}} c_{n-1}\\right] d s\n$$\n\nwhich is needed multiple times in the recursive Equation (4). The result of this computation is encapsulated by another 'Poly' object. Accordingly, we have implemented a function named recursive_IEII() in the ajdmom package, which executes the recursive process as specified by Equation (4).\nFor the covariance calculations within the package, we focus on the covariance between $y_{n}$ and its lag-1 counterpart $y_{n+1}$ at different orders, denoted by $\\operatorname{cov}\\left(y_{n}^{l_{1}}, y_{n+1}^{l_{2}}\\right)$. This necessitates computing $\\mathrm{E}\\left[y_{n}^{l_{1}} y_{n+1}^{l_{2}}\\right]-\\mathrm{E}\\left[y_{n}^{l_{1}}\\right] \\mathrm{E}\\left[y_{n+1}^{l_{2}}\\right]$, which we refer to as having an order of $\\left(l_{1}, l_{2}\\right)$. Detailed steps for deriving $\\mathrm{E}\\left[y_{n}^{l_{1}} y_{n+1}^{l_{2}}\\right]$ are provided in the ajdmom package documentation, which involves expanding the terms of $y_{n+1}^{l_{2}}$ followed by those of $y_{n}^{l_{1}}$.\nThe 'Poly' class, with its custom dictionary structure, has proven crucial for efficiently deriving the moments and covariances for the Heston SV model and its AJD extensions.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 4,
      "text": "# 3.2. Framework of the ajdmom package \n\nThe ajdmom package is methodically organized into two primary components: facilities and applications. Below is an enhanced description of each segment:\nFacilities: The facilities encompass a suite of modules, each dedicated to specific mathematical operations within the domain of stochastic processes:\n\n- poly: This module introduces the 'Poly' class, a specialized dictionary-like data structure crafted to represent and manipulate polynomial moments effectively.\n- ito_mom: This module is dedicated to calculating moments of It\u00f4 processes characterized by a single SRD.\n- itos_mom: An extension of the previous module, itos_mom handles the computation of moments for It\u00f4 processes that are derived from a composite of two SRDs.\n- ito_cond_mom: This module concentrates on deriving conditional moments of It\u00f4 processes from models including jumps in the variance.\n- cpp_mom: The focus of this module lies in the derivation of moments for compound Poisson processes (CPP).\n- utils: This module provides some support for computations involving combinations and normal distributions.\n\nApplications: The applications are divided into subpackages, each targeting a different type of AJD model:\n\n- mdl_1fsv: This subpackage provides tools for the one-factor SV model, notably the Heston SV model.\n- mdl_1fsvj: Here, users can find functionality for one-factor SV models that incorporate jumps in the return process.\n- mdl_2fsv: Dedicated to two-factor SV models, this subpackage extends the complexity of the SV models.\n- mdl_2fsvj: This subpackage is similar to mdl_2fsv but includes jump features in the return process within the two-factor SV model framework.\n- mdl_srjd: This subpackage caters to the square-root jump diffusion (SRJD) process which integrates jump components into the SRD processes.\n- mdl_svvj: Extends the Heston SV model by including jumps in the variance process.\n- mdl_svij: Enhances the Heston SV model by incorporating independent jumps both in the return and variance processes.\n- mdl_svcj: Augments the Heston SV model by adding contemporaneous jumps in the return and variance processes.\n\nThe 'Poly' class within the poly module is carefully designed to facilitate the representation and manipulation of polynomial moments. It supports arithmetic operations like addition, subtraction, and multiplication via the implementation of corresponding magic methods (a way to overload the behaviors of predefined operators in Python). Additionally, the class allows for a 'Poly' object to be inversely multiplied by a constant and exponentiated to an integer power, also through magic methods. The documentation of the ajdmom package provides an in-depth exploration of these capabilities.\n\nIn the ito_mom module, we implement the derivation of the moment\n\n$$\n\\mathrm{E}\\left[I E_{n-1, t}^{m_{1}} I_{n-1, t}^{m_{2}} I_{n-1, t}^{m_{3}} \\mid v_{n-1}\\right]\n$$\n\ncatering to scenarios where the latent state is represented by an SRD. Similarly, for the case where the latent state is a superposition of two SRDs, the moment\n\n$$\n\\mathrm{E}\\left[I E_{1, n-1, t}^{m_{1}} I_{1, n-1, t}^{m_{2}} I E_{2, n-1, t}^{m_{3}} I_{2, n-1, t}^{m_{4}} I_{n-1, t}^{m_{5}} \\mid v_{1, n-1}, v_{2, n-1}\\right]\n$$\n\nis derived within the itos_mom module. The ajdmom package documentation provides detailed definitions of these terms.\nThe cpp_mom module encompasses the derivation of CPP moments. The default configuration assumes the CPP's arrival process as a homogeneous Poisson process, with the jump distribution typically set to a normal distribution-however, alternative distributions can be accommodated as required. An extension to handle an inhomogeneous Poisson process with a state-dependent affine rate is not covered in the current scope of the package.\nLeveraging these facilities, the package simplifies the coding process for automating the derivation of moments and covariances for various AJD models. We have implemented this for four distinct AJD models across four corresponding subpackages. Specifically, the mdl_1fsv subpackage caters to the one-factor SV model, i.e., the Heston SV model, and is characterized by Equations (1) and (2). Included within this subpackage are three modules-mom, cmom, and cov-for deriving moments, central moments, and covariances, respectively. An additional module, euler, facilitates the generation of model samples via the Euler approximation, serving as a validation tool by enabling comparison between derived moments and sample moments. The other three subpackages-mdl_1fsvj, mdl_2fsv, and mdl_2fsvj-mirror this structure, each consisting of modules for moments, central moments, covariances, and sample generation through Euler approximation.\nThe mdl_1fsvj subpackage caters to the one-factor SV model with jumps incorporated into returns, governed by the following SDEs:\n\n$$\n\\begin{aligned}\n& d p(t)=(\\mu-v(t) / 2) d t+\\sqrt{v(t)} d w^{s}(t)+d z(t) \\\\\n& d v(t)=k(\\theta-v(t)) d t+\\sigma \\sqrt{v(t)} d w^{v}(t)\n\\end{aligned}\n$$\n\nwhere $z(t)$ denotes a homogeneous CPP with constant arrival rate $\\lambda$ and jumps distributed according to $F_{j}\\left(\\cdot, \\boldsymbol{\\theta}_{j}\\right)$ parameterized by $\\boldsymbol{\\theta}_{j}$. The remaining parameters are consistent with those in the one-factor SV model as described by Equations (1) and (2). Within the mdl_1fsvj subpackage, a normal distribution with mean $\\mu_{j}$ and variance $\\sigma_{j}^{2}$ serves as a specific instance for the jump size distribution $F_{j}\\left(\\cdot, \\boldsymbol{\\theta}_{j}\\right)$.\nThe mdl_2fsv subpackage addresses the two-factor SV model which is defined by the following SDEs:\n\n$$\n\\begin{aligned}\nd p(t) & =(\\mu-v(t) / 2) d t+\\sqrt{v(t)} d w(t) \\\\\nv(t) & =v_{1}(t)+v_{2}(t) \\\\\nd v_{1}(t) & =k_{1}\\left(\\theta_{1}-v_{1}(t)\\right) d t+\\sigma_{v 1} \\sqrt{v_{1}(t)} d w_{1}(t) \\\\\nd v_{2}(t) & =k_{2}\\left(\\theta_{2}-v_{2}(t)\\right) d t+\\sigma_{v 2} \\sqrt{v_{2}(t)} d w_{2}(t)\n\\end{aligned}\n$$\n\nwhere variances $v_{1}(t)$ and $v_{2}(t)$ are two independent SRDs, and Wiener processes $w(t), w_{1}(t)$ and $w_{2}(t)$ are mutually independent. Extensions to three-factor and higher-factor models are also feasible.\nThe mdl_2fsvj subpackage extends the two-factor SV model by incorporating jumps into the return process, articulated by the following SDEs:\n\n$$\n\\begin{aligned}\nd p(t) & =(\\mu-v(t) / 2) d t+\\sqrt{v(t)} d w(t)+d z(t) \\\\\nv(t) & =v_{1}(t)+v_{2}(t) \\\\\nd v_{1}(t) & =k_{1}\\left(\\theta_{1}-v_{1}(t)\\right) d t+\\sigma_{v 1} \\sqrt{v_{1}(t)} d w_{1}(t) \\\\\nd v_{2}(t) & =k_{2}\\left(\\theta_{2}-v_{2}(t)\\right) d t+\\sigma_{v 2} \\sqrt{v_{2}(t)} d w_{2}(t)\n\\end{aligned}\n$$\n\nwhere $z(t)$ is a CPP analogously defined as in the mdl_1fsvj subpackage, and all others are set as in the mdl_2fsv subpackage.\nFor square-root jump diffusion processes and affine SV models including jumps in the variance -SV with jumps in the variance (SVVJ), SV with independent jumps in the return and variance (SVIJ), and SV with contemporaneous jumps in the return and variance (SVCJ) - their moment derivations are much more complicated, see Wu and Hu (2025a) for detailed explanations. The derivation of unconditional and conditional moments for the SRJD and SVCJ models is implemented in the modules mom, cmom, cond_mom, cond_cmom, cond2_mom and cond2_cmom within subpackages mdl_srjd and mdl_svcj, respectively, where cond denotes that only the initial variance is given while cond2 denotes both the initial variance and jumps over the horizon are given. The derivation of conditional moments and conditional central moments is implemented in the modules cond2_mom and cond2_cmom within subpackages mdl_svvj and mdl_svij, respectively. See the package documentation for the details. It should be noted that the derivation of unconditional moments and unconditional central moments for the SVVJ and SVIJ models can also be implemented with moderate adjustments.\nThe mdl_srjd subpackage investigates the SRJD process, represented by the following SDE:\n\n$$\nd v(t)=k(\\theta-v(t)) d t+\\sigma_{v} \\sqrt{v(t)} d w^{v}(t)+d z^{v}(t)\n$$\n\nwhere $z^{v}(t)$ is a CPP with constant arrival rate $\\lambda$ and exponentially distributed jumps with scale parameter $\\mu_{v}$.\nThe mdl_svvj subpackage alters the Heston SV model by substituting its SRD variance with above SRJD process, elucidated by the following SDEs:\n\n$$\n\\begin{aligned}\n& d p(t)=(\\mu-v(t) / 2) d t+\\sqrt{v(t)} d w^{s}(t) \\\\\n& d v(t)=k(\\theta-v(t)) d t+\\sigma_{v} \\sqrt{v(t)} d w^{v}(t)+d z^{v}(t)\n\\end{aligned}\n$$\n\nThe mdl_svij subpackage extends the Heston SV model by incorporating independent jumps into the return and variance processes, described by the following SDEs:\n\n$$\n\\begin{aligned}\n& d p(t)=(\\mu-v(t) / 2) d t+\\sqrt{v(t)} d w^{s}(t)+d z^{s}(t) \\\\\n& d v(t)=k(\\theta-v(t)) d t+\\sigma_{v} \\sqrt{v(t)} d w^{v}(t)+d z^{v}(t)\n\\end{aligned}\n$$\n\nwhere $z^{v}(t)$ is a CPP with constant arrival rate $\\lambda_{v}$ and jumps distributed according to an exponential distribution with scale parameter $\\mu_{v}, z^{s}(t)$ is another CPP independent of $z^{v}(t)$, with constant arrival rate $\\lambda_{s}$ and jumps distributed according to a normal distribution with mean $\\mu_{s}$ and variance $\\sigma_{s}^{2}$.\nThe mdl_svcj subpackage augments the Heston SV model by incorporating contemporaneous jumps into the return and variance processes, governed by the following SDEs:\n\n$$\n\\begin{aligned}\n& d p(t)=(\\mu-v(t) / 2) d t+\\sqrt{v(t)} d w^{s}(t)+d z^{s}(t) \\\\\n& d v(t)=k(\\theta-v(t)) d t+\\sigma_{v} \\sqrt{v(t)} d w^{v}(t)+d z^{v}(t)\n\\end{aligned}\n$$\n\nwhere $z^{s}(t)$ and $z^{v}(t)$ now are two CPPs sharing a common arrival process with constant arrival rate $\\lambda$. Jumps $J_{i}^{v}$ in the former CPP are distributed according to an exponential distribution with scale parameter $\\mu_{v}$, i.e., $J_{i}^{v} \\sim \\exp \\left(\\mu_{v}\\right)$ while jumps $J_{i}^{s}$ in the latter CPP are distributed according to a normal distribution with mean $\\mu_{s}+\\rho_{J} J_{i}^{v}$ (depending on the realized jump $J_{i}^{v}$ in the variance process) and variance $\\sigma_{s}^{2}$, i.e., $J_{i}^{s} \\sim \\mathcal{N}\\left(\\mu_{s}+\\rho_{J} J_{i}^{v}, \\sigma_{s}^{2}\\right)$.\nWe note that the supported AJD models within these subpackages are adaptable. For example, the jump size distribution in the subpackage mdl_1fsvj can be readily generalized to incorporate alternative distributions. While other extensions are conceivable, they may require additional exploration and validation.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 5,
      "text": "# 4. Usage demonstrations and experiments \n\nIn this section, we first use the Heston SV model as an illustrative example to demonstrate the application of the ajdmom package. Second, we present a series of numerical experiments to validate the accuracy and reliability of the methodologies we propose. Before using the ajdmom package, we first need to install it from Python package index (PyPI), through\n> pip install ajdmom\nor some other ways.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 6,
      "text": "### 4.1. Usage demonstrations\n\nAs a case study, we utilize the Heston SV model, a representative of the one-factor SV model category, to elucidate the functionality of the ajdmom package. In the literature, the Heston SV model, as rigorously defined and adopted in this research, has limited closedform solutions for its moments and covariances, with few exceptions such as the expected value $\\mathrm{E}\\left[g_{n}\\right]=(\\mu-\\theta / 2) h$. We aim to demonstrate that the ajdmom package is capable not only of replicating these known results but also of facilitating the computation of hitherto unattainable outcomes.\nTo illustrate this, we begin by detailing the process for calculating the first moment of the Heston SV model. The procedure is exemplified through the following code excerpt:\n\n```\n>>> from ajdmom import mdl_1fsv\n>>> from pprint import pprint\n>>> m1 = mdl_1fsv.moment_y(1)\n```\n\n```\n>>> msg = f\"which is a Poly with attribute keyfor = \\n{m1.keyfor}\"\n>>> print(\"moment_y(1) = \"); pprint(m1); print(msg)\nmoment_y(1) =\n{(0, 1, 0, 0, 1, 0, 0, 0): Fraction(-1, 2),\n(0, 1, 0, 1, 0, 0, 0, 0): Fraction{1, 1)}\nwhich is a Poly with attribute keyfor =\n('e^{k} , 'h', 'k^{k},\n```\n\nThe code snippet's execution yields a 'Poly' object which contains two principal key-value pairs, namely $(0,1,0,0,1,0,0,0)$ : Fraction $(-1,2)$ and $(0,1,0,1,0,0,0,0)$ : Fraction $(1,1)$, correspond to the following expressions:\n\n$$\n\\begin{gathered}\n-\\frac{1}{2} \\times e^{-0 k h} h^{1} k^{-0} \\mu^{0} \\theta^{1} \\sigma_{v}^{0} \\rho^{0}\\left(\\sqrt{1-\\rho^{2}}\\right)^{0} \\\\\n1 \\times e^{-0 k h} h^{1} k^{-0} \\mu^{1} \\theta^{0} \\sigma_{v}^{0} \\rho^{0}\\left(\\sqrt{1-\\rho^{2}}\\right)^{0}\n\\end{gathered}\n$$\n\nrespectively. The summation of these terms yields the first moment of the one-factor SV model: $\\mathrm{E}\\left[y_{n}\\right]=(\\mu-\\theta / 2) h$. This demonstrates that the ajdmom package successfully encapsulates the model's dynamics into a computationally manipulable form, specifically leveraging a custom dictionary data structure, referred to as 'Poly', to encode the moment's expression. Subsequently, we shift our focus to the computation of the covariance $\\operatorname{cov}\\left(y_{n}^{2}, y_{n+1}\\right)$ for the Heston SV model - an outcome not previously resolved in the literature. This computation is facilitated by the following code snippet:\n\n```\n>>> from ajdmom import mdl_1fsv\n>>> from pprint import pprint\n>>> cov21 = mdl_1fsv.cov_yy(2,1)\n>>> msg = f\"which is a Poly with attribute keyfor =\\n{cov21.keyfor}\"\n>>> print(\"cov_yy(2,1) = \"); pprint(cov21); print(msg)\ncov_yy(2,1) =\n{(0, 0, 3, 0, 1, 2, 0, 2): Fraction(-1, 4),\n(0, 0, 3, 0, 1, 2, 2, 0): Fraction(-5, 4),\n(0, 0, 4, 0, 1, 3, 1, 0): Fraction(3, 4),\n(0, 0, 5, 0, 1, 4, 0, 0): Fraction(-1, 8),\n(0, 1, 2, 0, 2, 1, 1, 0): Fraction(1, 2),\n(0, 1, 2, 1, 1, 1, 1, 0): Fraction(-1, 1),\n(0, 1, 3, 0, 2, 2, 0, 0): Fraction(-1, 8),\n(0, 1, 3, 1, 1, 2, 0, 0): Fraction(1, 4),\n(1, 0, 3, 0, 1, 2, 0, 2): Fraction(1, 2),\n(1, 0, 3, 0, 1, 2, 2, 0): Fraction(5, 2),\n(1, 0, 4, 0, 1, 3, 1, 0): Fraction(-3, 2),\n(1, 0, 5, 0, 1, 4, 0, 0): Fraction(1, 4),\n(1, 1, 2, 0, 1, 2, 2, 0): Fraction(1, 1),\n(1, 1, 2, 0, 2, 1, 1, 0): Fraction(-1, 1),\n```\n\n$(1,1,2,1,1,1,1,0): \\operatorname{Fraction}(2,1)$,\n$(1,1,3,0,1,3,1,0): \\operatorname{Fraction}(-3,4)$,\n$(1,1,3,0,2,2,0,0): \\operatorname{Fraction}(1,4)$,\n$(1,1,3,1,1,2,0,0): \\operatorname{Fraction}(-1,2)$,\n$(1,1,4,0,1,4,0,0): \\operatorname{Fraction}(1,8)$,\n$(2,0,3,0,1,2,0,2): \\operatorname{Fraction}(-1,4)$,\n$(2,0,3,0,1,2,2,0): \\operatorname{Fraction}(-5,4)$,\n$(2,0,4,0,1,3,1,0): \\operatorname{Fraction}(3,4)$,\n$(2,0,5,0,1,4,0,0): \\operatorname{Fraction}(-1,8)$,\n$(2,1,2,0,1,2,2,0): \\operatorname{Fraction}(-1,1)$,\n$(2,1,2,0,2,1,1,0): \\operatorname{Fraction}(1,2)$,\n$(2,1,2,1,1,1,1,0): \\operatorname{Fraction}(-1,1)$,\n$(2,1,3,0,1,3,1,0): \\operatorname{Fraction}(3,4)$,\n$(2,1,3,0,2,2,0,0): \\operatorname{Fraction}(-1,8)$,\n$(2,1,3,1,1,2,0,0): \\operatorname{Fraction}(1,4)$,\n$(2,1,4,0,1,4,0,0): \\operatorname{Fraction}(-1,8)\\}$\nwhich is a Poly with attribute keyfor $=$\n( 'e^\\{-kh\\}', 'h', 'k^\\{-\\}', 'mu', 'theta', 'sigma_v', 'rho', 'sqrt(1-rho^2)')\n\nThe execution of the provided code yields the covariance expressed within a 'Poly' object.\nThe ajdmom package further extends its utility to encompass seven additional extended models, which are accessible through the subpackages mdl_1fsvj, mdl_2fsv, mdl_2fsvj, mdl_srjd, mdl_svvj, mdl_svij and mdl_svcj, respectively. The representation of moments and covariances as 'Poly' objects simplifies the process of performing partial differentiation with respect to the model parameters. Detailed instructions for these operations are available in the ajdmom package documentation.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 7,
      "text": "# 4.2. Experiments \n\nTo evaluate the accuracy of our proposed methods and their implementation, we performed a series of experiments under the SVJ and SVCJ models, as implemented in the mdl_1fsvj and mdl_svcj subpackages, respectively.\nThe initial experimental set aimed to validate the moment calulations provided by the ajdmom package. This was achieved by comparing the theoretically derived moments against their sample counterparts, computed from a sample path of $4,000,000$ observations of the model under the parameterization $\\mu=0.125, k_{1}=0.1, \\theta_{1}=0.25, \\sigma_{v 1}=0.1, \\lambda=0.01, \\mu_{j}=0$, $\\sigma_{j}=0.05$. The sample path was generated using Euler's method, with a step size $h=1$, further subdivided into ten equal segments for finer approximation. Table 1 represents the comparative results, affirming the correctness of our method and implementation within the expected variability due to sampling randomness and the discretization error inherent in Euler's approximation.\nThe subsequent experimental series examined the accuracy of the covariance calculations. Keeping all settings consistent with the first series, we shifted our focus to the derivation of covariances. The outcomes, as summarized in Table 2, likewise support the validity of our methods and their computational realizations. For the SVCJ model, we conduct experiments to test the accuracy of the conditional moment computation, with results reported in Table 3.\n\n![table_0](table_0)\n\nTable 1: Comparison between derived moments and sample moments for the one-factor SV model with jumps in the return process. The comparison is based on a sample path of $4,000,000$ observations of the one-factor SV model with jumps in the return process, under the parameter settings ( $\\mu=0.125, k_{1}=0.1, \\theta_{1}=0.25, \\sigma_{v 1}=0.1, \\lambda=0.01, \\mu_{j}=0$, $\\sigma_{j}=0.05$ ). The sample path was generated using Euler's method, with a step size $h=1$, further subdivided into ten equal segments for finer approximation.\n\n![table_1](table_1)\n\nTable 2: Comparison between derived covariances and sample covariances for the one-factor SV model with jumps in the return process. The comparison is based on a sample path of $4,000,000$ observations of the one-factor SV model with jumps in the return process, under the parameter settings ( $\\mu=0.125, k_{1}=0.1, \\theta_{1}=0.25, \\sigma_{v 1}=0.1, \\lambda=0.01, \\mu_{j}=0$, $\\sigma_{j}=0.05$ ). The sample path was generated using Euler's method, with a step size $h=1$, further subdivided into ten equal segments for finer approximation.\n\n![table_2](table_2)\n\nTable 3: Comparison between derived conditional moments and sample moments for the SV model with contemporaneous jumps in the return and the volatility. The comparison is based on $4,000,000$ i.i.d. samples of the SVCJ model, under the parameter settings ( $v_{0}=0.007569$, $\\mu=0.0789, k=3.46, \\theta=0.008, \\sigma=0.14, \\rho=-0.82, \\lambda=0.47, \\mu_{\\nu}=0.05, \\rho_{J}=-0.38$, $\\mu_{s}=-0.0865, \\sigma_{s}=0.0001$ ). The samples are generated using Euler's method, with $h=1$, subdivided into ten equal segments for fine approximation.\n\nAll of the tables corroborate the effectiveness of our procedures, demonstrating a high degree of concordance between the theoretical derivations and their empirical estimates. These findings are particularly encouraging considering the stochastic nature of the model and the approximations employed in the simulation process.",
      "tables": {
        "table_0": "| Moment | Derived moment | Sample moment | Difference | Difference (\\%) |\n| :-- | :--: | :--: | :--: | :--: |\n| $\\mathrm{E}\\left[y_{n}\\right]$ | 0.0000 | 0.0002 | 0.0002 | - |\n| $\\mathrm{E}\\left[y_{n}^{2}\\right]$ | 0.2615 | 0.2606 | 0.0009 | $0 \\%$ |\n| $\\mathrm{E}\\left[y_{n}^{3}\\right]$ | -0.0449 | -0.0425 | 0.0024 | $5 \\%$ |\n| $\\mathrm{E}\\left[y_{n}^{4}\\right]$ | 0.2508 | 0.2491 | 0.0016 | $1 \\%$ |\n| $\\mathrm{E}\\left[y_{n}^{5}\\right]$ | -0.1412 | -0.1350 | 0.0062 | $4 \\%$ |",
        "table_1": "| Covariance | Derived Covariance | Sample Covariance | Difference | Difference (\\%) |\n| :-- | :--: | :--: | :--: | :--: |\n| $\\operatorname{cov}\\left(y_{n}, y_{n+1}\\right)$ | 0.0108 | 0.0108 | 0.0000 | $0 \\%$ |\n| $\\operatorname{cov}\\left(y_{n}^{2}, y_{n+1}\\right)$ | -0.0069 | -0.0069 | 0.0000 | $0 \\%$ |\n| $\\operatorname{cov}\\left(y_{n}, y_{n+1}^{2}\\right)$ | -0.0228 | -0.0230 | 0.0002 | $1 \\%$ |\n| $\\operatorname{cov}\\left(y_{n}^{3}, y_{n+1}\\right)$ | 0.0112 | 0.0111 | 0.0001 | $1 \\%$ |\n| $\\operatorname{cov}\\left(y_{n}^{2}, y_{n+1}^{2}\\right)$ | 0.0150 | 0.0150 | 0.0000 | $0 \\%$ |\n| $\\operatorname{cov}\\left(y_{n}, y_{n+1}^{3}\\right)$ | 0.0140 | 0.0138 | 0.0002 | $1 \\%$ |\n| $\\operatorname{cov}\\left(y_{n}^{4}, y_{n+1}\\right)$ | -0.0155 | -0.0151 | 0.0004 | $2 \\%$ |\n| $\\operatorname{cov}\\left(y_{n}^{3}, y_{n+1}^{2}\\right)$ | -0.0243 | -0.0245 | 0.0002 | $1 \\%$ |\n| $\\operatorname{cov}\\left(y_{n}^{2}, y_{n+1}^{3}\\right)$ | -0.0108 | -0.0108 | 0.0000 | $0 \\%$ |\n| $\\operatorname{cov}\\left(y_{n}, y_{n+1}^{4}\\right)$ | -0.0456 | -0.0456 | 0.0000 | $0 \\%$ |",
        "table_2": "| Moment | Derived moment | Sample moment | Difference | Difference (\\%) |\n| :-- | :--: | :--: | :--: | :--: |\n| $\\mathrm{E}\\left[y_{n} \\mid v_{0}\\right]$ | 0.0229 | 0.0228 | 0.0001 | $1 \\%$ |\n| $\\mathrm{E}\\left[y_{n}^{2} \\mid v_{0}\\right]$ | 0.0196 | 0.0200 | 0.0003 | $2 \\%$ |\n| $\\mathrm{E}\\left[y_{n}^{3} \\mid v_{0}\\right]$ | -0.0024 | -0.0025 | 0.0001 | $5 \\%$ |\n| $\\mathrm{E}\\left[y_{n}^{4} \\mid v_{0}\\right]$ | 0.0022 | 0.0023 | 0.0001 | $5 \\%$ |\n| $\\mathrm{E}\\left[y_{n}^{5} \\mid v_{0}\\right]$ | -0.0011 | -0.0012 | 0.0001 | $7 \\%$ |"
      },
      "images": {}
    },
    {
      "section_id": 8,
      "text": "# 5. Conclusion \n\nIn this work, we have developed and introduced ajdmom, a comprehensive Python package designed for the derivation of moment formulae specifically tailored to the Heston SV model and its AJD extensions.\nOur approach commenced with an exposition of the AJD models, highlighting the Heston SV model as a prominent example. We then present a recursive equation framework capable of determining moments of any order within these models. Leveraging insights from this theoretical foundation, we crafted a novel dictionary-based data structure to effectively represent the moments of the It\u00f4 processes under consideration.\nThe paper proceeded to detail the implementation of a procedure within ajdmom to automate the derivation of moments for AJD models. We discussed the architectural framework of the package, emphasizing its robustness and versatility.\nPractical applications and the utility of ajdmom were demonstrated through illustrative examples, and experimental validation confirmed the accuracy of our methodology. The results not only verified the correctness of our proposed solutions but also underscored the practical implications for users involved in financial modelling and analysis.\nLooking ahead, the methodologies encapsulated within ajdmom hold the promise for extension to a broader class of AJD models, including potentially non-affine jump diffusion processes. Such ventures present intriguing avenues for future research and development in this domain.\nIn summary, ajdmom stands as a significant contribution to the computational finance field, offering a powerful tool for researchers and practitioners alike, and paving the way for continued innovation in the modelling of complex financial instruments.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 9,
      "text": "## Acknowledgement\n\nThis work is supported in part by the National Nature Science Foundation of China (NSFC) under grants 72033003, 72350710219 and 72342006.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 10,
      "text": "## References\n\nBates DS (1996). \"Jumps and Stochastic Volatility: Exchange Rate Processes Implicit in Deutsche Mark Options.\" The Review of Financial Studies, 9(1), 69-107.\n\nBezanson J, Edelman A, Karpinski S, Shah VB (2017). \"Julia: A fresh approach to numerical computing.\" SIAM review, 59(1), 65-98. URL https://doi.org/10.1137/141000671.\n\nBlack F, Scholes M (1973). \"The Pricing of Options and Corporate Liabilities.\" Journal of political economy, 81(3), 637-654.\n\nBollerslev T, Zhou H (2002). \"Estimating Stochastic Volatility Diffusion Using Conditional Moments of Integrated Volatility.\" Journal of Econometrics, 109(1), 33-65.\n\nBroadie M, Chernov M, Johannes M (2007). \"Model Specification and Risk Premia: Evidence from Futures Options.\" The Journal of Finance, 62(3), 1453-1490.\n\nBroadie M, Kaya \u00d6 (2006). \"Exact Simulation of Stochastic Volatility and Other Affine Jump Diffusion Processes.\" Operations Research, 54(2), 217-231.\n\nCanyakmaz C, \u00d6zekici S, Karaesmen F (2019). \"An Inventory Model Where Customer Demand is Dependent on a Stochastic Price Process.\" International Journal of Production Economics, 212, 139-152.\n\nChacko G, Viceira LM (2003). \"Spectral GMM Estimation of Continuous-Time Processes.\" Journal of Econometrics, 116(1), 259-292. ISSN 0304-4076.\n\nChoi J, Kwok YK (2024). \"Simulation Schemes for the Heston Model with Poisson Conditioning.\" European Journal of Operational Research, 314(1), 363-376.\n\nCox JC, Ingersoll Jr JE, Ross SA (1985). \"A Theory of the Term Structure of Interest Rates.\" Econometrica, 53, 385-407.\n\nCuchiero C, Keller-Ressel M, Teichmann J (2012). \"Polynomial processes and their applications to mathematical finance.\" Finance and Stochastics, 16, 711-740.\n\nDassios A, Zhao H (2017). \"Efficient Simulation of Clustering Jumps with CIR Intensity.\" Operations Research, 65(6), 1494-1515.\n\nDuffie D, Pan J, Singleton K (2000). \"Transform Analysis and Asset Pricing for Affine JumpDiffusions.\" Econometrica, 68(6), 1343-1376.\n\nEraker B, Johannes M, Polson N (2003). \"The Impact of Jumps in Volatility and Returns.\" The Journal of Finance, 58(3), 1269-1300.\n\nGiesecke K, Kakavand H, Mousavi M (2011). \"Exact Simulation of Point Processes with Stochastic Intensities.\" Operations research, 59(5), 1233-1245.\n\nGorj\u00e3o LR, Witthaut D, Lind PG (2023). \"jumpdiff: A Python Library for Statistical Inference of Jump-Diffusion Processes in Observational or Experimental Data Sets.\" Journal of Statistical Software, 105, 1-22.\n\nGorj\u00e3o LR, Meirinhos F (2019). \"kramersmoyal: Kramers-Moyal Coefficients for Stochastic Processes.\" Journal of Open Source Software, 4(44), 1693. doi:10.21105/joss.01693. URL https://doi.org/10.21105/joss.01693.\n\nGosain A (2020). \"DerivativesPricing: Derivatives Pricing and Optimisation.\" URL https://github.com/AnjishtGosain/DerivativesPricing.\n\nHeston SL (1993). \"A Closed-Form Solution for Options with Stochastic Volatility with Applications to Bond and Currency Options.\" The Review of Financial Studies, 6(2), $327-343$.\n\nJiang GJ, Knight JL (2002). \"Estimation of Continuous-Time Processes via the Empirical Characteristic Function.\" Journal of Business 8 Economic Statistics, 20(2), 198-212.\n\nJustin Lars K, Duy N, Zhenyu C, Zhimin Z, Shijie D, Jean-Philippe A (2023). \"PROJ_Option_Pricing_Matlab: Option Pricing PROJ Method (Exotic/Vanilla Options).\" URL https://github.com/jkirkby3/PROJ_Option_Pricing_Matlab.\n\nKyriakou I, Brignone R, Fusai G (2024). \"Unified Moment-Based Modeling of Integrated Stochastic Processes.\" Operations Research, 72(4), 1630-1653.\n\nMeurer A, Smith CP, Paprocki M, \u010cert\u00edk O, Kirpichev SB, Rocklin M, Kumar A, Ivanov S, Moore JK, Singh S, Rathnayake T, Vig S, Granger BE, Muller RP, Bonazzi F, Gupta H, Vats S, Johansson F, Pedregosa F, Curry MJ, Terrel AR, Rou\u010dka v, Saboo A, Fernando I, Kulal S, Cimrman R, Scopatz A (2017). \"SymPy: Symbolic Computing in Python.\" PeerJ Computer Science, 3, e103.\n\nOkada M (2020). \"Jdmbs: An R Package for Monte Carlo Option Pricing Algorithms for Jump Diffusion Models with Correlational Companies.\" URL https://github.com/jirotubuyaki/Jdmbs.\n\nOverbeck L, Ryd\u00e9n T (1997). \"Estimation in the Cox-Ingersoll-Ross Model.\" Econometric Theory, 13(3), 430-461. doi:10.1017/S0266466600005880.\n\nR Core Team (2024). R: A Language and Environment for Statistical Computing. R Foundation for Statistical Computing, Vienna, Austria. URL https://www.R-project.org/.\n\nRackauckas C, Nie Q (2017). \"DifferentialEquations.jl - A Performant and Feature-Rich Ecosystem for Solving Differential Equations in Julia.\" The Journal of Open Research Software, 5(1). doi:10.5334/jors. 151.\n\nRinn P, Lind PG, W\u00e4chter M, Peinke J (2016). \"The Langevin Approach: An R Package for Modeling Markov Processes.\" Journal of Open Research Software, 4.\n\nRydin Gorj\u00e3o L, Witthaut D, Lehnertz K, Lind PG (2021). \"Arbitrary-Order Finite-Time Corrections for the Kramers-Moyal Operator.\" Entropy, 23(5), 517.\n\nSingleton KJ (2001). \"Estimation of Affine Asset Pricing Models Using the Empirical Characteristic Function.\" Journal of Econometrics, 102(1), 111-141.\n\nSphinx Development Team (2020). \"Sphinx 4.0.0+ Documentation.\" URL https://www.sphinx-doc.org/en/master/.\n\nStroustrup B (2013). The $C++$ programming language. Pearson Education.\nThe MathWorks Inc (2022). \"MATLAB version: 9.13.0 (R2022b).\" URL https://www.mathworks.com.\n\nVan Rossum G, Drake FL (2009). Python 3 Reference Manual. CreateSpace, Scotts Valley, CA. ISBN 1441412697.\n\nWeinberg J, Brown LD, Stroud JR (2007). \"Bayesian Forecasting of an Inhomogeneous Poisson Process with Applications to Call Center Data.\" Journal of the American Statistical Association, 102(480), 1185-1198.\n\nWolfram Research, Inc (2024). \"Mathematica, Version 14.1.\" Champaign, IL, 2024, URL https://www.wolfram.com/mathematica.\n\nWu Y, Hu J, Yang X (2022). \"Moment Estimators for Parameters of L\u00e9vy-driven Ornstein-Uhlenbeck Processes.\" Journal of Time Series Analysis, 43(4), 610-639. doi:https://doi.org/10.1111/jtsa.12630.\n\nWu Y, Hu J, Zhang X (2019). \"Moment Estimators for the Parameters of Ornstein-Uhlenbeck Processes Driven by Compound Poisson Processes.\" Discrete Event Dynamic Systems, 29(1), 57-77.\n\nWu YF, Hu JQ (2025a). \"Density Approximation of Affine Jump Diffusions via Closed-Form Moment Matching.\" pp. 1-27. Working paper.\n\nWu YF, Hu JQ (2025b). \"Method of moments estimation for the superposition of square-root diffusions.\" Probability in the Engineering and Informational Sciences, 39(1), 23-43.\n\nWu YF, Yang X, Hu JQ (2024). \"Method of Moments Estimation for Affine Stochastic Volatility Models.\" 2408.09185, URL https://arxiv.org/abs/2408.09185.\n\nYang X, Wu Y, Zheng Z, Hu JQ (2021). \"Method of Moments Estimation for L\u00e9vy-Driven Ornstein-Uhlenbeck Stochastic Volatility Models.\" Probability in the Engineering and Informational Sciences, 35(4), 975-1004.\n\nZagatti GA, Isaacson SA, Rackauckas C, Ilin V, Ng S, Bressan S (2024). \"Extending JumpProcesses.jl for fast point process simulation with time-varying intensities.\" Proceedings of the JuliaCon Conferences, 6(58), 133. doi:10.21105/jcon.00133. URL https://doi.org/10.21105/jcon.00133.\n\nZhang X, Blanchet J, Giesecke K, Glynn PW (2015). \"Affine Point Processes: Approximation and Efficient Simulation.\" Mathematics of Operations Research, 40(4), 797-819.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 11,
      "text": "# A. Recursive equation for the product moments \n\nThe conditional product moments of It\u00f4 processes $I E_{n-1, t}^{m_{1}} I_{n-1, t}^{m_{2}} I_{n-1, t}^{* m_{3}}$, with condition on $v_{n-1}$, can be derived in a recursive way as follows:\n\n$$\n\\begin{aligned}\n& \\mathrm{E}\\left[I I E_{n-1, t}^{m_{1}} I_{n-1, t}^{m_{2}} I_{n-1, t}^{* m_{3}}\\left[v_{n-1}\\right]\\right. \\\\\n& =\\int_{(n-1) h}^{t} e^{k s} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}-2} I_{n-1, s}^{* m_{2}} I_{n-1, s}^{* m_{3}}\\left[v_{n-1}\\right] d s \\cdot \\frac{m_{1}\\left(m_{1}-1\\right)}{2} e^{k(n-1) h} \\bar{v}_{n-1}\\right. \\\\\n& +\\int_{(n-1) h}^{t} e^{2 k s} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}-2} I_{n-1, s}^{* m_{2}} I_{n-1, s}^{* m_{3}}\\left[v_{n-1}\\right] d s \\cdot \\frac{m_{1}\\left(m_{1}-1\\right)}{2} \\theta\\right. \\\\\n& +\\int_{(n-1) h}^{t} e^{k s} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}-1} I_{n-1, s}^{m_{2}} I_{n-1, s}^{* m_{3}}\\left[v_{n-1}\\right] d s \\cdot \\frac{m_{1}\\left(m_{1}-1\\right)}{2} \\sigma_{v}\\right. \\\\\n& +\\int_{(n-1) h}^{t} e^{-k s} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}} I_{n-1, s}^{* m_{2}} I_{n-1, s}^{* m_{3}}\\left[v_{n-1}\\right] d s \\cdot \\frac{m_{2}\\left(m_{2}-1\\right)}{2} e^{k(n-1) h} \\bar{v}_{n-1}\\right. \\\\\n& +\\int_{(n-1) h}^{t} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}} I_{n-1, s}^{* m_{2}} I_{n-1, s}^{* m_{3}}\\left[v_{n-1}\\right] d s \\cdot \\frac{m_{2}\\left(m_{2}-1\\right)}{2} \\theta\\right. \\\\\n& +\\int_{(n-1) h}^{t} e^{-k s} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}+1} I_{n-1, s}^{m_{2}-2} I_{n-1, s}^{* m_{3}}\\left[v_{n-1}\\right] d s \\cdot \\frac{m_{2}\\left(m_{2}-1\\right)}{2} \\sigma_{v}\\right. \\\\\n& +\\int_{(n-1) h}^{t} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}-1} I_{n-1, s}^{m_{2}-1} I_{n-1, s}^{* m_{3}}\\left[v_{n-1}\\right] d s \\cdot m_{1} m_{2} e^{k(n-1) h} \\bar{v}_{n-1}\\right. \\\\\n& +\\int_{(n-1) h}^{t} e^{k s} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}-1} I_{n-1, s}^{* m_{2}} I_{n-1, s}^{* m_{3}}\\left[v_{n-1}\\right] d s \\cdot m_{1} m_{2} \\theta\\right. \\\\\n& +\\int_{(n-1) h}^{t} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}} I_{n-1, s}^{m_{2}-1} I_{n-1, s}^{* m_{3}}\\left[v_{n-1}\\right] d s \\cdot m_{1} m_{2} \\sigma_{v}\\right. \\\\\n& +\\int_{(n-1) h}^{t} e^{-k s} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}} I_{n-1, s}^{* m_{2}} I_{n-1, s}^{* m_{3}-2}\\left[v_{n-1}\\right] d s \\cdot m_{3} e^{k(n-1) h} \\bar{v}_{n-1}\\right. \\\\\n& +\\int_{(n-1) h}^{t} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}} I_{n-1, s}^{* m_{2}-2}\\left[v_{n-1}\\right] d s \\cdot m_{3} \\theta\\right. \\\\\n& +\\int_{(n-1) h}^{t} e^{-k s} \\mathrm{E}\\left[I E_{n-1, s}^{m_{1}+1} I_{n-1, s}^{* m_{2}-2}\\left[v_{n-1}\\right] d s \\cdot m_{3} \\sigma_{v} .\\right.\n\\end{aligned}\n$$",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 12,
      "text": "## Affiliation:\n\nYan-Feng Wu, Jian-Qiang Hu\nDepartment of Management Science\nFudan University\nNo. 670, Guoshun Rd.\n200433 Shanghai, China\nE-mail: wuyf@fudan.edu.cn, hujq@fudan.edu.cn\nURL: https://github.com/xmlongan",
      "tables": {},
      "images": {}
    }
  ],
  "id": "2411.06484v2",
  "authors": [
    "Yan-Feng Wu",
    "Jian-Qiang Hu"
  ],
  "categories": [
    "q-fin.MF"
  ],
  "abstract": "We introduce ajdmom, a Python package designed for automatically deriving\nmoment formulae for the well-established affine jump diffusion processes with\nstate-independent jump intensities. ajdmom can produce explicit closed-form\nexpressions for conditional and unconditional moments of any order,\nsignificantly enhancing the usability of these models. Additionally, ajdmom can\ncompute partial derivatives of these moments with respect to the model\nparameters, offering a valuable tool for sensitivity analysis. The package's\nmodular architecture makes it easy for adaptation and extension by researchers.\najdmom is open-source and readily available for installation from GitHub or the\nPython package index (PyPI).",
  "updated": "2025-04-07T02:27:58Z",
  "published": "2024-11-10T14:55:10Z"
}