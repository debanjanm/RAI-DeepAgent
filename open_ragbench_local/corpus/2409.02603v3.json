{
  "title": "Formalising Inductive and Coinductive Containers",
  "sections": [
    {
      "section_id": 0,
      "text": "#### Abstract\n\nContainers capture the concept of strictly positive data types in programming. The original development of containers is done in the internal language of locally cartesian closed categories (LCCCs) with disjoint coproducts and W-types, and uniqueness of identity proofs (UIP) is implicitly assumed throughout. Although it is claimed that these developments can also be interpreted in extensional Martin-L\u00f6f type theory, this interpretation is not made explicit. In this paper, we present a formalisation of the results that 'containers preserve least and greatest fixed points' in Cubical Agda, thereby giving a formulation in intensional type theory. Our proofs do not make use of UIP and thereby generalise the original results from talking about container functors on Set to container functors on the wild category of types. Our main incentive for using Cubical Agda is that its path type restores the equivalence between bisimulation and coinductive equality. Thus, besides developing container theory in a more general setting, we also demonstrate the usefulness of Cubical Agda's path type to coinductive proofs.\n\n\n2012 ACM Subject Classification Theory of computation $\\rightarrow$ Type theory\nKeywords and phrases type theory; container; initial algebra; terminal coalgebra; Cubical Agda\nFunding Axel Ljungstr\u00f6m: This author is supported by the Swedish Research Council (Vetenskapsr\u00e5det) under Grant No. 2019-04545.\n\nAcknowledgements The authors would like to thank Tom de Jong, Nicolai Kraus, Anders M\u00f6rtberg, and Chris Purdy for fruitful discussions on this work, as well as the Agda Zulip and Discord communities for useful inputs and valuable comments.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 1,
      "text": "## 1 Introduction\n\nAn inductive type is a type given by a list of constructors, each specifying a way to form an element of the type. Defining types inductively is a central idea in Martin-L\u00f6f type theory (MLTT) [19], with examples including the natural numbers, lists, and finite sets. In order for our inductive definitions to 'make sense', meaning their induction principle can be properly expressed without leading to inconsistencies (see [24, Section 5.6]),\n\n- we need to impose conditions on the general form of a constructor. The condition we would like to impose on our inductive definitions is that they are strictly positive. Dual to inductive types is the notion of a coinductive type, i.e. a type defined by a list of destructors. While inductive types are described by the different ways we can construct them, coinductive types are described by the ways we can break them apart. Coinductive types are typically infinite structures, and examples include the conatural numbers and streams. As is the case for inductive definitions, coinductive definitions also ought to be strictly positive in order to avoid inconsistencies. ${ }^{1}$ To ensure our type systems only admit such types, we seek a semantic description of strict positivity - this is precisely what containers provide.\n\n[^0]\n[^0]:    ${ }^{1}$ To be precise, in both cases we mean that the type's signature functor should be strictly positive.\n\nThe theory of containers [1-4] (also referred to as polynomial functors in the literature [14]) was developed to capture the concept of strictly positive data types in programming, and has been very useful in providing semantics for inductive types and inductive families. The original development of containers uses a categorical language, where containers are presented as constructions in the internal language of locally cartesian closed categories (LCCCs) with disjoint coproducts and W-types (so-called Martin-L\u00f6f categories), and a standard settheoretic metatheory is used. Abbott et al. claim in [3, Section 2.1] that these developments can also be interpreted as constructions in extensional MLTT. While Seely, Hofmann, and others show that this translation can be done in principle [15,22], the construction in type theory is not actually carried out.\n\nIn this paper, we remedy this by providing a formalisation of existing results by Abbott et al. [3]. While the aforementioned paper implicitly assumes uniqueness of identity proofs (UIP) throughout, we do not assume this principle for any of the types involved in our formalisation. More precisely, the main contributions of this paper are:\n\n- the formalisation of the results stating 'container functors preserve initial algebras' and 'container functors preserve terminal coalgebras' (Theorems 13 and 14), and\n- the generalisation of these results by proving them not in the category of sets, but in the wild category of types.\nThe formalisation is written in Cubical Agda [26], an extension of the Agda proof assistant which implements (a cubical [11] flavour of) homotopy type theory (HoTT). Although a lot of the interest around Cubical Agda is arguably due to its native support for the univalence axiom, our main motivation for using it is due to its treatment of equality as a path type, which restores the symmetry between inductive and coinductive reasoning in Agda. In intensional type theory, and therefore in vanilla Agda, working with inductive types is facilitated by using structural recursion and pattern matching. For coinductive types, although we do have copattern matching and some guarded corecursion, we cannot get very far when working in this setting. In particular, many equalities on coinductive types are impossible to prove in much the same way that equalities on function types cannot be proved: this requires some form of extensionality. Fortunately, Cubical Agda makes function extensionality provable, and many of the equalities on coinductive types that were previously impossible in vanilla Agda also become provable. With our formalisation, we contribute to the agda/cubical library [23], and hope to demonstrate that the practical developments brought to MLTT by cubical type theory extend beyond just computational univalence.\n\nOur formalisation is available at https://github.com/stefaniatadama/formalisin g-inductive-coinductive-containers in a fork of the agda/cubical library. To access the code corresponding to specific results in the paper, the reader can consult the README file at the link above, or simply click the cog symbol $\\boldsymbol{\\otimes}$ next to the respective result. We have taken some liberties concerning the typesetting in this paper and, although it should still be easy to follow, the syntax of the formalisation may differ slightly from the paper.\n\nThe paper is organised as follows. In Section 2, we give a brief overview of Agda and Cubical Agda, W- and M-types, and some container theory. In Section 3 we motivate and develop the constructions to be used in the main proofs, which are then given in Section 4. Lastly, we conclude in Section 5 with some related work and future avenues of study.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 2,
      "text": "# ? Background \n\nIn this section, we present some background material that aids in understanding the rest of the paper. We start by giving an overview of Agda and Cubical Agda concepts that will be used throughout the paper. We then review W- and M-types, as well as the theory of containers adapted to wild categories.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 3,
      "text": "# 2.1 Agda and Cubical Agda \n\nAgda is a dependently typed functional programming language and proof assistant. It supports inductive data types, e.g. the unit type, the empty type, the natural numbers\ndata T : Type where\ntt : T\ndata $\\perp$ : Type where\ndata $\\mathbb{N}$ : Type where\nzero : $\\mathbb{N}$\n$\\operatorname{suc}: \\mathbb{N} \\rightarrow \\mathbb{N}$\nand record types, e.g. $\\Sigma$-types and (coinductive) streams.\n\n```\nrecord \\(\\Sigma(A:\\) Type \\()\\) ( \\(B: A \\rightarrow\\) Type \\():\\) Type where\n    constructor\n    field\n        fst : \\(A\\)\n        snd : \\(B\\) fst\n```\n\nrecord Stream ( $A$ : Type) : Type where\ncoinductive\nfield\nhd : $A$\ntl : Stream $A$\n\nAgda supports pattern matching on inductive data types, and dually supports copattern matching on record and coinductive data types, as shown below.\n\n![table_0](table_0)\n\nWe note that Agda uses the syntax $(a: A) \\rightarrow B a$ rather than $\\Pi_{a: A} B a$; we will use both notations interchangeably throughout the paper. We also remark that the syntax $\\{a: A\\} \\rightarrow B a$ is available in Agda and denotes the same construction but with $a$ an implicit argument.\n\nCubical Agda [26] extends Agda with primitives from cubical type theory [11,12]. While the original motivation behind this extension was arguably to allow for native support for Voevodsky's univalence axiom [27] and higher inductive types [18], we are primarily interested in Cubical Agda's representation of equality. The equality type in Cubical Agda, also called the path type, restores the equivalence between bisimilarity and equality for coinductive types. In order to explain how, let us briefly introduce some of the elementary machinery of Cubical Agda.\n\nThe main novelty of Cubical Agda is the addition of an interval (pre-)type I. This type has two terms $i 0, i 1$ : I denoting the endpoints of the interval. It comes equipped with operations, such as a 'reversal' operation $\\sim: \\mathrm{I} \\rightarrow \\mathrm{I}$, which allow us to internalise the usual homotopical notion of a path and take that as our definition of equality. Indeed, an equality $p$ between two points $x, y: A$, denoted $p: x \\equiv y$, is a path in $A$ between $x$ and $y$, i.e. a function $p: \\mathrm{I} \\rightarrow A$ such that $p i 0$ is definitionally equal to $x$ and $p i 1$ is definitionally equal to $y$. To showcase some elementary constructions of paths in Cubical Agda, consider e.g. the constructions/proofs of reflexivity and symmetry.\n\n$$\n\\begin{array}{ll}\n\\text { refl : }\\{x: A\\} \\rightarrow x \\equiv x & \\sim^{-1}: x \\equiv y \\rightarrow y \\equiv x \\\\\n\\text { refl }\\{x=x\\} i=x & \\left(p^{-1}\\right) i=p(\\sim i)\n\\end{array}\n$$\n\nAs in plain MLTT, there is also a notion of dependent path in Cubical Agda expressed by the primitive type called PathP. This type generalises the path type by considering dependent functions $(i: \\mathrm{I}) \\rightarrow A i$ instead of only non-dependent ones $\\mathrm{I} \\rightarrow A$. In this paper, we adopt an informal approach and write $a \\equiv b$ for the statement that ' $a: A$ is equal to $b: B$ modulo\n\nsome path of types $p: A \\equiv B$ '. The definition of the path of types will often be omitted from the main text, as it almost always can be automatically inferred from context. However, it will be included in a separate text box for the interested reader, although it can generally be ignored by the reader focussing on the broader picture.\n\nOn a related note, we also mention here that the Cubical Agda primitives allow us to define transport : $A \\equiv B \\rightarrow A \\rightarrow B$. As usual we have that, for any $p: A \\equiv B$, the type of dependent paths $a \\equiv b$ modulo $p$ is equivalent to the type transport $p a \\equiv b$.\n\nOne of the key advantages of Cubical Agda's treatment of equality is that it renders function extensionality a triviality:\n\n$$\n\\begin{aligned}\n& \\text { funExt : }((x: A) \\rightarrow f x \\equiv g x) \\rightarrow f \\equiv g \\\\\n& \\text { funExt } p i x=p x i\n\\end{aligned}\n$$\n\nA consequence of this is that we can use the types $f \\equiv g$ and $(x: A) \\rightarrow f x \\equiv g x$ interchangeably without having to worry about introducing any bureaucracy when moving from one to the other; in Cubical Agda, equality of functions is by definition pointwise equality. In a similar way, and especially important for us, the equality type of a coinductive type is bisimulation modulo copattern matching. In particular, id below can be shown to be an equivalence [5]. To the best of our knowledge, this feature is unique to Cubical Agda.\n\n```\nrecord \\(\\qquad\\) (xs ys : Stream \\(A\\) ) : Set where\n    coinductive\n    field\n        \\(\\mathrm{hd} \\equiv: \\mathrm{hd} x s \\equiv \\mathrm{hd} y s\\)\n        \\(\\mathrm{tl} \\approx: \\mathrm{tl} x s \\approx \\mathrm{tl} y s\\)\n```\n\nid : (xs ys : Stream $A) \\rightarrow x s \\approx y s \\rightarrow x s \\equiv y s$\nhd (id $x s y s p i)=\\mathrm{hd} \\equiv p i$\ntl (id $x s y s p i)=\\operatorname{id}(\\mathrm{tl} x s)(\\mathrm{tl} y s)(\\mathrm{tl} \\approx p) i$",
      "tables": {
        "table_0": "| isEven : $\\mathbb{N} \\rightarrow$ Type | from : $\\mathbb{N} \\rightarrow$ Stream $\\mathbb{N}$ |\n| :-- | :-- |\n| isEven zero $=\\mathrm{T}$ | hd (from $n$ ) $=n$ |\n| isEven (suc zero) \\(=\\perp$ | $\\mathrm{tl}($ from \\(n\\) ) = from (suc \\(n\\) ) |\n| isEven (suc (suc \\(n\\) )) \\(=\\) isEven \\(n$ |  |"
      },
      "images": {}
    },
    {
      "section_id": 4,
      "text": "# 2.2 The W-type and the M-type \n\nThe type W, due to Martin-L\u00f6f [20,21], is the type of well-founded, labelled trees. A tree of type W can be infinitely branching, but every path in the tree is finite. W takes two parameters $S$ : Type and $P: S \\rightarrow$ Type. We think of $S$ as the type of shapes of the tree, and for a given shape $s: S$, the tree has $(P s)$-many positions. The key property of W is that it is the universal type for strictly positive inductive types, i.e. any strictly positive inductive type can be expressed using W.\n\n$$\n\\begin{aligned}\n& \\text { data W }(S \\text { : Type) }(P: S \\rightarrow \\text { Type }) \\text { : Type where } \\\\\n& \\text { sup-W }:(s: S) \\rightarrow(P s \\rightarrow \\mathrm{~W} S P) \\rightarrow \\mathrm{W} S P\n\\end{aligned}\n$$\n\n- Example 1. We encode the type of natural numbers $\\mathbb{N}$ by defining $S$ and $P$ as below (where $A \\uplus B$ is the sum type of $A$ and $B$ with constructors inl and inr).\n\n$$\n\\begin{aligned}\nS & =\\top \\uplus \\top \\\\\n\\mathrm{P}(\\text { inl } \\ldots) & =\\perp \\\\\n\\mathrm{P}(\\text { inr } \\ldots) & =\\top\n\\end{aligned}\n$$\n\nS encodes the possible constructors we can choose (inl is for zero, inr is for succ), and P encodes the number of subtrees (or recursive arguments) each choice of $S$ has. Thus W S P encodes $\\mathbb{N}$. For example, zero is represented by the tree on the left below, succ zero by the tree on the right, and so on.\n![img-0.jpeg](img-0.jpeg)\n\nThe type M, first studied by Abbott et al. [3] and van den Berg and De Marchi [25], is the type of non-well-founded, labelled trees. A tree of type M can have both finite and infinite paths. M takes two parameters $S:$ Type and $P: S \\rightarrow$ Type, and we think of them similarly as for W. Dually to W, M is the universal type for strictly positive coinductive types.\n\n```\nrecord M ( }S\\mathrm{ : Type) ( }P\\mathrm{ : }S\\mathrm{ \\rightarrow Type): Type where\n    coinductive\n    field\n        shape : }S\n        pos : P shape }->\\mathrm{M}S\n```\n\n- Example 2. If we define $S$ and $P$ as in Example 1, then $M S P$ is an encoding of the conatural numbers $\\mathrm{N} \\infty$.",
      "tables": {},
      "images": {
        "img-0.jpeg": "data:image/jpeg;base64,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"
      }
    },
    {
      "section_id": 5,
      "text": "# record $\\mathrm{N} \\infty$ : Type where <br> coinductive \n\nfield\npred $\\infty$ : Maybe $\\mathrm{N} \\infty$\nApart from having all the natural numbers as its elements, $\\mathrm{N} \\infty$ also has an 'infinite number' whose predecessor is itself. This is represented by the infinite tree shown below. This M-tree clearly has an infinite path.\n\n$$\n\\operatorname{inr} \\operatorname{tt} \\square\n$$\n\nWe will see in Section 4 that it is useful to have an explicit account of the coinduction principle of $M$, which states that any two $m_{0}, m_{1}: M S Q$ that can be related by a bisimulation are equal. In Cubical Agda, we can define the type of bisimulations on M as M-R below. For a relation $R$ to be a bisimulation on $M$, it has to relate 2 elements of $M$ whenever their shapes are equal and their positions are related by $R$.\n\n```\nrecord M-R ( }R\\mathrm{ : M S Q -> M S Q -> Type) ( }m_{0} m_{1}: \\mathrm{M} S Q\\mathrm{ : Type where\n    field\n    s-eq : shape m0 \\equiv shape m\n    p-eq : ( }q_{0}: Q\\mathrm{ (shape m0)) ( }q_{1}: Q\\mathrm{ (shape m}\n        (q-eq: q0 \\equiv q1) -> R (pos m0 q0) (pos m\n```\n\nt. Above, $q$-eq is a dependent path over the path of types $(\\lambda i \\rightarrow Q($ s-eq $i))$\n\nWe can then prove the coinduction principle using interval abstraction and copattern matching.\n\n$$\n\\begin{aligned}\n& \\text { MCoind : }(R: \\mathrm{M} S Q \\rightarrow \\mathrm{M} S Q \\rightarrow \\text { Type }) \\\\\n& \\quad\\left(\\text { is-bisim : }\\left(m_{0} m_{1}: \\mathrm{M} S Q\\right) \\rightarrow R m_{0} m_{1} \\rightarrow \\mathrm{M}-\\mathrm{R} R m_{0} m_{1}\\right) \\\\\n& \\quad\\left\\{m_{0} m_{1}: \\mathrm{M} S Q\\right\\} \\rightarrow R m_{0} m_{1} \\rightarrow m_{0} \\equiv m_{1} \\\\\n& \\text { shape (MCoind } R \\text { is-bisim } r \\text { i) }=\\text { s-eq (is-bisim } r \\text { ) } i \\\\\n& \\text { pos (MCoind } R \\text { is-bisim }\\left\\{m_{0}=m_{0}\\right\\}\\left\\{m_{1}=m_{1}\\right\\} r \\text { i) } q= \\\\\n& \\quad \\text { MCoind } R \\text { is-bisim }\\left\\{m_{0}=\\text { pos } m_{0} q_{0}\\right\\}\\left\\{m_{1}=\\text { pos } m_{1} q_{1}\\right\\}\\left(\\text { p-eq (is-bisim } r\\right) q_{0} q_{1} q_{a}\\right) i\n\\end{aligned}\n$$\n\nAbove, $q_{0}, q_{1}$, and $q_{2}$ are all of the form transport... $q$. The constructions of these transports use some rather technical cube algebra; we omit the details and refer the interested reader to the formalisation.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 6,
      "text": "# 2.3 Containers \n\nThe container and container functor definitions in this section are adapted from [3] to the wild category of types Type. ${ }^{2}$ A wild category (or precoherent category in the sense of [10]) is a precategory as in [24], except the type of morphisms need not be an h-set (i.e. satisfies UIP). We observe that Type is in fact a 2-coherent category in the sense of [10], and moreover its triangle and pentagon coherators are trivial [10, Example 2.2.5]. The definitions of container functor algebras are standard category theory definitions also adapted to this setting, with the initial algebra definition being motivated by [16, Definition 5].\n\nDefinition 3 (\u0e51). A (unary) container is given by a pair of types $S:$ Type and $P: S \\rightarrow$ Type, which we write as $S \\triangleleft P$.\n\n- Example 4. For a fixed type $A$, the container representation of List $A$ : Type is given by $\\mathbb{N} \\triangleleft$ Fin. The shape of a list is a natural number $n$ representing its length, and there are $n$-many positions for data to be stored in a list, represented by Fin $n$, the type of finite sets of size $n$.\n\nIn practice, many data types are parameterised by one or more types. For example, List ( $A$ : Type) : Type (this time, $A$ is not fixed) and Vec ( $A$ : Type): $\\mathbb{N} \\rightarrow$ Type are both parameterised by the type $A$ of data to be stored in them. In order to be able to reason about such parameterised data types, as well as to construct fixed points of containers, we will need containers parameterised by some (potentially infinite) indexing type $I$. We call these $I$-ary containers.\n\nDefinition 5 (\u0e51). An I-ary container is given by a pair $S$ : Type and $\\mathbf{P}: I \\rightarrow S \\rightarrow$ Type, which we write as $S \\triangleleft \\mathbf{P}$.\n\nAbove, $\\mathbf{P}$ can be thought of as $I$ families of families over $S$. We will sometimes write $P_{0}, P_{1}, \\ldots$ instead of $\\mathbf{P} i_{0}, \\mathbf{P} i_{1}, \\ldots$ to enumerate the families over $S$.\n\nExample 6. We represent List ( $A$ : Type) : Type, where $A$ is parameterised and not fixed, as the binary container $\\mathrm{S} \\triangleleft\\left(\\mathrm{P}_{0}, \\mathrm{P}_{1}\\right)$ via the below definitions.\n\n![table_1](table_1)\n\nThe type of shapes $S$ reflects the fact that there are two ways to construct a list, i.e. as either nil or cons. $\\mathrm{P}_{0}$ defines positions for the parameter $A$ and $\\mathrm{P}_{1}$ defines positions for the recursive argument in either case of $S$.\n\nUnary containers are trivially $I$-ary containers when $I$ is the unit type, so henceforth in this section we will only consider $I$-ary containers.\n\nTo every container $S \\triangleleft \\mathbf{P}$, we associate a wild functor which maps a family of types $\\mathbf{X}: I \\rightarrow$ Type to a choice of shape $s: S$, and for every $i: I$ and position $\\mathbf{P} i s$ associated to $s$, a value of type $\\mathbf{X} i$ to be stored at that position.\n\n[^0]\n[^0]:    ${ }^{2}$ We note that we use Type to refer to both the wild category of types as well as Cubical Agda's universe of types.\n\nDefinition 7 ( $\\odot$ ). The container functor associated to an $I$-ary container $S \\triangleleft \\mathbf{P}$ is the wild functor $\\llbracket S \\triangleleft \\mathbf{P} \\rrbracket:(I \\rightarrow$ Type $) \\rightarrow$ Type with the following actions on objects and morphisms. ${ }^{3}$ - Given $\\mathbf{X}: I \\rightarrow$ Type, we define $\\llbracket S \\triangleleft \\mathbf{P} \\rrbracket \\mathbf{X}:=\\sum_{s: S}((i: I) \\rightarrow \\mathbf{P} i s \\rightarrow \\mathbf{X} i)$.\n\n- Given $\\mathbf{X}, \\mathbf{Y}: I \\rightarrow$ Type, and a morphism $f:(i: I) \\rightarrow \\mathbf{X} i \\rightarrow \\mathbf{Y} i$, we define\n\n$$\n\\llbracket S \\triangleleft \\mathbf{P} \\rrbracket f(s, g):=(s, f \\circ g)\n$$\n\nfor $s: S$ and $g:(i: I) \\rightarrow \\mathbf{P} i s \\rightarrow \\mathbf{X} i$.\nAs a special case of the above definition, given an $(I+1)$-ary container $F=S \\triangleleft \\mathbf{R}$, we will later need to write it in a way where we single out one component from it. We split $\\mathbf{R}$ into $\\mathbf{P}$ and $Q$ and write $F$ as having components $S:$ Type, $\\mathbf{P}: I \\rightarrow S \\rightarrow$ Type, $Q: S \\rightarrow$ Type, and use the notation $F=(S \\triangleleft \\mathbf{P}, Q)$. Given $\\mathbf{X}: I \\rightarrow$ Type and $Y:$ Type, then $S, \\mathbf{P}$, and $Q$ satisfy the below.\n\n$$\n\\llbracket S \\triangleleft \\mathbf{P}, Q \\rrbracket(\\mathbf{X}, Y)=\\sum_{s: S}((i: I) \\rightarrow \\mathbf{P} i s \\rightarrow \\mathbf{X} i) \\times(Q s \\rightarrow Y)\n$$\n\n- Example 8. Container functors allow us to view strictly positive types simply as memory locations in which data can be stored. The container functor associated to $\\mathbb{N} \\triangleleft$ Fin allows us to represent concrete lists. The list of Chars ['T', 'e', 'd'] is represented as $\\left(3,\\left(0 \\mapsto{ }^{\\prime} r^{\\prime} ; 1 \\mapsto{ }^{\\prime} e^{\\prime} ;\\right.\\right.$ $2 \\mapsto\\left.\\left.\\left.\\left\\langle d^{\\prime}\\right)\\right): \\sum_{n: \\mathbb{N}}(\\operatorname{Fin} n \\rightarrow \\operatorname{Char}\\right)$.\n\nThe two main results formalised in this paper concern the initial algebra and terminal coalgebra of a container functor. We define explicitly what we mean by these in the setting of wild categories and wild functors. We note that for (at least a na\u00efve definition of) a functor of wild categories $F: \\underline{\\mathbf{C}} \\rightarrow \\underline{\\mathbf{C}}$, it is not in general the case that $F$-algebras form a wild category. However, this is the case for container functors. This follows relatively directly from the properties of Type we mentioned at the start of the section.\n\n- Definition 9 ( $\\odot$ ). For a (unary) container functor $\\llbracket F \\rrbracket$ : Type $\\rightarrow$ Type, the wild category of $\\llbracket F \\rrbracket$-algebras, denoted $\\mathrm{Alg}_{\\llbracket F \\rrbracket}$, is defined as follows.\n- Objects are algebras: pairs $(X:$ Type, $\\alpha: \\llbracket F \\rrbracket X \\rightarrow X){ }^{4}$\n- A morphism of algebras $(X, \\alpha) \\rightarrow(Y, \\beta)$ is a function $f: X \\rightarrow Y$ such that the following square commutes.\n![img-1.jpeg](img-1.jpeg)\n- Definition 10 ( $\\odot$ ). The initial algebra of a (unary) container functor $\\llbracket F \\rrbracket$ : Type $\\rightarrow$ Type is an algebra $(I, \\iota)$ such that for every other algebra $(X, \\alpha), \\operatorname{Alg}_{\\llbracket F \\rrbracket}((I, \\iota),(X, \\alpha))$ is contractible.\n\nThe wild category of $\\llbracket F \\rrbracket$-coalgebras $\\operatorname{Coalg}_{\\llbracket F \\rrbracket}$ is dual to Definition 9, where the objects, coalgebras, are defined as pairs $(X:$ Type, $\\alpha: X \\rightarrow \\llbracket F \\rrbracket X)$. The terminal coalgebra is then an object $(T, \\tau)$ such that for every other coalgebra $(X, \\alpha), \\operatorname{Coalg}_{\\llbracket F \\rrbracket}((X, \\alpha),(T, \\tau))$ is contractible.\n\n[^0]\n[^0]:    ${ }^{3}$ Here, $I \\rightarrow$ Type refers to the wild category of $I$-indexed families of types.\n    ${ }^{4} X$ is sometimes called the carrier.",
      "tables": {
        "table_1": "| S : Type | $\\mathrm{P}_{0}: \\mathrm{S} \\rightarrow$ Type | $\\mathrm{P}_{1}: \\mathrm{S} \\rightarrow$ Type |\n| :-- | :-- | :-- |\n| $\\mathrm{S}:=\\mathrm{T} \\uplus \\mathrm{T}$ | $\\mathrm{P}_{0}(\\text { int } \\mathrm{tt}):=\\perp$ | $\\mathrm{P}_{1}(\\text { int } \\mathrm{tt}):=\\perp$ |\n|  | $\\mathrm{P}_{0}(\\text { intr } \\mathrm{tt}):=\\mathrm{T}$ | $\\mathrm{P}_{1}(\\text { intr } \\mathrm{tt}):=\\mathrm{T}$ |"
      },
      "images": {
        "img-1.jpeg": "data:image/jpeg;base64,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"
      }
    },
    {
      "section_id": 7,
      "text": "# 3 Setting up \n\nIn this section, we state precisely what it is that we want to prove and start attacking the problem. We construct a candidate initial algebra and terminal coalgebra for a general container functor, which in the following section we prove to be correct. We also discuss a generalised induction principle for the inductive family Pos of finite paths in a tree.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 8,
      "text": "### 3.1 Calculation of the initial algebra and terminal coalgebra\n\nGiven a container functor $\\llbracket F \\rrbracket:(I+1 \\rightarrow$ Type $) \\rightarrow$ Type, which we write as $F=(S \\triangleleft \\mathbf{P}, Q)$, we need to specify container functors\n\n$$\n\\begin{aligned}\n& \\llbracket A_{\\mu} \\triangleleft \\mathbf{B}_{\\mu} \\rrbracket:(I \\rightarrow \\text { Type }) \\rightarrow \\text { Type } \\\\\n& \\llbracket A_{\\nu} \\triangleleft \\mathbf{B}_{\\nu} \\rrbracket:(I \\rightarrow \\text { Type }) \\rightarrow \\text { Type }\n\\end{aligned}\n$$\n\nsuch that\n\n$$\n\\begin{aligned}\n& \\llbracket A_{\\mu} \\triangleleft \\mathbf{B}_{\\mu} \\rrbracket \\mathbf{X} \\cong \\mu Y . \\llbracket F \\rrbracket(\\mathbf{X}, Y) \\\\\n& \\llbracket A_{\\nu} \\triangleleft \\mathbf{B}_{\\nu} \\rrbracket \\mathbf{X} \\cong \\nu Y . \\llbracket F \\rrbracket(\\mathbf{X}, Y)\n\\end{aligned}\n$$\n\nAbove, and for the remainder of the paper, $\\cong$ is used to denote an equivalence of types. ${ }^{5}$ The symbols $\\mu$ and $\\nu$ denote partial operators taking a wild functor to the carrier of its initial algebra or terminal coalgebra respectively, if they exist. The notation $\\mu Y . \\llbracket F \\rrbracket(\\mathbf{X}, Y)$ is shorthand for the initial algebra of the wild functor $G$ defined by $G Y:=\\llbracket F \\rrbracket(\\mathbf{X}, Y)$, and similarly for $\\nu$.\n\nWe now illustrate how we calculate containers $\\left(A_{\\mu} \\triangleleft \\mathbf{B}_{\\mu}\\right)$ and $\\left(A_{\\nu} \\triangleleft \\mathbf{B}_{\\nu}\\right)$ in $I$ parameters to make the above isomorphisms hold. Calculating $A_{\\mu}$ and $A_{\\nu}$ is straightforward. If we set $\\mathbf{X}=\\top$ in the above, we get\n\n$$\n\\begin{aligned}\n& A_{\\mu} \\cong \\llbracket A_{\\mu} \\triangleleft \\mathbf{B}_{\\mu} \\rrbracket \\top \\cong \\mu Y . \\llbracket F \\rrbracket(\\top, Y) \\cong \\mu Y \\cdot \\sum_{s: S}(Q s \\rightarrow Y) \\cong \\mu Y . \\llbracket S \\triangleleft Q \\rrbracket Y \\cong \\mathrm{~W} S Q \\\\\n& A_{\\nu} \\cong \\llbracket A_{\\nu} \\triangleleft \\mathbf{B}_{\\nu} \\rrbracket \\top \\cong \\nu Y . \\llbracket F \\rrbracket(\\top, Y) \\cong \\nu Y \\cdot \\sum_{s: S}(Q s \\rightarrow Y) \\cong \\nu Y . \\llbracket S \\triangleleft Q \\rrbracket Y \\cong \\mathrm{M} S Q\n\\end{aligned}\n$$\n\nThe last step follows from the fact that the least (resp. greatest) fixed point of the container functor in one variable $\\llbracket S \\triangleleft Q \\rrbracket$ is W $S Q$ (M $S Q$ ), the W-type (M-type) with shapes $S$ and positions $Q$.\n\nCalculating $\\mathbf{B}_{\\mu}: I \\rightarrow \\mathrm{~W} S Q \\rightarrow$ Type and $\\mathbf{B}_{\\nu}: I \\rightarrow \\mathrm{M} S Q \\rightarrow$ Type is a bit more involved. Our reasoning below applies to both W $S Q$ and M $S Q$, so we consider any fixed point $\\phi$ of the container functor $\\llbracket S \\triangleleft Q \\rrbracket$ and construct $\\mathbf{B}: I \\rightarrow \\phi \\rightarrow$ Type. Being a fixed point of $\\llbracket S \\triangleleft Q \\rrbracket$ means that $\\phi$ consists of a carrier $\\mathrm{C}:$ Type together with an isomorphism, $\\chi: \\llbracket S \\triangleleft Q \\rrbracket \\subset \\cong \\mathrm{C}$.\n\n```\nrecord FixedPoint : Type \\(_{1}\\) where\n    field\n    C : Type\n    \\(\\chi:\\{\\Sigma[s \\in S](Q s \\rightarrow C)\\} \\cong C\\)\n```\n\n[^0]\n[^0]:    ${ }^{5}$ In HoTT, there are several different notions of type equivalence. In our formalisation, we primarily use a definition in terms of quasi-inverses [24, Definition 2.4.6], i.e. a function with an explicit inverse. All statements in this paper are independent of this particular choice and can be read with any other reasonable notion of equivalence in mind.\n\nIn particular, we have WAlg : FixedPoint whose carrier is W $S Q$ and MAlg : FixedPoint whose carrier is $\\mathrm{M} S Q$ (for the $\\chi$ components, we refer the reader to the formalisation).\n\nIf $\\llbracket \\mathbb{C} \\triangleleft \\mathbf{B} \\rrbracket \\mathbf{X}$ is to be a fixed point of $\\llbracket F \\rrbracket(\\mathbf{X},-)$, by Lambek's theorem [17], the following isomorphism is induced.\n\n$$\n\\llbracket F \\rrbracket(\\mathbf{X}, \\llbracket \\mathbb{C} \\triangleleft \\mathbf{B} \\rrbracket \\mathbf{X}) \\cong \\llbracket \\mathbb{C} \\triangleleft \\mathbf{B} \\rrbracket \\mathbf{X}\n$$\n\nBy massaging the left hand side of this isomorphism, we can write it as a container functor in terms of only $\\mathbf{X}$.\n\n$$\n\\begin{aligned}\n& \\sum_{s: S}((\\prod_{i}(\\mathbf{P} i s \\rightarrow \\mathbf{X} i)) \\times(Q s \\rightarrow \\llbracket \\mathbb{C} \\triangleleft \\mathbf{B} \\rrbracket \\mathbf{X})) \\\\\n= & \\sum_{s: S}((\\prod_{i}(\\mathbf{P} i s \\rightarrow \\mathbf{X} i)) \\times\\left(Q s \\rightarrow \\sum_{c: C}(\\prod_{i}(\\mathbf{B} i c \\rightarrow \\mathbf{X} i))\\right)) \\\\\n\\cong & \\sum_{s: S}((\\prod_{i}(\\mathbf{P} i s \\rightarrow \\mathbf{X} i)) \\times \\sum_{f: Q s \\rightarrow \\mathbb{C}}\\left(\\prod_{q: Q s} \\prod_{i}(\\mathbf{B} i(f q) \\rightarrow \\mathbf{X} i))\\right) \\\\\n& \\cong \\sum_{(s, f):} \\sum_{s: S}(Q s \\rightarrow \\mathbb{C}) \\cdot \\prod_{i}\\left(\\mathbf{P} i s+\\sum_{q: Q s}(\\mathbf{B} i(f q))\\right) \\rightarrow \\mathbf{X} i) \\\\\n& =\\llbracket \\sum_{s: S}(f: Q s \\rightarrow \\mathbb{C}) \\triangleleft(\\lambda i . \\mathbf{P} i s+\\sum_{q: Q s}(\\mathbf{B} i(f q))) \\rrbracket \\mathbf{X}\n\\end{aligned}\n$$\n\ndefinition of $\\llbracket \\ldots \\rrbracket$\ndistributivity of $\\Pi$ over $\\Sigma$\ncommutativity of $\\times$ and $(A \\rightarrow$ $C) \\times(B \\rightarrow C) \\cong$ $(A+B) \\rightarrow C$\ndefinition of $\\llbracket \\ldots \\rrbracket$\n\nThe induced isomorphism (1) can then be written as\n\n$$\n\\llbracket \\sum_{s: S}(f: Q s \\rightarrow \\mathbb{C}) \\triangleleft\\left(\\lambda i . \\mathbf{P} i s+\\sum_{q: Q s} \\mathbf{B} i(f q)\\right) \\rrbracket \\mathbf{X} \\cong \\llbracket \\mathbb{C} \\triangleleft \\mathbf{B} \\rrbracket \\mathbf{X}\n$$\n\nWe already have the isomorphism $\\chi: \\sum_{s: S}(f: Q s \\rightarrow \\mathbb{C}) \\cong \\mathbb{C}$ on shapes. We will also need the below isomorphism on positions for $i: I$ and $c: \\mathbb{C}$. We start using the notation $\\left(\\phi \\chi^{-1}{ }_{0}\\right) c$ and $\\left(\\phi \\chi^{-1}{ }_{1}\\right) c$ for the first and second projections of $\\left(\\chi^{-1} c\\right)$.\n\n$$\n\\left(\\mathbf{P} i\\left(\\left(\\phi \\chi^{-1}{ }_{0}\\right) c\\right)+\\sum_{q: Q\\left(\\left(\\phi \\chi^{-1}{ }_{0}\\right) c\\right)} \\mathbf{B} i\\left(\\left(\\phi \\chi^{-1}{ }_{1}\\right) c q\\right)\\right) \\cong \\mathbf{B} i c\n$$\n\nWe use this as our definition of $\\mathbf{B}$, which we hereafter call Pos, as an inductive family over $\\mathbb{C}$. In our code, Pos is also parameterised by a fixed point $\\phi$.\n\n```\ndata Pos ( }\\phi\\mathrm{ : FixedPoint) ( }i:I)\\mathrm{ : }\\phi.\\mathrm{C} \\rightarrow\\mathrm{ Type where\n    here : {c:\\phi.C} }->P i\\left(\\left(\\phi \\chi^{-1}{ }_{0}\\right) c\\right) \\rightarrow \\text { Pos } \\phi i c\n    below : {c:\\phi.C} (q:Q((\\phi \\chi^{-1}{ }_{0})c)) }->\\operatorname{Pos} \\phi i\\left(\\left(\\phi \\chi^{-1}{ }_{1}\\right) c q\\right) \\rightarrow \\operatorname{Pos} \\phi i c\n```\n\nIt turns out that Pos works for both cases: we set $\\mathbf{B}_{\\mu}=\\operatorname{Pos}$ WAlg and $\\mathbf{B}_{\\nu}=\\operatorname{Pos}$ MAlg. It is not immediately clear that choosing $\\mathbf{B}_{\\nu}$ to be an inductive (and not coinductive) family over $M S Q$ would be the right choice in the coinductive case, so we explain why this works in a bit more detail. Intuitively, we can think of Pos as the type of finite paths through a W or M tree. To see this more clearly, we look at Pos specified to $\\phi=\\mathrm{MAIg}$ and elide the indexing type, which would be equivalent to PosM below.\n\n```\ndata PosM : M S Q -> Type where\n    here : {m:M S Q} }->Q\\mathrm{ (shape m) }->\\mathrm{ PosM m\n    below : {m:M S Q} (p:Q(shape m)) -> PosM ((pos m) p) }->\\mathrm{ PosM m\n```\n\nNow, as an example, recall from Section 2.2 the $M$ trees encoding 0,1 , and $\\infty$ respectively of type $\\mathrm{N} \\infty$.\n![img-2.jpeg](img-2.jpeg)\n\nFor the first tree, PosM would be empty, as neither here nor below can be used to construct an element, since $Q$ (inl tt) is empty. For the second tree, PosM would consist solely of the element here tt, since $Q$ (inr tt) is T , but we cannot construct anything via below, since PosM for 0 is empty. For the third tree, PosM consists of here tt, below (here tt), below (below (here tt)), and so on, ad infinitum. Although M trees can have infinite paths, like in the third case, any position (i.e. where data is stored in the tree, even though this example does not involve payloads) is obtained via a finite path, and since PosM encodes exactly the finite paths, it is precisely what is required. We verify this is actually the case in Section 4.",
      "tables": {},
      "images": {
        "img-2.jpeg": "data:image/jpeg;base64,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"
      }
    },
    {
      "section_id": 9,
      "text": "# 3.2 Generalised induction principle for Pos \n\nWe take the opportunity to mention the induction principle for Pos, which will come in useful later. In general, given a fixed point $\\phi$, an index $i: I$, and a family of types $A:(c: \\phi . \\mathcal{C}) \\rightarrow$ Pos $\\phi i c \\rightarrow$ Type equipped with\n\n$$\n\\begin{aligned}\n= & h:\\left\\{c: \\phi . \\mathcal{C}\\right\\}\\left(p: P i\\left(\\left(\\phi \\chi^{-1}{ }_{0}\\right) c\\right)\\right) \\rightarrow A c(\\text { here } p) \\\\\n= & b:\\left\\{c: \\phi . \\mathcal{C}\\right\\}\\left(q: Q\\left(\\left(\\phi \\chi^{-1}{ }_{0}\\right) c\\right)\\right)\\left(p: \\operatorname{Pos} \\phi i\\left(\\left(\\phi \\chi^{-1}{ }_{1}\\right) c q\\right)\\right) \\rightarrow A\\left(\\left(\\phi \\chi^{-1}{ }_{1}\\right) c q\\right) p \\rightarrow \\\\\n& A c(\\text { below } q p)\n\\end{aligned}\n$$\n\ninduces, in the obvious way, a dependent function $(c: \\phi . \\mathcal{C})(p: \\operatorname{Pos} \\phi i c) \\rightarrow A c p$. In Cubical Agda, this is precisely the induction principle we get from performing a standard pattern matching. In practice, however, this induction principle is quite limited. The primary difficulty we run into is in the case where $A$ is only defined over $(d: D)$ and $\\operatorname{Pos} \\phi i(f d)$ for some fixed function $f: D \\rightarrow \\phi . \\mathcal{C}$. In this case, the induction principle above does not apply since $A$ is not defined over all of $\\phi . \\mathcal{C}$ (this is entirely analogous to how path induction does not apply to paths with fixed endpoints). There are, of course, special cases when the induction principle is still applicable: for instance, when $f$ is a retraction. In fact, we only need $f$ to satisfy a weaker property, namely the following.\n\nDefinition 11. Given a fixed point $\\phi$, a function $f: D \\rightarrow \\phi . \\mathcal{C}$ is called a $\\phi$-retraction if for any $d: D$, the lift $\\widehat{f}_{d}$ in the diagram to the right exists.\n![img-3.jpeg](img-3.jpeg)\n\n- Lemma 12 (Generalised Pos induction, $\\odot$ ). Let $\\phi$ be a fixed point, $i: I$ an index, and $f: D \\rightarrow \\phi . \\mathcal{C}$ a $\\phi$-retraction. Let $A:(d: D) \\rightarrow \\operatorname{Pos} \\phi i(f d) \\rightarrow$ Type be a dependent type equipped with\n$=h:\\left\\{d: D\\right\\}\\left(p: P i\\left(\\left(\\phi \\chi^{-1}{ }_{0}\\right)(f d)\\right)\\right) \\rightarrow A d$ (here $p$ )\n$=b:\\left\\{d: D\\right\\}\\left(q: Q\\left(\\left(\\phi \\chi^{-1}{ }_{0}\\right)(f d)\\right)\\right)\\left(p: \\operatorname{Pos} \\phi i\\left(\\left(\\phi \\chi^{-1}{ }_{1}\\right)(f d) q\\right)\\right) \\rightarrow A\\left(\\widehat{f}_{d} q\\right) \\widehat{p} \\rightarrow$ $A d($ below $q p)$\nwhere $\\widehat{p}$ is $p$ transported along the witness of the fact the diagram in Definition 11 commutes. This data induces a dependent function $(d: D)(p: \\operatorname{Pos} \\phi i(f d)) \\rightarrow A d p$.\n\nProof sketch. The induction principle follows immediately from the usual induction principle for Pos but with the family $\\widehat{A}:(c: \\phi . \\mathcal{C}) \\rightarrow$ Pos $\\phi i c \\rightarrow$ Type defined by\n\n$$\n\\widehat{A} c p:=(d: D)(t: c \\equiv f d) \\rightarrow A d \\widehat{p}\n$$\n\nwhere $\\widehat{p}$ denotes the result of transporting $p$ along $t: c \\equiv f d$. We obtain the appropriate statement by setting $c:=f d$.",
      "tables": {},
      "images": {
        "img-3.jpeg": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCACKAf8DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD3+iiigAooooAKKKKACiiigAooooAKKKKACjFFFACYFLRRQAUUVnajruk6OUGp6pZWXmZ2faZ0j3Y643Hn8KANGisNfGXhhyu3xJpDbjgAXsRyfQfNWwsgdA6MGVhlWXkEfWgCSiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvOPjLI9z4XsPD8JxPrepwWY9Qu7cT9Mqo/GvRea821j/iefHPQdP+9BounzX8n+/IQgB9x8hFAHoZsbU2Qs2t42tggj8plBXaBgDB7YrgPh3cmz8W+MfDELE6dpl1FJZpnIiWRSWjHooIwB9fSuy17XrTw7pM2o3zlY0GEQD55XP3Y0HdieAP5VzXw08OXukadqOr6xH5esa3dG8uY/+eQJJWP8AT+dAHdUUdqbnk0AOooHQUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFADJYlmieNtwDAglWKnn0I5H4VzUXw98OwahNqEUWoreTqElnGrXe+RR0DN5uSB6GuopjPtVmYhQoJLHoBQBk2nhXRrO9W9W1ee7TOye7nkuZEz12tIzFfwxWxgVheHPFVl4mju3shKotpjGVlXBdeqSqO6OuCp78+lb3agArD1Hw1De30l7DqGqWN2+MyWt2wU4GBmNsx/8AjtblGKAOZ+yeLrH/AI9tW0/VIx/BfW5gkP8A20jO3/yHS/8ACS6lZf8AIW8M6hEveaxK3cY/BcSf+OV0uKTA9KAMWx8X6BqM3kQarbC4/wCfeZvJlH1jfDD8q2s1WvtMsNUg8nULK3u4v7k8SuPyIrD/AOEK0+250m61HSWHQWV0wjH/AGyfdH/47QB0w6CiuZ+y+L7Af6PqmnapGP4L63MEh+skeV/8hij/AISfUbPjV/DOowAdZrLbeR/kmJP/ABygDpqKxLDxfoGpT/Z7bVrb7T3t5W8qUfWN8N+lbQJoAWigdKKACiiigAooooAKKKKACiiigAooooAKKKaTg0AOooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACo5JUiG6R1Rc4yxx+FJMZfIk8hlEu07C65UH3GRn8xXNTeC7LVZPO8STvrEuCRHP8AJbRdv3cIOB9W3MPWgDqMnqaxdX8PR63dKb+8unsAgVrBGVIZGyfvkDewPHy7tpxyDTNM0G50SZI9P1OZ9NBwbO8zN5Qx0jkJ3AezFh6YrexxQBg3vh6HU5I7r99peoW2Y7e6s5BvEYPAII2sp67GBAPvzW5CjRwRo8jSuqgNIwALEDqcADn2FRwCZN4mkjkbexUom3CZ4B5OSB34z6Cph0FAC0UUUAFFFFABRiiigBMAUYFLRQBUv9K0/VYPI1GxtruL+5cRLIv5EVh/8IVp9tzpN5qOkEHhbO6byv8Av0+6P/x2unowM570Acz9m8YWA/cajpuqxj+C8ga3kP1kjyv/AJDFH/CU31mMav4a1O2A6y2gW8j/APIf7zH1QV0uB6ClxQBiWHi3QtTn+z2mq2pue9vI3lyj6xthh+VbWTVTUNI03VofJ1GwtbyL+5cRLIB+BFYv/CF2Nsc6TfalpJB4W1umaP6eVJuj/JRQB0w6CiuZMHjDT/8AU3+marEP4buJraT8XTcpP/ABR/wlV7Z8av4b1S2A6y2qi8j/AA8vMn5oKAOmorF07xXoWqy+Taatavcd7dn2Sj6xthh+IrZyf8igBaKB0ooAKKKKAM3XNZttB0i51G7cLFDGz898KTj9KwfAcmoahpMOr3mrSXL3lrE01s0ZCwzkFn257YZVwOBt7nNHxMkk/wCEFv7O3J+06g0VhEB1JmkWPH5E11kMMcMKRxKFRFCqB2A6CgB46CloooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAEwDXn/iS+fWfHNp4bKailpHZT3FwYFxuZsRRuD0wuXI/2gD2rvJZkgRpJZFRFBJZiAFHqSa5PQAb74heKtSb5ooFttPhkByPkQyyAf8AAph+INAHUL5NlZKrzYjhjCmSV8nAGMsT1PuanjkSWJJI3V0cBlZTkEHoQe9cB4n17UNQ8PeIY7HyIYxcf2PAssZZ5ppCsZYfNgANJgDBztJ74ruNPitoNNtYbNla1jhRISpyCgAC4PcYxQA6KLyVcGSSTc7PmQ5xk5wPYdqnqnZGy2TfYTDt89/N8oj/AFm478475zmrY6CgBaKKKACiiigAooooAKKKKACiiigAooooAKKKKADApMClooApajo+mavD5Wpafa3kf924hWQfqKxv+ELs7U50nUdU0ph0W3umeP8A79y70/ICumpMCgDm/J8YWA/dXul6tGOi3UTWsp+rpuUn/gApB4qu7TjV/Dmq2oHWW2jF3H+HlZf80FdNikwMYxx6UAZGneKdC1aXybHVrSWcdYPMCyj6ocMPxFawJzVPUdG0zV4vK1LTrW8j7LcQrIB+YrHPg21tSDpGp6ppZHRYLoyRfTy5dyD8AKALUvhixn13+1ZpbmSTfHKIGlzEJEVlVgvYgO3TjODjIBG4Olc15PjGwH7q70rV4x0W4je0lP1dd6k/8AWkHiq5sxjVvDmq2gHWW3iF3H+HlEv+aCgDpqKx9N8UaHq8hisdVtJph1hEoEq/VD8w/EVr5PagBaKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAKt/p1pqljNZX0CT206lJI26MPQ0WOnWum232e0iEce4ueSxZickknJJ9zVqigChPomlXUjyXGm2kruwZmeFSSwxg5I68Dn2FXURIo1jjVURQAqqMAD0FOooAhhl87efLkTa5T94uM4OMj2PrU1QQvOwczxxxnzGChX3ZXPBPAwSO3OPU1OOlABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAJgelGBjGOPSlooAo6joulaxH5epabaXiDoLiFXx9Mjisf/AIQ63tju0jVtV0sr0WG6MsX08uXeoH0ArpqMDOaAOZ8vxlp/+rudK1aMdBOj2kp+rLvUn/gK0f8ACWXFpxq/h7VrMDrLDCLuM/jCWb81FdLgelGBjGOKAMnTfFGiaxIYtP1aznmHWFZR5g+qH5h+IrVyapaloek6xHs1PTbS8UdPPhV8fQkcVkf8IfDanOkavqumEdEjuTNF/wB8Tb1A+gFAHTUVzOzxlYfcn0nV4x2lR7SX8WXepP8AwFaP+EtmtDjV/D+rWQHWaOEXUX5wlmA+qigDpqKydM8TaLrD7NP1W0uJB96JJB5in3QncPxFam44oAdRQORmigAooooAKKKKACiiigAooooAKKKKACiiigAoqlqep2mj6dcahf3CW9pbrvllfoo/x9B/+qsPStQ17xHbC/jCaPp8o3W8ckXmXLqejtk7Uz2XDHHUjpQB1NFchbeJL7TPGEHhrXDDIb2B59PvYUKCXZ9+N15wwHzZBwR6HiuvHTmgBDS1z+v6nOL+x0PT5PLvr/ezTAA/Z4EA3yYPf5lVc8bmBOQCKu6xqtv4e0O51C4DtDax5CjlnPRVGerFsAe5FAGjk5p1ZmiwX0enh9Sl33s5Msyr9yNiPuL7KMDPfGepq9cXEdrbS3EzBIokLufQAZJ/IUAS0VV0yW4n0u0mvIxHcyQo0qDorlQSPzzVmgBaKTPNISQOtK4DqSsZ/FugxSNHJqkCupKspJyCOoqax8QaVqVwYLK+imkA3FU9KuVKdr2YF2W4iikjSSVEaRtqBmALHrgeveph0FcV4psrWPxh4Suo7aFbiXUXDyiMB2HkScE9a7UU5wUYxl3AWkzzS1z2q38uh61Z3Ezl9Mv5VtZQf+XeY8RuP9ljhCPUqR1OYA6Giiobq5hsrSa6uJFjghRpJHboqqMkn8BQBLk7valrB8OT32o2B1i93RtfBZYLUjiCHqgI/vkHLe5x2q14g1qLw94fvtXnUtHaQNKUB++QOFB7EnA/GgDUorlPDN94ou7zdq9tbrYyWUM6zIQD5zctGq9dqg4y3ORnnOF6ugApM801mIHYfWuL0DVNa8Qar4o027vLYQafNHbWt5ZW7RN5m3e+Q7OCVJQY6HByMHFAHbZ96Oax/DuryatYyi5RYr60me1u40+6JFxyvfawKuM9mFV7XUZtP8Tvot3IZIruNrmwlbGflI8yI+u3KkHuCf7pJAOhooHSigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKMCiigBMDOcc+tLiiigDO1LQdI1lQupaZZ3mOhnhVyv0JGR+FZX/AAh8dr82j6zq2m46IlyZ4vpsm3gD/dxXTUYoA5gDxlYfdk0nWIx0Dq9nKfxHmKT+C0v/AAl0lpxq+g6tYAdZVg+0xf8AfUO4ge7KK6XAowKAMvTPEmjaySunarZ3Mg+9HHKpdf8AeXOR+Nae7jJqhqegaPrIA1PTLS7I+600Ksy/QkZH4Vlf8Igtpzo+tatpuOAguftEf02TBwB7LtoA6YdKK5kf8JjYdH0nV4x0DB7OU/UjzFJ/BaP+Eua0ONY0PVtPx1kFv9pi/wC+oS2B/vAUAdISQeKdXG654psbvRft+iatBObK5hnuoreQNJ5CuPNBXOQQhZsH+7XXQyxzRJLE6vG6hldCCrA9CD3FAElFFc14m8Y2/h6e2sYrSfUtWu8m30+1AMjIASzHPAUAHnuRgd8AHS0UUUAFFFFAHl3xGLa94/8AB/hB8mxuJnvrtO0ixglVPt8rD8a9QAGAcCuO8WeHry48QaJ4n0iJZ9R0l3DWzOE+0wOpVlUnjeOSuSBnqRVK68V6xZyWMgs703N/dvbLaXsaQQREq7RjzMFs4RSSC4OWwM4AAMzxS7a18cfCGmWw3HSoZ725df4A4wAfTlF/76Fepdq5HwloVrpGoapPcXS33iK7KTajchSAu7OyNQfuqoBwOuME9RXXDoKAOM0lvtnxW8Syvy1jY2dtF7B/Mkb9dv5UvjwmW48K2GcJc65AXXsyxq8mD/wJFotI/wCzPivqavwms6bDNEx43PAzK6j3CyIfofaj4hJ5Fno2scCPS9WguJ2P8MJJicn2Akz7YoA6bUb+20nTbnULuQRW1tE0sr46Koyfr06Vxsk+reJfD0N3ezyadBq0kUcFhCF3eQ5BYyOQTuMYc4G0Dpz1rpPFWiDxH4X1LSDJ5Zu7do1f+63VSfxxWHHqGotqGlWs2h3LXWn2rSyRQPHs80gRIysWxsI87GcNx0oAuaXrd3D43vfC95OborZJf285VQ4RnKMj7QFyCARgcg8810dykslvIkMvlSOpCyAA7SehAP8AWsDw94enstT1HXNUmjl1bUSokEWfLgiUYSJM8kDqWwMk5wK6EnDe2fWkBx2n6xqWmfEC58O6ldNc2l1ai7sJnRQylTh4ztAz6jjOO57dDZXs2pXLXELhdPClYjwTO398Hsoxx68npjPA/EiVZ20vXVtxJp+jXypdy5P7yORgkqqB95egbsT8vODXp8ZQxqUIK4ypHTHtXXXiuSM0tXv6oS3HAYAFLgUvaiuQZzOuaBqWraxp17DqdrBHp9wZoY3s2kLEoUIZhIM9WPAHauhjLiFBIyvJtG5lXAJ9QMnA/E1IVBrlPHV7LbWmkWcTvGNS1W3s5HQ7W8tiWcAjkZCEcetbQUqrjTA6gPkda5f4kwmb4ca6wO2SG1NwjA/daPEgIPsVFQXrRaF478P2dhEkFtqcVzDNDGNqFo1Eitgcbhhhnrg+wqX4kSO3ga/sYObrUtlhAh6s8rBOPwJP0U+lRKHLZ9wOmsLj7Xp1tc4x50SSY9MgGuW+J7sPAd7bqxBu5re1+qyTIrD6bSwrrYIlgt44U+7GoUfQDFcv8R7Ge+8B6mLZDJcQBLqNB1YxOsmB7kJipA6sKoUKBgDoK86+LtrNe6DY6amoXUKarqNtp5t41TY+6QMWYlS3AQ9CB65rvrS7ivrKC8tZBJbzxrLG6/xKwyCPqCK4rxOv9q/Ezwdpq4eK1FzqU4642qEjb/vpjQB2On2ktpbCKa/uL1gc+bOsYb6fu1Vf0qeSVIYnlkcJGgLMx6AAc/41IBwKo6xp/wDami3+n+YYxdW8kG8dV3KVz+GaAOT0TWtQ8U6NeeJf7Rk0zS90psI440JMUZIMsu4EncQflG0AepIIf8KLaYeBotSu1Au9XuJdRnA6Zlckf+O7ay30jxCvwmPhOw0r7PqKacbWSSWVFibgg7CCSS/OM4A3fMRjB6/w3bXNvYLC8MlraQQxW1tbOFDKiIAWO0nkkkY9FHqaAMnSWNr8WPEdoM7LqwtLwgdN4Lxk/UhVH/ARSePW+yXnhO/jGJotdgh3DrslV42H0O4flT9BBvfiD4o1QYMEK22mxuOQWRWkk/IygfgaPGCHUde8KaSmC51L7fJ7RQIST/320Y+poA7Gq17fWunWsl1e3MVvbxjLyzOFVfqT0qzTWRXUqyhgeoPINAHP/wDCfeDv+hq0T/wPi/8AiqP+E+8Hf9DVon/gfF/8VW99nh/54x/98ij7PD/zxj/75FAGD/wn3g7/AKGrRP8AwPi/+Ko/4T7wd/0NWif+B8X/AMVW99nh/wCeMf8A3yKPs8P/ADxj/wC+RQBg/wDCfeDv+hq0T/wPi/8AiqP+E+8Hf9DVon/gfF/8VW99nh/54x/98ikMEP8AzxT/AL5FAGF/wn3g7/oatE/8D4v/AIqj/hPvB3/Q1aJ/4Hxf/FVvfZ4f+eUf/fIo+zw/88Y/++RQBg/8J94O/wChq0T/AMD4v/iqP+E+8Hf9DVon/gfF/wDFVu+RD/zyj/75FHkQ/wDPGP8A75FAGF/wn3g7/oatE/8AA+L/AOKo/wCE+8Hf9DVon/gfF/8AFVu+RD/zyj/75FHkw8nyo8f7ooAwv+E+8Hf9DVon/gfF/wDFUf8ACfeDv+hq0T/wPi/+Kq9b6jpt1qk+nQhTdQRrLIjQlcKzMoOSMHlG6elaAghx/qo/++RTaa3Awf8AhPvB3/Q1aJ/4Hxf/ABVH/CfeDv8AoatE/wDA+L/4qt3yIf8AnlH/AN8il+zw/wDPGP8A75FIDB/4T7wd/wBDVon/AIHxf/FUf8J94O/6GrRP/A+L/wCKre+zw/8APGP/AL5FJ5EP/PKP/vkUAYX/AAn3g7/oatE/8D4v/iqP+E+8Hf8AQ1aJ/wCB8X/xVb32eH/njH/3yKPs8P8Azxj/AO+RQBg/8J94O/6GrRP/AAPi/wDiqP8AhPvB3/Q1aJ/4Hxf/ABVb32eH/njH/wB8immCLnEMf/fIoAw/+E+8Hf8AQ1aJ/wCB8X/xVH/CfeDv+hq0T/wPi/8Aiq3vs8P/ADxj/wC+RR9nh/54x/8AfIoAwf8AhPvB3/Q1aJ/4HRf/ABVJ/wAJ74O/6GrRf/A+L/4qt/7PD/zxj/75FH2eH/njH/3yKAPFfiBrvhjX9ctpYtS0iWxsIiLyVLm3aWZJGXIgDggumzOeuGIXkmvTfBkegxeF7RPDVx9o0vnynMzSEc8j5uQQf4TjHoKi8RaVLrF7Y6QsJj0ubzJNQlj+Uui7QsORz85bJ/2UI710Fta29nbR29rBHBBGoVI4lCqg9ABwBQBJz6815b8Ld3iHxR4t8X3XzzSXzafb56xQx4O0fUFM/SvVMCuB0jSr/wACazq8drps+oaFqV217H9lw0ttMwAdWViMocDBBOOhHegDvqKKKACiiigBMDOa5/xh4Ss/GWjJp15cXNsIp1uIp7dgrxuoIBBPsT+ddDSdiaAMXw14ZsfC2kLp9l5rgu0ks0zbpJpGxl2bucAD8BW3TJOIyRwafQBka5pJ1OKCWCUQX9pL51pOV3BHwQVYfxKykhh6HgggEXbi3iv7CS1u4keG4iMcsZ+ZSpGGH5E1Y/j/AA/xpD1HuefyoAztGtLvTrFbK5uPtKwHZBMT87Rj7ocd2A4z3xngmrEViseo3N4WLSTpGnI+6qbiB+bMfxqy3XHbj+dO9KADFVr22+12rwedJEH4ZozhtuRkA9sjIyORnjBq0OlN7mls7gZ+oaNY6jok+jzQqLKaEwGNeAFxgY9MdvpVfQdJudHsobObUpbyK3jEMJdFDbR0LkfebGBngYGcZ5rX6Ejtik6sw7YFWpys430AeBxS0nalqPIArB8T6M+tWVuIXRLqyvIry3ZyQu+M5wxAOARlSccZzz0repjAbgcc1UZuEroDnn0q61HxPYaxexRwR6dDKsESyb2eSTaGY8YAAUgdSdxyBjBtzaU95r8GoXkitBZKTaQAcLIVIaVj64JVR2BY8k/LpZPlnns386kHH50OblYB46UhUMMEZHvS0UgOetfDzWuk6loguXXTJ0eO1MZxLbI4IZAfRScqewOMYUEt8O+Fbbw+xlWZ7i4W3jtI5JM/u4UyVUZJPJJJOeT7AAb5++3suR+tPwBwBQAvajFFFACbVyDgZHSqt8t09nMtk8UdywwkkoyqE8biB1xyccZxjIzkW6jP3/8AgX9KAKek6Vb6PpsVlb7mC5ZpJDl5HYlmdj3ZmJJ+tV7DSmh1e81a8kWW7nAij2/dhhUkhF9ycsx7k+gGNcdKQ85z7UAO7UUUUAFFFFABRRRQAnOaxNA1CbWkm1XeVs5JHis4/VFYr5h/3iCR227e5Na8x/cyfSub+HYH/CufDhxz/Z8P/oANAGnrurJpOms/2iGKZ3SGEzMAN7sEUkdwC2T9D0rUDbhkHj1rzzQ40udSuLmdFlnPie5tzLINzeUkcm1MnnaOw6CtrwL8uj38I4ih1S+ijQdERZ2CqB2AHAA6UAdJLcxRSpE8qLJJnYhIy2OuB3p5bBByME1w/wAWI0i8BajeRoqXUbW5SdRh1KzrtIbqMbmx6bj61u35z4m0eM8p5FzJtPTePLAbHqAzDPufWtHTSipXGW7qLWnuGNnqFhDCcbUmsnkYcc5YSqD+VS2Uepxsxv7u0nU/d8i2aIj6kyNn8hV0gDoMZ60h7e5rNy1sI5W1nLfEa9mNveLC+nQQLK1pIIy6STFhuK7eNy85xzXWDkCm9x9acPuiqnLmt6AVdRhuJ7KVLW5+z3AGYpCu4Bu2R3BPBHXBOCDgivoWrLrWjQXwj8t33JLFnPlyIxR0z3wysM+1X2HX6/0rmPAv/Hvrw7DXL3A9P3mf5k1IGzrmrLomjXN+0bStGAI4l6yyMwVEHuzMqj61PYRXMFlGt5OJrojdK6rhdx5IUdlHQd8dc1z3j3nT9GB5B1ywBHr+/WupTlRn0FAHHz+ItQ1PxddaRo17YxJYR27ymUhvOaRmLoP92NCcDBywyQBz2Y5FcN4Us7ZPG3jWRLeFXS+gCsEAKj7NHwD26n867npQBTv7yK1tpTJdx2z+W7Kz4OMDJIB6461yema1rU3w707xPdsGu1gN7cQRx4EtuSW2heu7y8EYPLD0NYWoolz4T+JlxOqyzxz3EaSSDcyqkKFFBPICkkgdieK7ixRf+ELgTaNv9nINuOP9XQBswTR3FvFNC4eKRA6MOhBGQakrA8Ckn4e+GiTknSrXn/tktb9ABRRRQAmBS0UUAFIQD1ANLRQB/9k="
      }
    },
    {
      "section_id": 10,
      "text": "# 4 Fixed points \n\nLet us now show that the constructions from Section 3 are correct: $\\llbracket \\mathrm{W} S Q \\triangleleft$ Pos WAlg $\\rrbracket \\mathbf{X}$ is the initial $\\llbracket F \\rrbracket(\\mathbf{X},-)$-algebra carrier, and $\\llbracket \\mathrm{M} S Q \\triangleleft$ Pos MAlg $\\rrbracket \\mathbf{X}$ is the terminal $\\llbracket F \\rrbracket(\\mathbf{X},-)$ coalgebra carrier. The proofs in this section mostly follow those given in [3], but in the more general (UIP-free) setting of Type instead of Set.\n\nWe start off by showing that $\\llbracket \\mathrm{W} S Q \\triangleleft$ Pos WAlg $\\rrbracket \\mathbf{X}$ is the initial $\\llbracket S \\triangleleft \\mathbf{P}, Q \\rrbracket(\\mathbf{X},-)$-algebra carrier. This proof is relatively straightforward.\n\n- Theorem 13 (\u25cb). Let $F=(S \\triangleleft \\mathbf{P}, Q)$ be a container in Ind +1 parameters with $S:$ Type, $\\mathbf{P}:$ Ind $\\rightarrow S \\rightarrow$ Type, $Q: S \\rightarrow$ Type. For any fixed $\\mathbf{X}:$ Ind $\\rightarrow$ Type, the type $\\llbracket \\mathrm{W} S Q \\triangleleft$ Pos WAlg $\\rrbracket \\mathbf{X}$ is the carrier of the initial algebra of $\\llbracket F \\rrbracket(\\mathbf{X},-):$ Type $\\rightarrow$ Type, i.e.\n\n$$\n\\llbracket \\mathrm{W} S Q \\triangleleft \\operatorname{Pos} \\mathrm{WAlg} \\rrbracket \\mathbf{X} \\cong \\mu Y . \\llbracket F \\rrbracket(\\mathbf{X}, Y)\n$$\n\nProof of Theorem 13. We write W for $\\mathrm{W} S Q$ and Pos $\\mu$ for Pos WAlg. We construct an $\\llbracket F \\rrbracket(\\mathbf{X},-)$-algebra with carrier $\\llbracket \\mathrm{W} \\triangleleft \\operatorname{Pos} \\mu \\rrbracket \\mathbf{X}$ by defining a morphism\ninto: $\\llbracket F \\rrbracket(\\mathbf{X},\\llbracket \\mathrm{W} \\triangleleft \\operatorname{Pos} \\mu \\rrbracket \\mathbf{X}) \\rightarrow \\llbracket \\mathrm{W} \\triangleleft \\operatorname{Pos} \\mu \\rrbracket \\mathbf{X}$\nby induction on Pos $\\mu$ as follows.\nfst $($ into $((s, f), g, h))=\\sup -\\mathrm{W} s f$\nsnd $($ into $((s, f), g, h))$ ind $($ here $p)=g$ ind $p$\nsnd $($ into $((s, f), g, h))$ ind $($ below $q b)=h$ ind $q b$\nThen ( $\\llbracket \\mathrm{W} \\triangleleft \\operatorname{Pos} \\mu \\rrbracket \\mathbf{X}$, into) is an $\\llbracket F \\rrbracket(\\mathbf{X},-)$-algebra. Now for any other algebra $(Y, \\alpha)$, we need to define $\\bar{\\alpha}: \\llbracket \\mathrm{W} \\triangleleft \\operatorname{Pos} \\mu \\rrbracket \\mathbf{X} \\rightarrow Y$ uniquely such that the below diagram commutes.\n\n$$\n\\begin{aligned}\n& \\llbracket F \\rrbracket(\\mathbf{X},\\llbracket \\mathrm{W} \\triangleleft \\operatorname{Pos} \\mu \\rrbracket \\mathbf{X}) \\xrightarrow{\\text { into }} \\llbracket \\mathrm{W} \\triangleleft \\operatorname{Pos} \\mu \\rrbracket \\mathbf{X} \\\\\n& \\llbracket F \\rrbracket(\\mathbf{X}, \\bar{\\alpha}) \\downarrow \\bar{\\alpha} \\\\\n& \\llbracket F \\rrbracket(\\mathbf{X}, Y) \\longrightarrow Y\n\\end{aligned}\n$$\n\nWe define $\\bar{\\alpha}: \\sum_{w: \\mathrm{W}}((i:$ Ind $) \\rightarrow \\operatorname{Pos} \\mu i w \\rightarrow \\mathbf{X} i) \\rightarrow Y$ by induction on W , as shown below. ${ }^{6}$\n\n$$\n\\begin{aligned}\n& \\bar{\\alpha}: \\Sigma \\llbracket w \\in \\mathrm{~W} S Q \\rrbracket((i: \\text { Ind }) \\rightarrow \\operatorname{Pos} \\mu i w \\rightarrow X i) \\rightarrow Y \\\\\n& \\bar{\\alpha}(\\sup -\\mathrm{W} s f, k)=\\alpha(s, \\mathrm{~g}, \\lambda q \\rightarrow \\bar{\\alpha}(f q, \\lambda i \\rightarrow \\mathrm{~h} i q)) \\\\\n& \\text { where } \\\\\n& \\mathrm{g}:(i: \\text { Ind }) \\rightarrow P i s \\rightarrow X i \\\\\n& \\mathrm{~g} i p=k i(\\text { here } p) \\\\\n& \\mathrm{h}:(i: \\text { Ind }) \\rightarrow(q: Q s) \\rightarrow \\operatorname{Pos} \\mu i(f q) \\rightarrow X i \\\\\n& \\text { h } i q b=k i(\\text { below } q b)\n\\end{aligned}\n$$\n\n[^0]\n[^0]:    ${ }^{6}$ Technically, this definition raises a termination checking error, but this is easily fixed in the actual code by defining the uncurried version first then writing $\\bar{\\alpha}$ in terms of it.\n\nThat (2) commutes then follows definitionally.\nThe only thing left to show is that $\\bar{\\alpha}$ is unique. We assume there is another arrow $\\bar{\\alpha}: \\llbracket \\mathrm{W} \\triangleleft \\operatorname{Pos} \\mu \\rrbracket \\mathbf{X} \\rightarrow Y$ making (2) commute, i.e.\n\n$$\n\\bar{\\alpha} \\circ \\text { into } \\equiv \\alpha \\circ \\llbracket F \\rrbracket(\\mathbf{X}, \\bar{\\alpha})\n$$\n\nand prove that for $w: \\mathrm{W}, k: \\operatorname{Pos} \\mu i w \\rightarrow \\mathbf{X} i$, we have $\\bar{\\alpha}(w, k) \\equiv \\bar{\\alpha}(w, k)$. By induction on W, we just have to show that for $s: S, f: Q s \\rightarrow \\mathrm{~W}$, we have $\\bar{\\alpha}($ sup-W $s f, k) \\equiv \\bar{\\alpha}($ sup-W $s f, k)$. This follows easily from $\\bar{\\alpha}$ 's definition, assumption (3), and our inductive hypothesis.\n\nNext, we show that $\\llbracket \\mathrm{M} S Q \\triangleleft \\operatorname{Pos} \\mathrm{MAlg} \\rrbracket \\mathbf{X}$ is the terminal $\\llbracket S \\triangleleft \\mathbf{P}, Q \\rrbracket(\\mathbf{X},-)$-coalgebra carrier. This proof is significantly more challenging than the previous one, both theoretically in that we use a modified version of the induction principle for Pos, and also technically in that we have to go through several workarounds for Cubical Agds to accept our proof. It also requires us to use a considerable amount of path algebra to prove coherences that are not needed when assuming UIP, which appears to be implicitly assumed in the original proof.\n\n- Theorem 14 (\u25cb). Let $F=(S \\triangleleft \\mathbf{P}, Q)$ be a container in Ind +1 parameters with $S:$ Type, $\\mathbf{P}:$ Ind $\\rightarrow S \\rightarrow$ Type, and $Q: S \\rightarrow$ Type. For any fixed $\\mathbf{X}:$ Ind $\\rightarrow$ Type, the type $\\llbracket \\mathrm{M} S Q \\triangleleft \\operatorname{Pos} \\mathrm{MAlg} \\rrbracket \\mathbf{X}$ is the carrier of the terminal coalgebra of $\\llbracket F \\rrbracket(\\mathbf{X},-):$ Type $\\rightarrow$ Type, i.e.\n\n$$\n\\llbracket \\mathrm{M} S Q \\triangleleft \\operatorname{Pos} \\mathrm{MAlg} \\rrbracket \\mathbf{X} \\cong \\nu Y . \\llbracket F \\rrbracket(\\mathbf{X}, Y)\n$$\n\nBefore we prove Theorem 14, we spell out what it is we need to show. We write M for $\\mathrm{M} S Q$ and Pos $\\nu$ for Pos MAlg. First, we construct an $\\llbracket F \\rrbracket(\\mathbf{X},-)$-coalgebra with carrier $\\llbracket \\mathrm{M} \\triangleleft \\operatorname{Pos} \\nu \\rrbracket \\mathbf{X}$ by defining\n\n$$\n\\text { out: } \\llbracket \\mathrm{M} \\triangleleft \\operatorname{Pos} \\nu \\rrbracket \\mathbf{X} \\rightarrow \\llbracket F \\rrbracket(\\mathbf{X}, \\llbracket \\mathrm{M} \\triangleleft \\operatorname{Pos} \\nu \\rrbracket \\mathbf{X})\n$$\n\nroughly as into ${ }^{-1}$, where into is the function from Theorem 13.\n\n$$\n\\text { out }(m, k)=(\\text { shape } m, \\text { pos } m),((\\lambda \\text { ind } p \\rightarrow k \\text { ind }(\\text { here } p)),(\\lambda \\text { ind } q b \\rightarrow k \\text { ind }(\\text { below } q b)))\n$$\n\nSo ( $\\llbracket \\mathrm{M} \\triangleleft \\operatorname{Pos} \\nu \\rrbracket \\mathbf{X}$, out $)$ is an $\\llbracket F \\rrbracket(\\mathbf{X},-)$-coalgebra. For any other algebra $(Y, \\beta)$, we need to define $\\bar{\\beta}: Y \\rightarrow \\llbracket \\mathrm{M} \\triangleleft \\operatorname{Pos} \\nu \\rrbracket \\mathbf{X}$ uniquely, such that the below diagram commutes.\n![img-4.jpeg](img-4.jpeg)\n\nTo this end, from now on we fix $\\beta: Y \\rightarrow \\llbracket F \\rrbracket(\\mathbf{X}, Y)$ with the following components.\n\n$$\n\\begin{aligned}\n& \\beta s: Y \\rightarrow S \\\\\n& \\beta g:(y: Y)(i: \\text { Ind }) \\rightarrow \\mathbf{P} i(\\beta s y) \\rightarrow \\mathbf{X} i \\\\\n& \\beta h:(y: Y) \\rightarrow Q(\\beta s y) \\rightarrow Y\n\\end{aligned}\n$$\n\nTo prove Theorem 14 we (i) construct $\\bar{\\beta}: Y \\rightarrow \\sum_{m: M}((i: \\operatorname{Ind}) \\rightarrow \\operatorname{Pos} \\nu i m \\rightarrow \\mathbf{X} i)$ such that (4) commutes and (ii) show that this $\\bar{\\beta}$ is unique. This will be the content of Lemmas 15 and 16 .\n\nLemma 15 (\u0e51). There is a function $\\bar{\\beta}: Y \\rightarrow \\sum_{m: M}((i: \\operatorname{Ind}) \\rightarrow$ Posv $i m \\rightarrow \\mathbf{X} i)$ making (4) commute.\n\nProof/construction. We will define $\\bar{\\beta}$ by\n\n$$\n\\begin{aligned}\n& \\bar{\\beta}: Y \\rightarrow \\Sigma[m \\in \\mathrm{M}]((\\text { ind }: \\text { Ind }) \\rightarrow \\text { Posv ind } m \\rightarrow X \\text { ind }) \\\\\n& \\bar{\\beta} y=\\bar{\\beta}_{1} y, \\bar{\\beta}_{s} y\n\\end{aligned}\n$$\n\nwhere $\\bar{\\beta}_{1}: Y \\rightarrow \\mathrm{M}$ is defined by coinduction on M and $\\bar{\\beta}_{2}:(y: Y)(i: \\operatorname{Ind}) \\rightarrow$ Posv $i\\left(\\bar{\\beta}_{1} y\\right) \\rightarrow$ $\\mathbf{X} i$ is defined by induction on Posv as follows.\n\n$$\n\\begin{array}{ll}\n\\bar{\\beta}_{1}: Y \\rightarrow \\mathrm{M} & \\bar{\\beta}_{s}:(y: Y)(\\text { ind }: \\text { Ind }) \\rightarrow \\text { Posv ind }\\left(\\bar{\\beta}_{1} y\\right) \\rightarrow X \\text { ind } \\\\\n\\text { shape }\\left(\\bar{\\beta}_{1} y\\right)=\\beta s y & \\bar{\\beta}_{s} y \\text { ind }(\\text { here } p)=\\beta g y \\text { ind } p \\\\\n\\operatorname{pos}\\left(\\bar{\\beta}_{1} y\\right)=\\bar{\\beta}_{1} \\circ(\\beta h y) & \\bar{\\beta}_{s} y \\text { ind }(\\text { below } q p)=\\bar{\\beta}_{s}(\\beta h y q) \\text { ind } p\n\\end{array}\n$$\n\nThis construction makes (4) commute by definition.\nTo show that $\\bar{\\beta}$ is unique, we assume there is another arrow $\\bar{\\beta}: Y \\rightarrow \\llbracket \\mathrm{M} \\triangleleft$ Posv $\\rrbracket \\mathbf{X}$ making the above diagram commute, i.e.\n\n$$\n\\text { out } \\circ \\bar{\\beta} \\equiv \\llbracket F \\rrbracket(\\mathbf{X}, \\bar{\\beta}) \\circ \\beta\n$$\n\nthen show that $\\bar{\\beta} \\equiv \\bar{\\beta}$. Naming $\\bar{\\beta}$ 's first and second projections $\\bar{\\beta}_{1}$ and $\\bar{\\beta}_{2}$, assumption (5) can be split up into the paths shown below. We remark that all but the first one of these paths are dependent paths. In what follows, we fix $y: Y$.\n\n$$\n\\begin{aligned}\n& \\operatorname{comm}_{1} y: \\text { shape }\\left(\\bar{\\beta}_{1} y\\right) \\equiv \\beta s y \\\\\n& \\operatorname{comm}_{2} y: \\operatorname{pos}\\left(\\bar{\\beta}_{1} y\\right) \\approx\\left(\\lambda q \\rightarrow \\bar{\\beta}_{1}(\\beta h y q)\\right) \\\\\n& \\text { t. dependent path over }\\left(\\lambda i \\rightarrow Q\\left(\\operatorname{comm}_{1} y i\\right) \\rightarrow \\mathrm{M}\\right) \\\\\n& \\operatorname{comm}_{3} y:\\left(\\lambda \\text { ind } p \\rightarrow \\bar{\\beta}_{2} y \\text { ind }(\\text { here } p)\\right) \\approx \\beta g y \\\\\n& \\text { t. dependent path over }\\left(\\lambda i \\rightarrow(\\text { ind }: \\text { Ind }) \\rightarrow P \\text { ind }\\left(\\operatorname{comm}_{1} y i\\right) \\rightarrow X \\text { ind }\\right) \\\\\n& \\operatorname{comm}_{4} y:\\left(\\lambda \\text { ind } q b \\rightarrow \\bar{\\beta}_{2} y \\text { ind }(\\text { below } q b)\\right) \\approx\\left(\\lambda \\text { ind } q b \\rightarrow \\bar{\\beta}_{2}(\\beta h y q) \\text { ind } b\\right) \\\\\n& \\text { t. dependent path over }\\left(\\lambda i \\rightarrow(\\text { ind }: \\text { Ind })\\left(q: Q\\left(\\operatorname{comm}_{1} y i\\right)\\right) \\rightarrow \\text { Posv ind }\\left(\\operatorname{comm}_{2} y i q\\right) \\rightarrow X \\text { ind }\\right)\n\\end{aligned}\n$$\n\nThese equations simply express the fact that for $\\bar{\\beta}$ to make diagram (4) commute, $\\bar{\\beta}_{1}$ and $\\bar{\\beta}_{2}$ have to be defined in the same way component-wise as $\\bar{\\beta}_{1}$ and $\\bar{\\beta}_{2}$, up to a path.\n\nLemma 16 (\u0e51). The function $\\bar{\\beta}: Y \\rightarrow \\sum_{m: M}((i: \\operatorname{Ind}) \\rightarrow$ Posv $i m \\rightarrow \\mathbf{X} i)$ from Lemma 15 is unique. In other words, under the assumption of the existence of comm ${ }_{1}$-comm $_{4}$ above, we can construct the following paths.\n\n$$\n\\begin{aligned}\n& \\text { fstEq }:(y: Y) \\rightarrow \\bar{\\beta}_{1} y \\equiv \\bar{\\beta}_{1} y \\\\\n& \\text { sndEq }:(y: Y) \\rightarrow \\bar{\\beta}_{s} y \\approx \\bar{\\beta}_{s} y \\\\\n& \\text { t. dependent path over }\\left(\\lambda i \\rightarrow(\\text { ind }: \\text { Ind }) \\rightarrow \\text { Posv ind }(\\text { fstEq } y i) X \\text { ind }\\right)\n\\end{aligned}\n$$\n\nProof of Lemma 16, part 1: construction of fstEq. Recall the coinduction principle MCoind from Section 2. Using this, we can prove fstEq in a rather straightforward manner. To apply it, we need to construct a binary relation R on M . We construct it as an inductive family that relates precisely those terms we need to prove equal, i.e. $\\bar{\\beta}_{1} y$ and $\\bar{\\beta}_{1} y$.\n\n$$\n\\begin{aligned}\n& \\text { data } R: M \\rightarrow M \\rightarrow \\text { Type where } \\\\\n& \\text { R-intro: }(y: Y) \\rightarrow \\mathrm{R}\\left(\\bar{\\beta}_{1} y\\right)\\left(\\bar{\\beta}_{1} y\\right)\n\\end{aligned}\n$$\n\nWe then prove that it is a bisimulation using copattern matching.\n\n```\nisBisimR : \\(\\left\\{m_{0} m_{1}: \\mathrm{M}\\right\\} \\rightarrow \\mathrm{R} m_{0} m_{1} \\rightarrow \\mathrm{M}-\\mathrm{R} \\mathrm{R} m_{0} m_{1}\\)\ns-eq (isBisimR (R-intro \\(y\\) )) \\(=\\operatorname{comm}_{1} y\\)\np-eq (isBisimR (R-intro \\(y\\) )) \\(\\varphi_{i} q_{1} q-e q=\\) transport \\(\\ldots\\left(\\mathrm{R}\\right.\\) intro \\(\\left.\\left(\\beta h y q_{1}\\right)\\right)\\)\n    \\. Here, the second goal is of type \\(\\mathrm{R}\\left(\\operatorname{pos}\\left(\\bar{\\beta}_{1} y q_{0}\\right)\\right)\\left(\\bar{\\beta}_{1}\\left(\\beta h y q_{1}\\right)\\right)\\) while R-intro \\(\\left(\\beta h y q_{1}\\right)\\) is of type\n    R \\(\\left(\\bar{\\beta}_{1}\\left(\\beta h y q_{1}\\right)\\right)\\left(\\bar{\\beta}_{1}\\left(\\beta h y q_{1}\\right)\\right)\\), This mismatch is adjusted using comm 2 . Explicitly, we transport\n    over the path of types \\((\\lambda i \\rightarrow \\mathrm{R}\\left(\\operatorname{comm}_{2} y(\\sim i)(q-e q(\\sim i))\\right)\\).\n```\n\nThis allows us to finish the construction of fstEq.\n\n$$\n\\text { fstEq } y=\\text { MCoind } \\mathrm{R} \\text { isBisimR }(\\mathrm{R} \\text {-intro } y)\n$$\n\nBefore we continue with the construction of sndEq, let us briefly discuss some of the finer points concerning the construction of fstEq. Because we used MCoind and isBisimR to construct fstEq, its definition is somewhat opaque. Fortunately, the construction is well-behaved on shape and thus the action of shape on (fstEq $y$ ) computes definitionally to comm $_{1} y$. This means that the action of pos on (fstEq $y$ ) can be viewed as a dependent path $\\operatorname{pos}\\left(\\bar{\\beta}_{1} y\\right) \\equiv \\bar{\\beta}_{1} \\circ(\\beta h y)$ over the path of types $\\left(\\lambda i \\rightarrow Q\\left(\\right.\\right.$ comm $\\left.\\left._{1} y i\\right) \\rightarrow \\mathrm{M}\\right)$. There is another canonical element of this type obtained by simply composing comm 2 with a corecursive call of fstEq - let us call it fstEqPos. It is defined as the composition of paths\n\n$$\n\\operatorname{pos}\\left(\\bar{\\beta}_{1} y\\right) \\xrightarrow{\\text { comm }_{2} y}\\left(\\lambda q \\rightarrow \\bar{\\beta}_{1}(\\beta h y q)\\right) \\xrightarrow{\\text { fstEq } \\circ(\\beta h y)} \\bar{\\beta}_{1}(\\beta h y q)\n$$\n\nwhere the squiggly arrow indicates that $\\left(\\right.$ comm $\\left._{2} y\\right)$ is a dependent path. We can now ask whether pos computes to (fstEqPos $y$ ) on (fstEq $y$ ) (which in essence just says that fstEq satisfies the obvious coinductive computational rule). This would be entirely trivial if we had assumed UIP but now becomes something we cannot take for granted. Fortunately, it turns out we can still prove it.\n\n- Lemma 17 (Q). For all $y: Y$, we have fstEqPos $y \\equiv\\left(\\lambda i \\rightarrow \\operatorname{pos}(\\right.$ fstEq $\\left.y i\\right)$ ).\n\nProof sketch of Lemma 17. The lemma is proved by abstracting and applying function extensionality and path induction on comm $_{1}$. In this special case, i.e. when comm $_{1} y=$ refl, one can simplify the instances of isBisimR and MCoind used in the construction of fstEq. We omit the details which are just technical path algebraic manipulations and refer the reader to the formalisation.\n\nOne may reasonably ask why this is a lemma and not simply part of the definition of fstEq. We discuss this in Section 4.1.\n\nLet us now move on to the construction of sndEq. We construct sndEq using Lemma 12 which requires the following fact.\n\n- Lemma 18. $\\bar{\\beta}_{1}$ is an MAlg-retraction.\n\nProof. By unfolding definitions, we see that the statement boils down to constructing, for each $y: Y$, a function $\\widehat{f}_{y}: Q(\\beta s y) \\rightarrow Y$ such that the following identity holds for each $q: Q(\\beta s y)$.\n\n$$\n\\bar{\\beta}_{1} y\\left(\\widehat{f}_{y} q\\right) \\equiv_{\\mathrm{M}} \\bar{\\beta}_{1} y(\\beta h y q)\n$$\n\nDefining $\\widehat{f}_{y}=\\beta h y$ makes (7) hold definitionally.\n\nFinally, we are ready to construct sndEq and thereby finish the proof of Lemma 16.\nProof of Lemma 16, part 2: construction of sndEq. For ease of notation, we define, for each ind: Ind and $y: Y$, the function $\\operatorname{tr} y:$ Pos $\\nu$ ind $\\left(\\bar{\\beta}_{1} y\\right) \\rightarrow$ Pos $\\nu$ ind $\\left(\\bar{\\beta}_{1} y\\right)$ to be the function obtained by transporting via (fstEq $y)^{-1} .{ }^{7}$ For the construction of sndEq, we first note that, by function extensionality and the interchangeability of dependent paths and transports, constructing sndEq is equivalent to showing that\n\n$$\n\\bar{\\beta}_{2} y \\text { ind }(\\operatorname{tr} y t) \\equiv \\bar{\\beta}_{2} y \\text { ind } t\n$$\n\nfor ind: Ind and $t:$ Pos $v$ ind $\\left(\\bar{\\beta}_{1} y\\right)$. In light of Lemma 18, we may apply Lemma 12 in order to induct on $t$. When $t$ is of the form here $p$, there is not much to show. Indeed, by translating this instance of (8) back into the language of dependent paths, we see that the data is given precisely by comm $_{3}$.\n\nWhen $t$ is of the form below $q p$, we may assume inductively that we have a path\n\n$$\n\\bar{\\beta}_{2}(\\beta h y q) \\text { ind }\\left(\\operatorname{tr}(\\beta h y q) p\\right) \\equiv \\bar{\\beta}_{2}(\\beta h y q) \\text { ind } p\n$$\n\nand the goal is to show that\n\n$$\n\\bar{\\beta}_{2} y \\text { ind }(\\operatorname{tr} y(\\text { below } q p)) \\equiv \\bar{\\beta}_{2} y \\text { ind }(\\text { below } q p)\n$$\n\nThe RHS of (10) is, by definition, equal to the RHS of (9). By commuting transports with below and using comm $_{4}$, we can rewrite the LHS of (9) to a term of the form $\\bar{\\beta}_{2} y$ ind (below (transport . . . q) (transport . . . p)). Commuting transports with below in the LHS of (10), we get a term of the same form, albeit with transports over slightly different families. Thus, it remains to equate these families. We spare the reader the technical details and simply point out that this task, after some path algebra, boils down to precisely Lemma 17. This concludes the proof of Lemma 16 and thus also of Theorem 14.\n\n- Example 19. For a concrete example of Theorem 13 and Theorem 14, consider S, $\\mathrm{P}_{0}$, and $\\mathrm{P}_{1}$ as defined in Example 6. Then for a fixed $X$ : Type, $\\llbracket \\mathrm{S} \\triangleleft \\mathrm{P}_{0}, \\mathrm{P}_{1} \\rrbracket(X,-)$ : Type $\\rightarrow$ Type has an initial algebra with carrier $\\llbracket \\mathrm{N} \\triangleleft$ Fin $\\rrbracket X$, and it has a terminal coalgebra with carrier $\\llbracket \\mathrm{N} \\infty \\triangleleft$ Cofin $\\rrbracket X . \\mathrm{N} \\infty$ is defined as in Example 2 and Cofin is the inductive type family over $\\mathbb{N} \\infty$ of finite and infinite sets. We note that $\\llbracket \\mathrm{S} \\triangleleft \\mathrm{P}_{0}, \\mathrm{P}_{1} \\rrbracket(X,-) \\cong \\top \\uplus(-\\times X)$, the signature functor for List. $\\mathbb{N} \\triangleleft$ Fin is the container representation of lists while $\\mathbb{N} \\infty \\triangleleft$ Cofin is the container representation of colists (the type of finite and infinite lists).",
      "tables": {},
      "images": {
        "img-4.jpeg": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCACRAdsDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD3+iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiq0t9bQzRwy3EMcknCI7hWY+gBOSaALNFIDn6UtABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFZOv6jqOl6XPeadp0V+8EbSPA9wYmZQM/LhGyeOAcfWs7wP4rm8ZeH49ZNlBa20xYRIlyZX+VipDjYoU8Duc5oA6eiua1PxBrEHiKHSdK0SDUA0PmzTtemEW/OBvHlt97nbgknDcADNdFGzlV3qFfAyAcgHvzgfyoAfRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAEF3dR2VlPdTMBFDG0jn0VRk1wPiJ71PDlxYXemSwNqTRQXOrSSRmOJ5WVcgBi42s+1fl4IByB81dT4nE02krYWzqlxfSrAhYZGPvPkZ6bFeq2q6PfeIvstpfpbW2nRTxzzJDIZHnKMGVMlVCruAJ6k4xx1oA6JF2qoyTgAZPU0+kxS0AFFFFABRRRQAUUUUAFFFFABRQelNByaAHUUVm+IrybT/DOq3tuQs9vZzSxkjOGVCRx9RQBog5pa4fw62v3PiK5gvPEU09va29tMYvskS+YZA5IJC5GNoxit7xRrVz4f0G71WC0guUtImmmSW4MR2KpJ2kK2W9AcfWgDapuT7fhXKaJ4i8R69odnqsHh+whhu4RNGk+pOH2npkCE9RzTLbV9b11NWsXhfQb7TpEHmxSR3KyqVLDBZAPTtmgDrwaU8CuE8E6rrF7eWi6pqTXq3ejW2ogNAieW8hIIG0DjjvXR69rL6Zb28NtGkuo3sogtInPyl8ElmxztVQzHHYe9AGuCSaWue1q/17SNOifTNITWXihJmDXXkOzKB91djAluTjI6Ad65r4efFGTx/fXUCaPDYrbDMge9Ly89CE8sZGeCc8ceooA9Gorgrbxv4lv9d1LS7Pwnaytp7Ks8/9rARBmGQu7yuWxyR2yM4rukZyql1CsQMgHOD6ZoAfRRXCHx3q0Pju28J3Wg2cN1cQ/aI5/wC0mMciDO4L+6BLDDfLgdOoHNAHd0maz9b1NtK0a6vkjileFNyxySFBIf7oIVjk9AACSSBiqek3mu6rpTzX+mxaPPJGDCguPtDoxB++AqgYOOATnnpjkA3M0tZOg6wdWtJRNGIr21mNvdxA52SLg5HqrAhgf7rCtagAooooAKKKKACiiigAooooAKKKKACjqKKO1ACYrx7wbPd+EPG3ijwVZW3m+bMt/pgwTHCjgbi/oqgqPcqRnJr1m6vI7O2eeVZmRRkiGF5W/BUBJ/AV514IlmvPiT4o1i+07U7Z714rewNzYTRr5EanJ3MuF3EA4Ygn0oA7/S9Nj0218sMZZpG3zzv96ZyOWOPyA6AAAAAAVewKXFFAFe6vbawtmuby5ht4E+/LM4RV57knArL/AOEz8Lf9DLo//gdF/wDFVsvEkilXUMp6hhkGof7Psv8Anzt/+/S/4UAZn/CZ+Fv+hl0f/wADov8A4qj/AITPwt/0Muj/APgdF/8AFVp/2fZf8+dv/wB+l/wo/s+y/wCfO3/79L/hQBmf8Jn4W/6GXR//AAOi/wDiqP8AhM/C3/Qy6P8A+B0X/wAVWn/Z9l/z52//AH6X/Cj+z7L/AJ87f/v0v+FAGZ/wmfhb/oZdH/8AA6L/AOKo/wCEz8Lf9DLo/wD4HRf/ABVaf9n2X/Pnb/8Afpf8KP7Psv8Anzt/+/S/4UAZn/CZ+Fv+hl0f/wADov8A4qj/AITPwt/0Muj/APgdF/8AFVp/2fZf8+dv/wB+l/wo/s+y/wCfO3/79L/hQBmf8Jn4W/6GXR//AAOi/wDiqD4z8LEY/wCEl0f/AMDov/iq0/7Psv8Anzt/+/S/4Uf2fZf8+dv/AN+l/wAKAMpvF/hN2Vm8R6MShypN9FwcEZ+96Ej8ad/wmXhb/oZdH/8AA6L/AOKrT/s+y/587f8A79L/AIUf2fZf8+dv/wB+l/woAzP+Ez8Lf9DLo/8A4HRf/FUf8Jn4W/6GXR//AAOi/wDiq0/7Psv+fO3/AO/S/wCFH9n2X/Pnb/8Afpf8KAMz/hM/C3/Qy6P/AOB0X/xVH/CZ+Fv+hl0f/wADov8A4qtP+z7L/nzt/wDv0v8AhR/Z9l/z52//AH6X/CgDM/4TPwt/0Muj/wDgdF/8VR/wmfhb/oZdH/8AA6L/AOKrT/s+y/587f8A79L/AIUf2fZf8+dv/wB+l/woAzP+Ez8Lf9DLo/8A4HRf/FUf8Jn4W/6GXR//AAOi/wDiq0/7Psv+fO3/AO/S/wCFH9n2X/Pnb/8Afpf8KAMz/hM/C3/Qy6P/AOB0X/xVH/CZ+Fv+hl0f/wADov8A4qtP+z7L/nzt/wDv0v8AhR/Z9l/z52//AH6X/CgDMPjPwtg/8VLo/wD4HRf/ABVc5oXjTRbHXJtBudesroXFy8+nXKXSyhxI24wsQTtZWYhQeqlcZOQO2On2WP8Ajzt/+/S/4Vzej+H4r7V7nXdWsUE63Lx2EEiDbbxI20OF6b3IL7uuCo4xQB1mfSsbxf8A8iVr3/YOuP8A0W1bOOKx/F//ACJWvf8AYOuP/RbUAZXhcf8AFT6v/wBeOn/+gSVjfGm7lXwKmkWgZrvWbyGxhRMZJLbuAT324/4FWz4Y/wCRm1f/AK8NP/8AQJK5bxPfNrXxM8Kzf2XrLaLpXnXE040m5KmYjCDHl5OCqnIGPm60AdLaazew6roPh+20K/0+3MbM8twYGUQxJjaPLd+SxjHbg8V0stpDBHfTIDvnUtISxOcLgfTgVMiwzPFdiM+ZsIRnQqyq2CRyMjO1cj2FOuv+POb/AK5t/KgDgvAv/H5ouef+KUsD+OWrRZje/F9YnO6LTtF8xAf4ZJpsE/XbEB+NZ3gT/j80X/sU7H+bVobTZ/GAyNxHqOi7UJ7vDLkj/vmUH8KAOw2AD14xXzv8WNPl8AeN7bxX4YvFtrq8jkkuLdFzszhTIVxjYxYdf4vfp7b4g8TpoUeBpWrX8zRl0SxspJgT2BZQQufeuc8E6Ymv6VquoeIdPujqmq5jvor21eERxEfLBGHAyig9R1bJzmgDV+Hj6NN4L06bQ5GltZELySSNmVpicyGQ/wB8tnP4dsV1WBXz34Bl174f+Mr+yt9E8QXnhS6k3LI2mThozj5X2lc5A+U+uAewr17XvF02k+G7fWrPQtRv45JVEkCwtHNDHzmRkYbgBjoQOvYUAdP1ry/4w28umWujeNLNW+06FeI0u04LwOwDKT7nA/4Ea9OB3KOOvY15n8V7mbWdOs/Dtrp2qzxT6hD/AGhJDp07rHbqQzEMFw/OD8uehoA67T1fX7iDVriN0skIext5BgtkcTOOxOTtHYHJ+Y4Xf2ioLaWO4t45olkWNwCokjaNgPdWAI+hqxQBxlo4svi9qFohPl6ho8V24PeSOUx5/wC+WX8q7OuNtUN58Xb66QZjsNHitnb/AG5JWfH/AHyin8RXZUAFFFFABRRRQAUUUUAFFFFABRRRQAUHpRRQAhUY/pTQOn6U89KwPGNxNZ+HvOtpWikF5aJuU4+VrmNSPxBI/GgDezzS0g4paACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACkAx3NLRQAVmeI7Sa/8L6tZ2yb57iymijXOMsyEAZPua06KAOG8NnXLfxHczXfhq8tre7gtoPNa4t2EZiVwSQshODuGMA13G0UYpaAExjJ71n6xdXVtp0jWmmz38r/ACCGGSNGGR1y7KP1rRpMCgDg/A+naxaXdm2p6TLYpaaJbadulmifzJIydxXY7YHI64rovEGkSalFbXNm8cWpWE32i1lkztDYKlGxztZWKnHrnqBW1tFG360AQ28jywRtLA0EjKN0bEEofTI4OPUcVLtH/wCql2gc0gbd0I9DigBdoqnqVm2oWT2nmBIpSFm+XJZP4lHpkZGe2c9au0YoATFG2looATaBzUV1JLHayvDD50oU7I923cccDPb61NSYB60AZHh/SG0q0ma4kWbULuY3F5Mq4DyHAwB2VQAqj0Ud+a2KTaM5paACiiigAooooAKKKKACiiigAooooAKTNHasXUrTxBNdb9N1axtYNo/dz6e0zZ9dwlX+VNK+lwNrNc346P8AxTB/6/rL/wBKoqg8rxP9p+z/APCUaL52M+V/ZjbiPp5+al8b5HhYByCwvbHJAxn/AEqLmnKHLbW4HTd6Wk70tSAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABXOeEGZotZ3MzY1e5AyegDDAro65rwf/qda/wCwxdf+h0AdLRTd3NG6gB1FJSEkdqAHUU0MT2pc0ALRSZoJoAM0VUvr9dOs3uZIp5VTGUt4Wlc5OOFUEn8qxv8AhNLP/oF69j1OkXA/9lq405y2QHSUtZul6xFq0bvFbXsAQgEXdpJATn0DgZ+taNRJOLswFooooAKKKKACiiigBKoavdSWumytCcTyMsURIzh3YIpI7gEg/hV81h60LmfUdLtrXyzIjtdMshIV0QbdpIzjmVSDz93vTgry1EzAvd8uqaJpDWEunQ/b/OS7meNzcGIF9oKkkM4BJLY+UMOpxWv45GPDB/6/rL/0qiqRtIutS12x1HUDDFDp5dre3hctukZdpd2IHRSQFA6sTnsGeOv+RYP/AF/WX/pVFWlWSlYEdH3paTvS1kMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArmvB/+p1r/ALDF1/6HXS1zfg//AFWtf9hi6/8AQ6AMfxXLet4j8iHUr22iRdOUJby7AfOu2jcn32gCuq1KX+ytAubhbjYLS3LmaZTJ8qLkk8jJwPWuU8T/API0yf8AcH/9LnpvxZ1m3tPBd1pS30EN9qbR2iLJKqkJI4DMQTwoXdk0AW/DWo+JdZ8L6VqV9qWm2l1qMQljiFkzD5lLKBmUEnaM/gai1D+17rRdDm1C9ubO+kvUtrgWTGFGUuwztJYjgDv3rU0vwzpdrf6dqWn3M8tvBaPBCj3ck8ZDbNrLuYgYVSMgDIb0FS+KeE0nn/mKW/8A6FQBDomsLafDy01nVLh3WGwE9xK3LMFXJPueKuWsesz6F5klylrqdxtkO+LzUt84/d7QRuwBgnPUk9OK5G/R2+BKFckR6fFJJzj5FZWf/wAdBrur7UrDTLI3eoXlvbWy8GWeUIgJ/wBomgDzXTPiNqujeLtV0Px5c2Vj5Fu01nNFbkR3CjPzAljk4BwuMk5GcjB6vwhL4svrSK/1+4tYoZtzJZrZmOVUP3C5MjBWI5KgHHTPXHD6zp0XxlS+1DT9ShtbXSC0emyKR5jT5BaWX+KNDtAUdcfN2ArY+GvxNtfEdjHpmtXVtBr9vJ5BBkULdns0fYk45A/kRQB6WQB/9esie/ee+mtkultYYCFkl+Xcz4DbV3cYCkEnB+8OmDU9nrmn3+p6hptvcB7vTii3Ue1l8suu5eSMEEZ5BPQ1zC3Xh698O/a9TtbW8nkaaWO2liV5yXYkIqkZyV2j6AHpV013EzQsb/V9W8JrqNvtW9jeSSAbdqXSKzBMg/dEigHPbcD0GDt6XqMWsaVaalaMGt7qFZoywwcMM8jsfaqXhe2vrPwrpdtqjl76K2jSdic/MF5ye57Z71Q+HasngTTT82yTzZY8j+B5XZPw2kYpTtzuwzqqKKKkAooooAKKKKADFN8tC4cqN4GA2OcelOooAbsA6dR0rm/HLZ8L8f8AP9Zf+lUVdK4JRgGKkjgjqK8z8calrHh7w+I9YYajp73dq0d9BDsljK3Eb7JUBIOVVsMuMnAIGQSAel55p1YGjjX7y5TUNSmjsrd1ymmRIHZQehlkOfm9lwAeMt1rfoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiig9DQA0tziuc8H/wCp1rt/xOLr/wBDqzrEOvRzC90e7gcIuHsLlMJMQSflkHKMc45yOnFcb4Q1fWNeGrW2jQ/2cn9pTyXd3dxbmhdjnyVTIDOv8RJ2rkcNQBueJND1q+1sXmmJp8kbLaFhc3DxkG3uGl42owIbIGe3XBrrIDK0EbToiSlQXWNiygnrg4BIz3wKLeJ4reKOSVpXVQrSMAC5A5Y4459qlxzmgA24HU1z/iWz1i/axXTYLF1t7mO4c3Nw8ZJQ5AAWNs59e1dDSAADA6UAZGhaW+n+F7LSb7yppIrZYZgvKPxhsZHI69RUuj2M2l2EdhJL50Vu3l27n73lD7obPUjpnvgHua0to/8ArUBQBxQAm0e/XPWl24HFLRQBm3GmGc6gxndXu4BArj/lmoBwfrlmP4irkcSxoqquABtAAx0qXAowKd9LAZur2U2o2LWUU4hjuD5c0g++IyDu2f7RHGe2c84xV6C3itreOCBBHDEoREXgKoGAB+FSBQO5paQCUZrh/EnifXrDVL+DTE03yLMWQb7TG7OzXEpj42sBgYB6Vq634kk8JeFG1bW0W5kiZVkWyTaGLPtG0O2ehHU04xlOXLHdhsdHmlrL0HW7XxFodpqtnuENym4K+NynoVOO4II/Csvxl42sPBVjb3N7DPOZ5CiRW6gucAlmwSOBxn6iqjSnKp7JL3uwrq1zqKKgtrgXNtFOqkLIgcBuuCM81Nmo2dmMWim7u3f0ptxMtvbyzNnbGhY464AzRuA/NRzQRXCeXNGsiZDbXUEZByD9QQCK4jS/iPLrGmxalY+EtcnspM7ZYxCc4JBwDICeQRW/4e8Vad4kWcWZliubZ9lza3CGOaFvRl/z39DWk8PVpp8y2C5ubRnNLRRWYBRRRQAUVDdfaDayi0aJbjafLaZSUDY4yAQcfjXF6R4n8RS63Z22orpbW0+o3Ng32eORXBijkbeMuRg7OmO9AHdUVBd3DWtnNOsEk7RoWEUWN74GcDJAyfcge9cBcfGLS7TxAmg3Og69FqjlVW2eGFSxYZABMuOfrQB6NRXL+KPG0HhRLWS80jU7iK5ZY0a0jjf94xIWPBcEsfYGtbR9Vm1a3eWXSr7Ttr7RHeKgZhjOQEZsD64NAGlRRRQAUUUUAFFFFABRRRQAUUmeaWgAoorifF3ijW9Ivb6PS008xWWnLeSfao3YuWkddo2sMfcoA7aiqenf2gLQDUntXudxy1sjKmM8cMSc49652fx7DB4oXw4dC1Z9SeE3CRKsOGiBI35MuMZB64PtQB11FcrqfjVtHgW41Dw3rUMBkVDIEgkCliAM7JSRyfSodd1bxNY+ILaysn0g291HNJF58MhdPLVSQcOAc7vbFAHYUVm6BqUmr+HNM1KVVSS7tIrhlUcKXQMQPzqKy1l9R1S8itoQ1laEwvOTzJOOWRfZRwT/AHsj+E0Aa9Fec6x8Y9K8P38Fjq+g69Z3E6ho0lhhAYE4Bz5uOvvxXQa74yi8O6BHrN9o+pm3K7pkjWIvbjgDfmQDJJAG0mgDpqKxdB8QS66jSNomqadHtV0a+jRN4OegV2OfXIFbVABRWN4o1W60fw/Ne2awtcCSGNBMCUBeVUyQCDgbs9az/DWp+IdRv9QTUn0v7PZXL2zC2hkV3YIrAgliMfN6UAdRS1yXhzx9pviXX9T0a2guIbqwZg3nBQJArlCVwTwDjr6iumuLiK0tZridwkMKNI7noFAyT+VXUpTpy5Jqz/zDQmIB+vrUcUEMG/yokTexd9qgbmPUn1PvXOeDfG1l40s7m5s7W5t1t5BGRcKAWJAORgnjBrp80qtOdKXJPRgtVcMCloppb6VICnNGa5TXfG8ei+I7fQotIv8AUL2e3+0qttswEyR/Ew/umo4/iBbQXsFrrGkapo/nuI45ryFfJZz0XejMAT74rZYaq0pW0YrnYUU0NkUorAYtFFFMAoorlNf1PxJZa5ptrp76V9n1CcwR/aIZGdCsLyEkhwCPkI6dxQB1dFZHhjVZ9a8NafqNykaT3EQd1jBCg98ZJ4/GnXesz21y8KaNqNwq4/ewrGUbjPGXB9ulAHGeJh/xN/EX+9ov/pWan+M3Hw2vcHH76D/0YtQeJ/8AkL+I/wDe0X/0rap/jNz8Nb3/AK7QY/7+r2710YX+PH1E9iXwcTonivX/AAw42wmT+07FT/zylPzqPQK+f++q4/4hH/hIB4u1M/NZ6Japp9sTyPPd0aUj3A2rXW/EBLvSrnSPFmm2slzc6e7QTwxKSZIZFI6AEnDbT+NYuu6NLonwFvoLnP26eJbm7LD5jNJIrNn3BOPwrvpSXPGvfWTS+fX8PzIa6HpWkAf2NZY/594+n+6Kr6t4hsNFEa3cpNxMcQ2sKmSaY+iIOT9eg7461Y0cg6LY4IINvH/6CKxr/wAMTw61ca/oNytvqc6KlxHcgyQ3KqOFP8SY7FSB6g9K8up8b9S1sUn1XxL/AG9oEt1Fb6fp97etbmwwJJ2X7PM4aRwdqkGNflXPXlj0rq9T50q8/wCuL9Poa4u912W98S+FdO1DT7iw1GPU3kMTjfFIotbgFo5AMMMsODhhnkDrXZ6p/wAgm8/64P8A+gmin8aGeUfDPx54Y0T4e6Zp+o6vDBdReaXjKsSMyuR0HPUfnWx4Zkk1bx9q3jJYJLLRPsC2sclwpjNwVO4y7T0UAEZP+OLPwaA/4VjpeR0abr/11auu1/TW1bw5qenRyCN7q0lgVyeFLKQCfzrur1YRrzjFW5nZv5kJaHJ23izxbrdodY0LQrF9IJJgju7ho7i5QfxKACq5wcZ+tWL34iQHwlp2saZa+dNqN2ljDBO3l+XMxIxIedoXac/T3rH8OfEDR/D/AIWtNI14y2GrabCttJYtCxkcqNqlMD5g2Bgj19Oaq6ZYaZpXw7uD44s3itdX1KS6kiaNibUycruK8pjb1HQnBxzVulBP3o6J2Vuq/ULs7XRrrxcb8Ra3Y6T9lZCwnsZ3JVuMKVdec56g9qZo/iW+1HxXq+i3Gn28K6ckZM0Vw0m4yAlRgouDgds1xHhGa0svHlrp/hHW73U9De3le+hmYyRWxH3NjEDBJ4x9au+CdVnns9b1PTbNru/1bUZZY2YFYoolOyPzHxjgAnaPmIPTnNRVoJczstlbpuwTOztvERvPGF5oVvbb4rO1SW4uQ/3JHPyx49doLZz6VytgP+Kh0r/sZtR/9ETV1vhzQU0KykRpWuLu4lM93dOMNNIepx2HQAdgK5Kw/wCRh0v/ALGXUf8A0RNXBUcea0Cz0ftXmPxj8Cx+JfD7avaMsGraVGZY5d+3dGvzFS3buR6HPrXot9qFrpllLeX08dvbxLuklkOFUe5rzXUPFuiePfFlr4WttVg/sdMTXfzYN+/VIEz1QYy578L3qQMz4TeIH+IOpLqWvXkc2paLCsVtZquANww1y3Yufu8cL6DcK9mxXzx8TrSL4c/ELT/Ffhye3huZzvudNDAFgchjt/uvtIPoRnqRj2bwv420TxdaRS6ZeRvO0Qllttw8yHPBDD2PGelAHRU0NkZFOrD1Dwnpup3r3dxNqYlcAHyNTuIV4GOFRwo6dhQBuZpM1zX/AAgejf8APfWv/B3ef/HaP+ED0b/nvrX/AIO7z/47QB0uaM1zH/CCaP8A899Z/wDB3ef/AB2j/hBNHxxPrP8A4O7z/wCO0AdPmjPFcufA2ig4+0az/wCDu7/+O04eBdHz/r9a/wDB1ef/AB2jyYFvxHqVzotta6igBsoLgfb8jJWAqVLj/dJVj7A1sRTJNEkkbq8bgMjqchgeQQe/FcH4j8L6fp1lBBYPq8uo30wtbVX1m8KBiCS7AS/dVFZiO+Md63/B/hKy8HaKum2c1zMNxeR55S2WPXA6KPYAe+TQB0PWvN/HI/03xL3/AOKfhz7/AL+WvSK848cgm+8SgDJ/4R+Hj/tvLQB6N2ryTw7rVpJ8WPGOvXMV68NsI9Mt3trGa4ACcygmJGA+ZQefWvRPEHiTS/DmmTXeo3tvAFjd445ZVVpiq52oDyx9hmuK+Cc9kfBKAahaz6peXE17eRRyqzozPtyyg5HCr1oA6rSryLxl4YS6kRo7S6k3wqRtYxLJ8pbOeWCZ9s461X8RqD4q0QHkfZb7/wBASuktLOCws4LS2Ty4IEWONQc4UDA+vHrXOeIv+Rq0T/r1vv8A0BKAIdM1I6P8H7LVRgvaaDHOuR1KwBh+orS8G2H9meDNItjnzBao8zE5LSMNzsfcsWP41hfYpNQ+BKWcILSy+HFVFHUt9nGB+JxXRaBqEE/hDTNRMirbvYxTFyeFXYCT+VAGL8SPA1t458MyWZCR38GZLOdv4HxypPZWxg/ge1eX/CzXZvGWpWHhvxLexumhKZbW1breSKSFLno3ljoO/U52mux8TfEDRfEOoWXhbSdet4or44vr9JMbIenlRt/z0cnb/sgk1y3xk8MWHhWbSPE/h6e30vUbUpGlshCGZUwAyDuVBVT6gj0oA95AyQadXF+BviLo/jHTLIrcxQ6tKjebYlsOGX7xAPVe+fQ+xrW0TxZp2v6rq+nWi3C3GlT+RcCWLaCeRlfUZU//AKiKAIfHX/IqSH0u7T/0pipPCv8Ax9eJOv8AyF3/APRUVL46/wCRUk/6+rT/ANKIqTwr/wAffiX/ALDEn/oqKgDyvRM6LPceK0+WOx8UXVreen2ebYpJ9drbTXoXxFnkutKsvDlq5FzrlytrlTgrCPmlb6BAR+NYvgXSYNc8LeMtLuMeVda1exE/e25CjP1Bwfwo+H9vq+sa6uo65aTQSaJZjTIhKP8AWTZ/eyj6hV5969mvKMqjqN6w/Ht+JnqXPhnBHbav4yhiRUij1dkVV4AAXAH6V6BLKkETSyuscaDczscBR6knpXBfDvH/AAkHjUjvrL8/hXXa9oFj4j0mTTtQWQwsyuCjbWVlOQw7HB7EEHuDXBjneu232/IuOiMpvEd9rhMPhe2SWHJVtUugRbD3jA+ab6jC/wC12q34QvrvUfC1ndX83nXTb1kkCBN5V2GcDp0qgL/W/DgEerwHVdNX/l+sof30Q9ZYV6gD+KMdvuipPh9KsvgfTpI+VcSMpxjIMjEVyjOS8Uaxp+g/G3SL7U7mO1tl0lkMj9Ml3wOOf0o8aeJtM8ceH5vDfhsPqt7evGm6OFhHbgMGLuxAAwB25q3quD8ftE7/APEokyP+BSV6RtA6V6FWrCn7KTV2orr5si25yOp+Ib7TLyw8NaPapqWttbiR2nk8uKGMYXzJCATyegA5pdI8U6nF4gj0DxNY21rfTxNLa3FpIXguQv3lXcAQw64Pb9cfWLkeD/iXJ4g1JHXRtQsltWuljLi2kVuA2BlVPr0z9KhfUIPHXxD0K50MvPpuiedLcXoQhGd12iNCep4ye2O9P2UHHbRq9/P/AIfSw7s0LPxX4q8Qm8vNA0/SBp9tcvbhb24dZpShwT8qlVz2BJrS8U+KNT8OeHLXUl0u2mnlaKOW2e6KlZHIAVSEIfkn+7wM1594jm8BNNqWrabrN9oviBSzNHamSN5JuwMZHzZOPu4Bz1rY1TUru9fwBZa0rpcsw1K9VIyW3xJlflUZJZ2+6B1zxxVyoQk4ySsu1tdvx9RXZ3PifxCPDfh641N4PPlQKsVurYMsjEKqg+5NU9bZ317wezqFc30u4A5AP2SfIz9aaml3XiDWrTU9Vha3sbJ/MsrJzlmk6CaTsCATtXtnJOThZvEGP+El8Jf9hCb/ANJJ68+aikorfr/kWJ4BH/FCaQOn7j+projGpOSW/BiK57wD/wAiLpH/AFw/qafqPjfw3pN/LY3+uWFtcxY3xSyqGXIBGQT6EGswOa8R/wDIa8Q/7+if+lZrv3+5JRRQugDm7/hQ33D/AJ70UU10DqKv+sP0FJJ94fQ0UUgWw8feP1/pSnoaKKAIk/1Q+o/nUtFFOW4GbP8A8hO2/wCBf1qeb/Uf8A/woorSX2f67j7GdoP+quv+uzfzrXX/AFy/Q/0ooqsR/EkIWP8Aq38688sf+Rg0v/sZdR/9ETUUVz9gR6In+pX8P50o+7/wKiimAJ0pn/Lc/wC8P/QTRRQBNRRRQAU1/uN9KKKAGf8ALRfpTj90f57UUVTGclc/8lT0j/sDXX/o2CutPb6n+tFFXV+z6CKN7/yE9N/67v8A+imrR70UVkAV5t47/wCPvxN/2L0P/o6WiigD0de/1/pQf9av+6f6UUUAOrlPEf8AyNWif9et9/6AlFFAFzwd/wAiD4f/AOwXbf8Aopaz/hj/AMk38P8A/Xv/AFNFFAHVH/Vr+P8AI0if638W/pRRQAq/c/Ef0rPt/wDkZL7/AK9Lf/0ZPRRQBQ8df8ipJ/19Wn/pRFSeFf8Aj68S/wDYXk/9FRUUUAbo/wBYv+81K/8AqpP9w/yooqmNir/rD/vf0qX+H8KKKmXxCEb7y/Wkbov+e1FFAEafdX6CplooqZfGCIZv9XJ/u/41Bpv/ACCrb/rkv8qKK2X8N+ouhn3v/Ietfqf5Vrf8tF/3KKK1qbQ9Bj07fh/KsDxD/wAjL4S/7CE3/pJPRRXKgQeAf+RF0j/rh/U1vN96iimB/9k="
      }
    },
    {
      "section_id": 11,
      "text": "# 4.1 The absence of UIP and Agda's termination checker \n\nOne of the key contributions of this paper is the fact we were able to formalise Lemma 16 without using UIP. Our main difficulty was proving the technical Lemma 17 which essentially says that fstEq is coinductively defined in the obvious manner. In theory, Cubical Agda should allow us to define fstEq as\n\n$$\n\\begin{aligned}\n& \\text { shape }(\\text { fstEq } y i)=\\text { comm }_{i} y i \\\\\n& \\text { pos }(\\text { fstEq } y i)=\\text { fstEqPos } i\n\\end{aligned}\n$$\n\nwhere we recall that fstEqPos is defined by coinductively calling fstEq as in (6). This construction would make Lemma 17 hold definitionally, without requiring any form of UIP.\n\n[^0]\n[^0]:    ${ }^{7}$ Formally, we define $\\operatorname{tr} y=\\operatorname{transport}\\left(\\lambda i \\rightarrow\\right.$ Pos $\\left.\\nu\\right.$ ind $\\left((\\operatorname{fstEq} y)^{-1} i\\right)$ ).\n\nThere are, however, two issues with it. Firstly, Agda does not accept this definition and raises a termination checking error. We believe this to be an issue with Cubical Agda's current termination checker. Generally speaking, in order to check whether a corecursive function terminates, Agda needs to ensure its output can be produced in a finite amount of steps. We call such functions productive. In the cases when it is not obvious from the structure of the code that it is productive, e.g. if we make a corecursive call and do something else with it before returning, rather then returning directly, Agda usually raises a termination error. While this is justified in general, composing productive calls using Cubical Agda's primitive path composition function, hcomp, should be productive, but Agda still raises an error. This was raised as a GitHub issue [6].\n\nIf the first issue were to be resolved, our proof of Theorem 14 could be made significantly shorter, as we would not need to use M's coinduction principle MCoind in the definition of fstEq. Nevertheless, there is another issue with such a construction of fstEq, namely that it relies heavily on the intricacies of cubical type theory (specifically when we introduce a path variable $i$ and then copattern match). As a result, we could not expect to reproduce such a proof in other non-cubical type theories. Therefore, from a mathematical perspective, the issue we faced with the termination checker may have been a blessing in disguise. Our original motivation behind formalising Lemma 16 was to support the claim by Abbott et al. [3] that the theory of containers can be understood in type theory. Here, we aim to interpret type theory as generally as possible, rather than restricting ourselves to cubical type theory. Since we had to define fstEq using MCoind rather than the Cubical Agda-specific construction above, our proofs should hold in the same type theory used by e.g. Seely and Hofmann $[15,22]$. The fact that the authors of [3] never mention any results akin to Lemma 17 suggests that they worked under a tacit assumption of UIP, which is further evidence that our formalisation indeed is a generalisation of previous results.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 12,
      "text": "# 5. Conclusion \\& Related Work \n\nIn this paper, we presented a formalisation of the following results on containers.\n[W $S Q \\triangleleft$ Pos WAlg $] \\mathbf{X}$ is the initial $\\llbracket S \\triangleleft \\mathbf{P}, Q \\rrbracket(\\mathbf{X},-)$-algebra, and\n[M $S Q \\triangleleft$ Pos MAlg $] \\mathbf{X}$ is the terminal $\\llbracket S \\triangleleft \\mathbf{P}, Q \\rrbracket(\\mathbf{X},-)$-coalgebra.\nWhile the first proof is relatively straightforward, the second proof needs more careful consideration. In particular, it uses a modified version of Pos's induction principle and also exposes an issue in Agda's current termination checker that meant we had to come up with various workarounds. Our formalisation presents results on containers that were previously done in the categorical language of LCCCs in intensional type theory, and demonstrates how Cubical Agda's path type enables proofs on coinductive types.\n\nThe formalisation of the results presented in this paper is part of a bigger ongoing formalisation effort covering most of the existing literature on containers; however, the latter result presented here was easily the most challenging one yet. Our survey of the results on containers was originally motivated by our ongoing work on generalising containers to provide a canonical way to represent quotient inductive and quotient inductive-inductive specifications that admit an initial algebra, i.e. the strictly positive ones. This parallels the way that containers and indexed containers provide canonical representations for strictly positive ordinary inductive types and inductive families respectively. As a first step to this generalisation, we worked out a number of restrictions to be applied to the semantics given in [7], with the main restriction being that functors encoding constructors of a type ought\n\nto be container functors [8]. Due to the type of these functors being more general than the literature on containers currently covers, 'generalised containers' were defined, which differ from ordinary containers in that they are parameterised over a category C, and the positions $P$ are a family over $S$ of objects of C (as opposed to being a family of h-sets). This was another motivation for us not to assume UIP and to work in Cubical Agda for this formalisation: we are interested in inductive types with equality constructors, for which Cubical Agda offers native support, and we hope to eventually adapt our ideas to the general class of higher inductive types, which obviously contradict UIP. For our approach in [8] to fully make sense, a prerequisite is having a container model of type theory, whose objects are ordinary containers and whose types are generalised containers $[9,13]$. This is another avenue that we are currently looking into.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 13,
      "text": "# References \n\n1 Michael Abbott, Thorsten Altenkirch, and Neil Ghani. Categories of containers. In Andrew D. Gordon, editor, Foundations of Software Science and Computation Structures, pages 23-38, Berlin, Heidelberg, 2003. Springer Berlin Heidelberg.\n2 Michael Abbott, Thorsten Altenkirch, and Neil Ghani. Representing nested inductive types using W-types. In Automata, Languages and Programming, 31st International Colloqium (ICALP), pages 59 - 71, 2004.\n3 Michael Abbott, Thorsten Altenkirch, and Neil Ghani. Containers: Constructing strictly positive types. Theoretical Computer Science, 342(1):3-27, 2005. Applied Semantics: Selected Topics. doi:https://doi.org/10.1016/j.tcs.2005.06.002.\n4 Michael Gordon Abbott. Categories of Containers. PhD thesis, University of Leicester, 2003.\n5 Benedikt Ahrens, Paolo Capriotti, and R\u00e9gis Spadotti. Non-wellfounded trees in homotopy type theory. In Thorsten Altenkirch, editor, 13th International Conference on Typed Lambda Calculi and Applications (TLCA 2015), volume 38 of Leibniz International Proceedings in Informatics (LIPIcs), pages 17-30, Dagstuhl, Germany, 2015. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik. doi:10.4230/LIPIcs.TLCA.2015.17.\n6 Thorsten Altenkirch. Cubical primitives should preserve guardedness. https://github.com /agda/agda/issues/4740, 2020. Online.\n7 Thorsten Altenkirch, Paolo Capriotti, Gabe Dijkstra, Nicolai Kraus, and Fredrik Nordvall Forsberg. Quotient Inductive-Inductive Types, page 293-310. Springer International Publishing, 2018. URL: http://dx.doi.org/10.1007/978-3-319-89366-2_16, doi: 10.1007/978-3-319-89366-2_16.\n\n8 Thorsten Altenkirch and Stefania Damato. Specifying QIITs using Containers, 2023. Talk abstract at HoTT/UF 2023, available at https://stefaniatadama.com/talks/abstract_ho tt_uf_2023.pdf.\n9 Thorsten Altenkirch and Ambrus Kaposi. A container model of type theory, 2021. Talk abstract at TYPES, available at https://types21.liacs.nl/download/a-container-model -of-type-theory/.\n10 Joshua Chen. 2-coherent internal models of homotopical type theory, 2025. arXiv:2503.05790.\n11 Cyril Cohen, Thierry Coquand, Simon Huber, and Anders M\u00f6rtberg. Cubical Type Theory: A Constructive Interpretation of the Univalence Axiom. In Tarmo Uustalu, editor, 21st International Conference on Types for Proofs and Programs (TYPES 2015), volume 69 of Leibniz International Proceedings in Informatics (LIPIcs), pages 5:1-5:34, Dagstuhl, Germany, 2018. Schloss Dagstuhl-Leibniz-Zentrum fuer Informatik. doi:10.4230/LIPIcs.TYPES. 2015. 5.\n\n12 Thierry Coquand, Simon Huber, and Anders M\u00f6rtberg. On higher inductive types in cubical type theory. In Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science, LICS '18, page 255-264, New York, NY, USA, 2018. Association for Computing Machinery. doi:10.1145/3209108.3209197.\n\n13 Stefania Damato and Thorsten Altenkirch. Coherences for the Container Model of Type Theory, 2024. Talk abstract at HoTT/UF 2024, available at https://stefaniatadama.com/t alks/abstract_hott_uf_2024.pdf.\n14 Nicola Gambino and Martin Hyland. Wellfounded trees and dependent polynomial functors. In Stefano Berardi, Mario Coppo, and Ferruccio Damiani, editors, Types for Proofs and Programs, pages 210-225, Berlin, Heidelberg, 2004. Springer Berlin Heidelberg.\n15 Martin Hofmann. On the interpretation of type theory in locally cartesian closed categories. In Selected Papers from the 8th International Workshop on Computer Science Logic, CSL '94, page 427-441, Berlin, Heidelberg, 1994. Springer-Verlag.\n16 Nicolai Kraus and Jakob von Raumer. Path spaces of higher inductive types in homotopy type theory. In Proceedings of the 34th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS '19. IEEE Press, 2021.\n17 Joachim Lambek. A fixpoint theorem for complete categories. Mathematische Zeitschrift, 103:151-161, 1968. URL: http://eudml.org/doc/170906.\n18 Peter LeFanu Lumsdaine and Michael Shulman. Semantics of higher inductive types. Mathematical Proceedings of the Cambridge Philosophical Society, 169(1):159-208, 2020. doi:10.1017/S030500411900015X.\n19 Per Martin-L\u00f6f. An intuitionistic theory of types. Twenty-Five Years of Constructive Type Theory, 1972.\n20 Per Martin-L\u00f6f. Intuitionistic type theory, 1984. Notes by Giovanni Sambin, available at https://archive-pml.github.io/martin-lof/pdfs/Bibliopolis-Book-1984.pdf.\n21 Per Martin-L\u00f6f. Constructive mathematics and computer programming. In L. Jonathan Cohen, Jerzy \u0141o\u015b, Helmut Pfeiffer, and Klaus-Peter Podewski, editors, Logic, Methodology and Philosophy of Science VI, volume 104 of Studies in Logic and the Foundations of Mathematics, pages 153-175. Elsevier, 1982. doi:https://doi.org/10.1016/S0049-237X(09)70189-2.\n22 R.A.G. Seely. Locally cartesian closed categories and type theory. Mathematical Proceedings of the Cambridge Philosophical Society, 95:33-48, 1984.\n23 The Agda Community. Cubical Agda Library, March 2025. URL: https://github.com/agd a/cubical.\n24 The Univalent Foundations Program. Homotopy Type Theory: Univalent Foundations of Mathematics. https://homotopytypetheory.org/book, Institute for Advanced Study, 2013.\n25 Benno van den Berg and Federico De Marchi. Non-well-founded trees in categories. Annals of Pure and Applied Logic, 146(1):40-59, 2007. doi:https://doi.org/10.1016/j.apal.2006. 12.001.\n\n26 Andrea Vezzosi, Anders M\u00f6rtberg, and Andreas Abel. Cubical Agda: A dependently typed programming language with univalence and higher inductive types. Journal of Functional Programming, 31:e8, 2021. doi:10.1017/S0956796821000034.\n27 Vladimir Voevodsky. The equivalence axiom and univalent models of type theory. (Talk at CMU on February 4, 2010), 2014. arXiv:1402.5556.",
      "tables": {},
      "images": {}
    }
  ],
  "id": "2409.02603v3",
  "authors": [
    "Stefania Damato",
    "Thorsten Altenkirch",
    "Axel Ljungstr\u00f6m"
  ],
  "categories": [
    "cs.LO",
    "math.LO"
  ],
  "abstract": "Containers capture the concept of strictly positive data types in\nprogramming. The original development of containers is done in the internal\nlanguage of locally cartesian closed categories (LCCCs) with disjoint\ncoproducts and W-types, and uniqueness of identity proofs (UIP) is implicitly\nassumed throughout. Although it is claimed that these developments can also be\ninterpreted in extensional Martin-L\\\"of type theory, this interpretation is not\nmade explicit. In this paper, we present a formalisation of the results that\n'containers preserve least and greatest fixed points' in Cubical Agda, thereby\ngiving a formulation in intensional type theory. Our proofs do not make use of\nUIP and thereby generalise the original results from talking about container\nfunctors on Set to container functors on the wild category of types. Our main\nincentive for using Cubical Agda is that its path type restores the equivalence\nbetween bisimulation and coinductive equality. Thus, besides developing\ncontainer theory in a more general setting, we also demonstrate the usefulness\nof Cubical Agda's path type to coinductive proofs.",
  "updated": "2025-04-07T18:13:28Z",
  "published": "2024-09-04T10:37:21Z"
}