{
  "title": "Regular Languages in the Sliding Window Model",
  "sections": [
    {
      "section_id": 0,
      "text": "#### Abstract\n\nWe study the space complexity of the following problem: For a fixed regular language $L$, we receive a stream of symbols and want to test membership of a sliding window of size $n$ in $L$. For deterministic streaming algorithms we prove a trichotomy theorem, namely that the (optimal) space complexity is either constant, logarithmic or linear, measured in the window size $n$. Additionally, we provide natural language-theoretic characterizations of the space classes. We then extend the results to randomized streaming algorithms and we show that in this setting, the space complexity of any regular language is either constant, doubly logarithmic, logarithmic or linear. Finally, we introduce sliding window testers, which can distinguish whether a sliding window of size $n$ belongs to the language $L$ or has Hamming distance $>\\epsilon n$ to $L$. We prove that every regular language has a deterministic (resp., randomized) sliding window tester that requires only logarithmic (resp., constant) space.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 1,
      "text": "## 1. Introduction\n### 1.1 The sliding window model\n\nStreaming algorithms process a data stream $a_{1} a_{2} a_{3} \\cdots$ of elements $a_{i}$ from left to right and have at time $t$ only direct access to the current element $a_{t}$. In many streaming applications, elements are outdated after a certain time, i.e., they are no longer relevant. The sliding window model is a simple way to model this. A sliding window algorithm computes for each time instant $t$ a value that only depends on the relevant past (the so-called active window) of $a_{1} a_{2} \\cdots a_{t}$. There are several formalizations of the relevant past. One way to do this is to fix a window size $n$.\n\n[^0]\n[^0]:    Cite as Moses Ganardi, Danny Hucke, Markus Lohrey, Konstantinos Mamouras, Tatiana Starikovskaya. Regular Languages in the Sliding Window Model. TheoretiCS, Volume 4 (2025), Article 8, 1-75.\n\nThen the active window consists at each time instant $t$ of the last $n$ elements $a_{t-n+1} a_{t-n+2} \\cdots a_{t}$ (here we assume that $a_{i}$ is a fixed padding symbol if $i \\leqslant 0$ ). In the literature this is also called the fixed-size model. Another sliding window model that can be found in the literature is the variable-size model; see e.g. [7]. In this model, the arrival of new elements and the expiration of old elements can happen independently, which means that the window size can vary. ${ }^{1}$ This allows to model for instance time-based windows, where data items arrive at irregular time instants and the active window contains all data items that arrive in the last $n$ seconds for a fixed $n$. The special case of the variable-size model, where old symbols do not expire, is the classical streaming model.\n\nA general goal in the area of sliding window algorithms is to avoid the explicit storage of the active window, which would require $\\Omega(n)$ space for a window size $n$, and, instead, to work in considerably smaller space, e.g. polylogarithmic space with respect to the window size $n$. A detailed introduction into the sliding window model can be found in [1, Chapter 8].\n\nThe (fixed-size) sliding window model was introduced in the seminal paper of Datar et al. [27] where the authors considered the basic counting problem: Given a window size $n$ and a stream of bits, maintain a count of the number of 1's in the window. One can easily observe that an exact solution would require $\\Theta(n)$ bits. Intuitively, the reason is that the algorithm cannot see the bit which is about to expire (the $n$-th most recent bit) without storing it explicitly; this is in fact the main difficulty in most sliding window algorithms. However, Datar et al. show that with $O\\left(\\frac{1}{\\epsilon} \\cdot \\log ^{2} n\\right)$ bits one can maintain an approximate count up to a multiplicative factor of $1 \\pm \\epsilon$. In Section 1.3.6 below we briefly discuss further work on sliding window algorithms.\n\nA foundational problem that has been surprisingly neglected so far is the language recognition problem over sliding windows: Given a language $L \\subseteq \\Sigma^{*}$ and a stream of symbols over a finite alphabet $\\Sigma$, maintain a data structure which allows to query membership of the active window in $L$. In other words, we want to devise a streaming algorithm which, after every input symbol, either accepts if the current active window belongs to $L$, or rejects otherwise. This problem finds applications in complex event processing, where the goal is to detect patterns in data streams. These patterns are usually described in some language based on regular expressions; see e.g. $[26,89]$ for more details. For the standard streaming model, where input symbols do not expire, some work on language recognition problems has been done; see Section 1.3.7 below.\n\nEXAMPLE 1.1. Consider the analysis of the price of a stock in order to identify short-term upward momentum. The original stream is a time series of stock prices, and it is pre-processed in the following way: over a sliding window of 5 seconds compute the linear regression of the prices and discretize the slope into the following values: $\\mathrm{P}_{2}$ (high positive), $\\mathrm{P}_{1}$ (low positive), Z (zero), $\\mathrm{N}_{1}$ (low negative), $\\mathrm{N}_{2}$ (high negative). This gives rise to a derived stream of symbols in\n\n[^0]\n[^0]:    1 The reader can also think of a queue data structure, where letters can be added to the right and removed at the left, the latter without retrieving the identity of the letter.\n\nthe alphabet $\\Sigma=\\left\\{\\mathrm{P}_{2}, \\mathrm{P}_{1}, \\mathrm{Z}, \\mathrm{N}_{1}, \\mathrm{~N}_{2}\\right\\}$, over which we describe the upward trend pattern: (i) no occurrence of $\\mathrm{N}_{2}$, (ii) at most two occurrences of $\\mathrm{N}_{1}$, (iii) and any two occurrences of Z or $\\mathrm{N}_{1}$ are separated by at least three positive symbols. The upward trend pattern can be described as the intersection of the language defined by the following regular expression $e_{i i}$ and the complement of the language defined by $e_{i}$ :\n\n$$\n\\begin{aligned}\n& e_{i}=\\Sigma^{*} \\cdot \\mathrm{~N}_{1} \\cdot \\Sigma^{*} \\cdot \\mathrm{~N}_{1} \\cdot \\Sigma^{*} \\cdot \\mathrm{~N}_{1} \\cdot \\Sigma^{*} \\\\\n& e_{i i}=\\left(\\mathrm{P}_{2}+\\mathrm{P}_{1}\\right)^{*} \\cdot\\left(\\left(\\mathrm{Z}+\\mathrm{N}_{1}\\right) \\cdot\\left(\\mathrm{P}_{2}+\\mathrm{P}_{1}\\right) \\cdot{ }^{[3, \\infty)}\\right)^{*} \\cdot\\left(\\varepsilon+\\mathrm{Z}+\\mathrm{N}_{1}\\right) \\cdot\\left(\\mathrm{P}_{2}+\\mathrm{P}_{1}\\right)^{*}\n\\end{aligned}\n$$\n\nWe want to monitor continuously whether the window of the last hour matches the upward trend pattern, as this is an indicator to buy the stock and ride the upward momentum. Our results will show that there is a space efficient streaming algorithm for this problem, which can be synthesized from the regular expressions $e_{i}$ and $e_{i i}$.\n\nIn this paper we focus on querying regular languages over sliding windows. Unfortunately, there are simple regular languages which require $\\Omega(n)$ space in the sliding window model, i.e., one cannot avoid maintaining the entire window explicitly. However, for certain regular languages, such as for the upward trend pattern from above, we present sublinear space streaming algorithms. Before we explain our results in more detail, let us give examples of sliding window algorithms for simple regular languages.\n\nEXAMPLE 1.2. Let $\\Sigma=\\{a, b\\}$ be the alphabet. In the following examples we refer to the fixed-size sliding window model.\n(i) Let $L=\\Sigma^{*} a$ be the set of all words ending with $a$. A streaming algorithm can maintain the most recent symbol of the stream in a single bit, which is also the most recent symbol of the active window. Hence, the space complexity of $L$ is $O(1)$ in the sliding window model.\n(ii) Let $L=\\Sigma^{*} a \\Sigma^{*}$ be the set of all words containing $a$. If $n \\in \\mathbb{N}$ is the window size, then a streaming algorithm can maintain the position $1 \\leqslant i \\leqslant n$ (from right to left) of the most recent $a$-symbol in the active window or set $i=\\infty$ if the active window contains no $a$-symbols. Let us assume that the initial window is $b^{n}$ and initialize $i:=\\infty$. On input $a$ we set $i:=1$ and on input $b$ we increment $i$ and then set $i:=\\infty$ if $i>n$. The algorithm accepts if and only if $i \\leqslant n$. Since the position $i$ can be stored using $O(\\log n)$ bits, we have shown that $L$ has space complexity $O(\\log n)$ in the sliding window model.\n(iii) Let $L=a \\Sigma^{*}$ be the set of all words starting with $a$. We claim that any (deterministic) sliding window algorithm for $L$ and window size $n \\in \\mathbb{N}$ (let us call it $\\mathcal{P}_{n}$ ) must store at least $n$ bits, which matches the complexity of the trivial solution where the window is stored explicitly. More precisely, the claim is that $\\mathcal{P}_{n}$ reaches two distinct memory states on any two distinct words $x=a_{1} \\cdots a_{n} \\in \\Sigma^{n}$ and $y=b_{1} \\cdots b_{n} \\in \\Sigma^{n}$. Suppose that $a_{i} \\neq b_{i}$. Then we simulate $\\mathcal{P}_{n}$ on the streams $x b^{i-1}$ and $y b^{i-1}$, respectively. The suffixes\n\n(or windows) of length $n$ for the two streams are $a_{i} \\cdots a_{n} b^{i-1}$ and $b_{i} \\cdots b_{n} b^{i-1}$. Since exactly one of the two windows belongs to $L$, the algorithm $\\mathcal{P}_{n}$ must accept exactly one of the streams $x b^{i-1}$ and $y b^{i-1}$. In particular, $\\mathcal{P}_{n}$ must reach two distinct memory states on the words $x b^{i-1}$ and $y b^{i-1}$, and therefore $\\mathcal{P}_{n}$ must have also reached two distinct memory states on the prefixes $x$ and $y$, as claimed above. Therefore, $\\mathcal{P}_{n}$ must have at least $\\left|\\Sigma^{n}\\right|=2^{n}$ memory states, which require $n$ bits of memory.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 2,
      "text": "# 1.2 Results \n\nLet us now present the main results of this paper. The precise definitions of all used notions can be found in the main part of the paper. We denote by $\\mathrm{F}_{L}(n)$ (resp., $\\mathrm{V}_{L}(n)$ ) the space complexity (measured in bits) of an optimal sliding window algorithm for the language $L$ in the fixed-size (resp., variable-size) sliding window model. Here, $n$ denotes the fixed window size for the fixed-size model, whereas for the variable-size model $n$ denotes that maximal window size among all time instants when reading an input stream.\n\nOur first result is a trichotomy theorem for the sliding window model, stating that the deterministic space complexity is always either constant, logarithmic, or linear. This holds for both the fixed- and the variable-size model. Furthermore, we provide natural characterizations for the three space classes. For this, we need the following language classes:\n\n- Reg is the class of all regular languages.\n- Len is the class of all regular length languages, i.e., regular languages $L \\subseteq \\Sigma^{*}$ such that for every $n \\geqslant 0$, either $\\Sigma^{n} \\subseteq L$ or $\\Sigma^{n} \\cap L=\\emptyset$.\n- ST is the class of all suffix testable languages [79, Section 5.3], i.e., finite Boolean combinations of languages of the form $\\Sigma^{*} w$ where $w \\in \\Sigma^{*}$ (note that these languages are regular). ${ }^{2}$\n- LI is the class of all regular left ideals, i.e., languages of the form $\\Sigma^{*} L$ for $L \\subseteq \\Sigma^{*}$ regular.\n\nWe emphasize that the three defined language properties only make sense with respect to an underlying alphabet. If $\\mathbf{L}_{1}, \\ldots, \\mathbf{L}_{n}$ are classes of languages over some alphabet $\\Sigma$, then $\\left\\langle\\mathbf{L}_{1}, \\ldots, \\mathbf{L}_{n}\\right\\rangle$ denotes the Boolean closure of the classes $\\mathbf{L}_{1}, \\ldots, \\mathbf{L}_{n}$, which is the class of all finite Boolean combinations of languages $L \\in \\bigcup_{i=1}^{n} \\mathbf{L}_{i}$. We also use the following asymptotic notation in our results: For functions $f, g: \\mathbb{N} \\rightarrow \\mathbb{R}_{\\geqslant 0}, f(n)=\\Omega^{\\infty}(g(n))$ holds if $f(n) \\geqslant c \\cdot g(n)$ for some $c>0$ and infinitely many $n \\in \\mathbb{N}$. Furthermore, $f(n)=\\Theta^{\\infty}(g(n))$ holds if $f(n)=\\mathcal{O}(g(n))$ and $f(n)=\\Omega^{\\infty}(g(n))$. Now we can state our first main result.\n\n[^0]\n[^0]:    2 For the results presented in this section, one could equivalently define ST as the class of all languages $\\Sigma^{*} w$ without taking the Boolean closure.\n\nTHEOREM 1.3. Let $L \\subseteq \\Sigma^{*}$ be regular. The space complexity $\\mathrm{F}_{L}(n)$ is either $\\Theta(1), \\Theta^{\\infty}(\\log n)$, or $\\Theta^{\\infty}(n)$. Moreover, we have:\n\n$$\n\\begin{array}{ll}\n\\mathrm{F}_{L}(n)=\\Theta(1) & \\Longleftrightarrow L \\in\\langle\\mathbf{S T}, \\text { Len }\\rangle \\\\\n\\mathrm{F}_{L}(n)=\\Theta^{\\infty}(\\log n) & \\Longleftrightarrow L \\in\\langle\\mathbf{L I}, \\text { Len }\\rangle \\backslash\\langle\\mathbf{S T}, \\text { Len }\\rangle \\\\\n\\mathrm{F}_{L}(n)=\\Theta^{\\infty}(n) & \\Longleftrightarrow L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{L I}, \\text { Len }\\rangle\n\\end{array}\n$$\n\nThe space complexity $\\mathrm{V}_{L}(n)$ is either $\\Theta(1), \\Theta(\\log n)$, or $\\Theta(n)$. Moreover, we have:\n\n$$\n\\begin{array}{ll}\n\\mathrm{V}_{L}(n)=\\Theta(1) & \\Longleftrightarrow L \\in\\left\\{\\emptyset, \\Sigma^{*}\\right\\} \\\\\n\\mathrm{V}_{L}(n)=\\Theta(\\log n) & \\Longleftrightarrow L \\in\\langle\\mathbf{L I}, \\text { Len }\\rangle \\backslash\\left\\{\\emptyset, \\Sigma^{*}\\right\\} \\\\\n\\mathrm{V}_{L}(n)=\\Theta(n) & \\Longleftrightarrow L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{L I}, \\text { Len }\\rangle\n\\end{array}\n$$\n\nTheorem 1.3 describes which regular patterns can be queried over sliding windows in sublinear space: Regular left ideals over a sliding window express statements of the form \"recently in the stream some regular event happened\". Dually, complements of left ideals over a sliding window express statements of the form \"at all recent times in the stream some regular event happened\".\n\nMost papers on streaming algorithms make use of randomness. For many problems, randomized streaming algorithms are more space efficient than deterministic streaming algorithms; see e.g. [3] and the remarks at the beginning of Section 4. So, it is natural to consider randomized sliding window algorithms for regular languages. Our randomized sliding window algorithms have a two-sided or one-sided error of $1 / 3$ (any constant error probability below $1 / 2$ would yield the same results). For a one-sided error we obtain exactly the same space trichotomy for regular languages as for deterministic algorithms (Theorem 4.18). This changes if we allow a two-sided error. With $\\mathrm{F}_{L}^{\\prime}(n)$ we denote the optimal space complexity of a randomized sliding window algorithm for $L$ in the fixed size model and with two-sided error. Our second main result says that the functions $\\mathrm{F}_{L}^{\\prime}(n)$ for $L$ regular fall into four randomized space complexity classes: constant, doubly logarithmic, logarithmic, and linear space. A language $L$ is suffix-free if $x y \\in L$ and $x \\neq \\varepsilon$ implies $y \\notin L$. We denote by $\\mathbf{S F}$ the class of all regular suffix-free languages.\n\nTHEOREM 1.4. Let $L \\subseteq \\Sigma^{*}$ be regular. The randomized space complexity $\\mathrm{F}_{L}^{\\prime}(n)$ of $L$ in the fixed-size sliding window model is either $\\Theta(1), \\Theta^{\\infty}(\\log \\log n), \\Theta^{\\infty}(\\log n)$, or $\\Theta^{\\infty}(n)$. Furthermore:\n\n$$\n\\begin{array}{ll}\n\\mathrm{F}_{L}^{\\prime}(n)=\\Theta(1) & \\Longleftrightarrow L \\in\\langle\\mathbf{S T}, \\text { Len }\\rangle \\\\\n\\mathrm{F}_{L}^{\\prime}(n)=\\Theta^{\\infty}(\\log \\log n) & \\Longleftrightarrow L \\in\\langle\\mathbf{S T}, \\mathbf{S F}, \\text { Len }\\rangle \\backslash\\langle\\mathbf{S T}, \\text { Len }\\rangle \\\\\n\\mathrm{F}_{L}^{\\prime}(n)=\\Theta^{\\infty}(\\log n) & \\Longleftrightarrow L \\in\\langle\\mathbf{L I}, \\text { Len }\\rangle \\backslash\\langle\\mathbf{S T}, \\mathbf{S F}, \\text { Len }\\rangle \\\\\n\\mathrm{F}_{L}^{\\prime}(n)=\\Theta^{\\infty}(n) & \\Longleftrightarrow L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{L I}, \\text { Len }\\rangle\n\\end{array}\n$$\n\nFigure 1 compares the deterministic and the randomized space complexity in the fixed-size model (we only show the upper bounds in order to not overload the figure). We also consider\n\nrandomized algorithms in the variable-size model. In this setting we obtain again the same space trichotomy for regular languages as for the deterministic case; see Lemma 4.21.\n\nBy Theorems 1.3 and 1.4, some (simple) regular languages (e.g. $a\\{a, b\\}^{*}$ ) do not admit sublinear space (randomized) algorithms. This gives the motivation to seek for alternative approaches in order to achieve efficient algorithms for all regular languages. We take our inspiration from the property testing model introduced by Goldreich et al. [61]. In this model, the task is to decide (with high probability) whether the input has a particular property $P$, or is \"far\" from any input satisfying $P$, while querying as few symbols of the input as possible. Alon et al. prove that every regular language has a property tester making only $O(1)$ many queries [2]. The idea of property testing was also combined with the streaming model, yielding streaming property testers, where the objective is not to minimize the number of queries but the required memory $[34,38]$. We define sliding window testers, which, using as little space as possible, must accept if the window (of size $n$ ) belongs to the language $L$ and must reject if the window has Hamming distance at least $\\gamma(n)$ from every word in $L$. Here $\\gamma(n) \\leqslant n$ is a function that is called the Hamming gap of the sliding window testers. We focus on the fixed-size model.\n\nTwo of our main results concerning sliding window testers that we show in Section 5 are the following:\n\nTHEOREM 1.5. Let $L \\subseteq \\Sigma^{*}$ be regular.\n(i) There exists a deterministic sliding window tester for $L$ with constant Hamming gap that uses space $O(\\log n)$.\n(ii) For every $\\epsilon>0$ there exists a randomized sliding window tester for $L$ with two-sided error and Hamming gap en that uses space $O(1 / \\epsilon)$.\n\nSection 5 contains additional results that give a rather precise tradeoff between space complexity and the Hamming gap function $\\gamma(n)$. In addition we also study sliding window testers with a one-sided error and prove optimality for most of our results by providing matching lower bounds. See Section 5.2 for a complete discussion of our results for sliding window testers.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 3,
      "text": "# 1.3 Related work \n\nThis paper builds on four conference papers [43, 45, 46, 47]. To keep this paper coherent, we decided to omit some of the results from [43, 45, 46, 47]. In this section, we briefly discuss these results as well as other related work.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 4,
      "text": "### 1.3.1 Uniform setting\n\nIn all our results we assume a fixed regular language $L$. The space complexity is only measured with respect to the window size. It is a natural question to ask how the space bounds depend on the size of a finite automaton (deterministic or nondeterministic) for $L$. This question is\n\n![img-0.jpeg](img-0.jpeg)\n\nFigure 1. The space complexity of regular languages in the fixed-size sliding window model. Reg: regular languages, LI: regular left ideals, ST: suffix testable languages, SF: regular suffix-free languages, Len: regular length languages. The angle brackets $\\langle\\cdot\\rangle$ denote Boolean closure.\nconsidered in [43]. It is shown that, if $\\mathcal{A}$ is a DFA (resp., NFA) with $m$ states for a language $L \\in\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$, then $\\mathrm{V}_{L}(n)=O\\left(2^{m} \\cdot m \\cdot \\log n\\right)\\left(\\right.$ resp., $\\mathrm{V}_{L}(n)=O\\left(4^{m} \\cdot \\log n\\right)$ ). Furthermore, for every $k \\geqslant 1$ there exists a language $L_{k} \\subseteq\\{0, \\ldots, k\\}^{*}$ recognized by a deterministic automaton with $k+3$ states such that $L_{k} \\in\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$ and $F_{L_{k}}(n) \\geqslant\\left(2^{k}-1\\right) \\cdot(\\log n-k)$. A binary encoding of the words in $L_{k}$ yields a subexponential lower bound over a fixed alphabet [41, Theorem 4.45]. Further results on the uniform space complexity for languages in $\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$ as well as in $\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$ can be found in [41, Section 4.3].",
      "tables": {},
      "images": {
        "img-0.jpeg": "data:image/jpeg;base64,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UAFc3f6jdRfELR9PjmYW01hdSyRcYZlaIKfw3N+ddJXJal/yVTQB2/su9/8AQ4KAOsHSloooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAqG5cpBIwJBCEjH0qaobr/j0m/wCubfyoAxvBF9c6n4G0S+vJTLc3FnFJLI3VmKgk/nW/XMfDj/km3hz/ALB8P/oIrp6ACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK5LUv+SqaB/2C73/0OCutrktS/wCSqaB/2C73/wBDgoA62iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACobv/jzm/wCubfyqaobv/jzm/wCubfyoA574cf8AJNvDn/YPh/8AQRXT1zHw4/5Jt4c/7B8P/oIrp6ACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK5LUv+SqaB/wBgu9/9Dgrra5LUv+SqaB/2C73/ANDgoA62iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACobv/AI85v+ubfyqaobv/AI85v+ubfyoA574cf8k28Of9g+H/ANBFdPXMfDj/AJJt4c/7B8P/AKCK6egAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACuW1G3nb4laJcrFIYI9NvFeQISqkvDgE+pwfyr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TWNTluftN5qdwJHcpt2RINscYGTwo798mgDcXpTqRRgYxiloAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKMAdqKKADFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUYz1oooAKKKKACiiigAoxiiigAoopjMN4XOCece3f8Az70APopAciloAKKKKACiiigAIB6iiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKADFFFFABRRRQAUYoooAKKKQ8EUALRTUYOgZSCD0IOadQAUUUUAFFFFABRiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACuS1L/AJKpoH/YLvf/AEOCutrktS/5KpoH/YLvf/Q4KAOsAwKWiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACobsA2c3H/ACzb+VTVDd/8ec3/AFzb+VAHPfDn/km3hz/sHw/+giunrmPhx/yTbw5/2D4f/QRXT0AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVyWpf8lU0D/sF3v/ocFdbXJal/yVTQP+wXe/8AocFAHW0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVDd/8AHnN/1zb+VTVDd/8AHnN/1zb+VAHPfDj/AJJt4c/7B8P/AKCK6euY+HH/ACTbw5/2D4f/AEEV09ABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUU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VTQP+wXe/wDocFAHW0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVDdgfY5/wDrm38qmqG7/wCPOb/rm38qAOe+HH/JNvDn/YPh/wDQRXT1zHw4/wCSbeHP+wfD/wCgiunoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArktS/wCSqaB/2C73/wBDgrra5LUv+SqaB/2C73/0OCgDraKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKhu/wDjzm/65t/Kpqhu/wDjzm/65t/KgDnvhx/yTbw5/wBg+H/0EV09cx8OP+SbeHP+wfD/AOgiunoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArktS/5KpoH/YLvf8A0OCutrktS/5KpoH/AGC73/0OCgDraKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKhu/+POb/rm38qmqG7/485v+ubfyoA574cf8k28Of9g+H/0EV09cx8OP+SbeHP8AsHw/+giunoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAqlNplrLq1tqbxZu7eJ4Y5Nx+VHKlhjoc7F57Y96u0EA9RQAi9KWiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooo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"
      }
    },
    {
      "section_id": 5,
      "text": "# 1.3.2 Membership in the space classes \n\nIn view of Theorem 1.3 it is natural to ask for the complexity of checking whether a given (non)deterministic finite automaton accepts a language from $\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$ or $\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$, respectively. Both problems are shown in [43] to be NL-complete for deterministic automata and PSPACEcomplete for nondeterministic automata. We remark that for the class $\\langle\\mathbf{S T}, \\mathbf{S F}, \\mathbf{L e n}\\rangle$ from Theorem 1.4 the complexities of the corresponding membership problems are open.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 6,
      "text": "### 1.3.3 Other models of randomness\n\nIn Section 1.2 we did not specify the underlying model of randomized sliding window algorithms (that is used in Theorem 1.4) in a precise way. Let us be a bit more specific: we require that a randomized sliding window algorithm for a language $L$ running on an input stream $s$ outputs at every time instant a correct answer on the question whether the current window belongs to $L$ or not with high probability (say at least $2 / 3$ ). This is not the only model of randomized sliding window algorithms that can be found in the literature. A stronger model requires that with high probability the randomized sliding window algorithm outputs at every time instant\n\na correct answer. So the difference is between \" $\\forall$ time instants: $\\operatorname{Pr}[$ answer correct] $\\geqslant 2 / 3$ \" and \"Pr[ $\\forall$ time instants: answer correct] $\\geqslant 2 / 3$ \". A randomized sliding window algorithm that fulfills the latter (stronger) correctness criterion is called strictly correct in [44]. This model is for instance implicitly used in [13, 27]. In [44] it is shown that every strictly correct randomized sliding window algorithm can be derandomized without increasing the space complexity. This result is shown in a very general context for arbitrary approximation problems. The proof in [44] needs input streams of length doubly exponential in the window size for the derandomization. In contrast, if one restricts to input streams of length polynomial in the window size then strictly correct randomized sliding window algorithms can be more space efficient than ordinary randomized sliding window algorithms (as defined in this paper) [44]. The intermediate case of exponentially long input streams is open.\n\nFinally, we emphasize that our randomized sliding window algorithms are not necessarily adversarially robust, i.e., an adversary may fool the algorithm by observing the internal memory state and picking the input symbols adaptively.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 7,
      "text": "# 1.3.4 Context-free languages \n\nIt is natural to ask to which extent our results hold for context-free languages. This question is considered in [49, 42]. Let us briefly discuss the results. In [49] it is shown that if $L$ is a context-free language with $F_{L}(n) \\leqslant \\log n-\\omega(1)$ then $L$ must be regular and $F_{L}(n)=\\Theta(1)$. Hence, the gap between constant space and logarithmic space for regular languages also exists for context-free languages. In contrast, the gap between logarithmic space and linear space for regular languages does not extend to all context-free languages. In [49], the authors construct examples of context-free languages $L$ with $F_{L}(n)=\\Theta^{\\infty}\\left(n^{1 / c}\\right)$ and $V_{L}(n)=\\Theta\\left(n^{1 / c}\\right)$ for every natural number $c \\geqslant 2$. These languages are not deterministic context-free, but [49] also contains examples of deterministic one-turn one-counter languages $L$ and $L^{\\prime}$ with $F_{L}(n)=\\Theta^{\\infty}\\left(\\log ^{2} n\\right)$ and $V_{L^{\\prime}}(n)=\\Theta\\left(\\log ^{2} n\\right)$. In [42], the author studies the space complexity of visibly pushdown languages (a language class strictly in-between the regular and deterministic context-free languages with good closure and decidability properties [5]). It is shown that for every visibly pushdown language the space complexity in the variable-size sliding window model is either constant, logarithmic or linear in the window size. Hence, the space trichotomy that we have seen for regular languages also holds for visibly pushdown languages in the variable-size model. Whether the visibly pushdown languages also exhibit the space trichotomy in the fixed-size model is open.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 8,
      "text": "### 1.3.5 Update times\n\nIn this paper, we only considered the space complexity of sliding window algorithms. Another important complexity measure is the update time of a sliding window algorithm, i.e., the worst\n\ncase time that is spent per incoming symbol for updating the internal data structures. In [88], it is shown that for every regular language $L$ there exists a deterministic sliding window algorithm (for the fixed-size model) with constant update time. The underlying machine model of the sliding window algorithm is the RAM model, where basic arithmetic operations on registers of bit length $O(\\log n)$ (with $n$ the window size) need constant time. In fact, the algorithm in [88] is formulated in a more general context for any associative aggregation function. The case of a regular language $L$ is obtained by applying the algorithm from [88] for the syntactic monoid of $L$. In [48] the result of [88] is extended to visibly pushdown languages.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 9,
      "text": "# 1.3.6 Further work on sliding windows \n\nWe have already mentioned the seminal work of Datar et al. on the sliding window model [27], where the authors considered the problem of estimating the number of ones in the sliding window. In the same paper, Datar et al. extend their result for the basic counting problem to arbitrary functions which satisfy certain additivity properties, e.g. $L_{p}$-norms for $p \\in[1,2]$. Braverman and Ostrovsky introduced the smooth histogram framework [17], to compute socalled smooth functions over sliding windows, which include all $L_{p}$-norms and frequency moments. Further work on computing aggregates, statistics and frequent elements in the sliding window model can be found in $[7,9,12,13,16,28,35,55,56]$. The problem of sampling over sliding windows was first studied in [8] and later improved in [18]. As an alternative to sliding windows, Cohen and Strauss consider the problem of maintaining stream aggregates where the data items are weighted by a decay function [25].",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 10,
      "text": "### 1.3.7 Language recognition in the classical streaming model\n\nWhereas language recognition in the sliding window model has been neglected prior to our work, there exists some work on streaming algorithms for formal languages in the standard setting, where the streaming algorithm reads an input word $w$ and at the end has to decide whether $w$ belongs to some language. Clearly, for regular languages, this problem can be solved in constant space. Streaming algorithms for various subclasses of context-free languages have been studied in [10, 38, 63, 69, 72]. Related to this is the work on querying XML documents in the streaming model $[11,67,85]$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 11,
      "text": "### 1.3.8 Streaming pattern matching\n\nRelated to our work is the problem of streaming pattern matching, where the goal is to find all occurrences of a pattern (possibly with some bounded number of mismatches) in a data stream; see e.g. $[66,82,57,54,19,21,22,23,24,58,60,59,80,86]$ and search of repetitions in streams $[33,32,31,53,52,73,74]$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 12,
      "text": "# 1.3.9 Dynamic membership problems for regular languages \n\nA sliding window algorithm can be viewed as a dynamic data structure that maintains a dynamic string $w$ (the window content) under very restricted update operations. Dynamic membership problems for more general updates that allow to change the symbol at an arbitrary position have been studied in [6, 39, 40]. As in our work, a trichotomy for the dynamic membership problem of regular languages has been obtained in [6] (but the classes appearing the trichotomy in [6] are different from the classes that appear in our work).",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 13,
      "text": "### 1.4 Outline\n\nThe outline of the paper is as follows: In Section 2 we give preliminary definitions and introduce the fixed-size sliding window model and the variable-size sliding window model. In Section 3 we study deterministic sliding window algorithms for regular languages and prove the space trichotomy and the characterizations of the space classes (Theorem 1.3). In Section 4 we turn to randomized sliding window algorithms and prove the space tetrachotomy (Theorem 1.4). Finally, in Section 5 we present deterministic and randomized sliding window property testers for regular languages (Theorem 1.5).",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 14,
      "text": "## 2. Preliminaries\n### 2.1 Words and languages\n\nAn alphabet $\\Sigma$ is a nonempty finite set of symbols. A word over an alphabet $\\Sigma$ is a finite sequence $w=a_{1} a_{2} \\cdots a_{n}$ of symbols $a_{1}, \\ldots, a_{n} \\in \\Sigma$. The length of $w$ is the number $|w|=n$. The empty word is denoted by $\\varepsilon$ whereas the lunate epsilon $\\epsilon$ denotes small positive numbers. The concatenation of two words $u, v$ is denoted by $u \\cdot v$ or $u v$. The set of all words over $\\Sigma$ is denoted by $\\Sigma^{*}$. A subset $L \\subseteq \\Sigma^{*}$ is called a language over $\\Sigma$.\n\nLet $w=a_{1} \\cdots a_{n} \\in \\Sigma^{*}$ be a word. Any word of the form $a_{1} \\cdots a_{i}$ is a prefix of $w$, a word of the form $a_{i} \\cdots a_{n}$ is a suffix of $w$, and a word of the form $a_{i} \\cdots a_{j}$ is a factor of $w$. The concatenation of two languages $K, L$ is $K L=\\{u v \\mid u \\in K, v \\in L\\}$. For a language $L$ we define $L^{n}$ inductively by $L^{0}=\\{\\varepsilon\\}$ and $L^{n+1}=L^{n} L$ for all $n \\in \\mathbb{N}$. The Kleene-star of a language $L$ is the language $L^{*}=\\bigcup_{n \\in \\mathbb{N}} L^{n}$. Furthermore, we define $L^{<n}=\\bigcup_{0 \\leqslant k<n} L^{k}$ and $L^{<n}=\\bigcup_{0 \\leqslant k<n} L^{k}$.\n\nLet $L \\subseteq \\Sigma^{*}$ be a language. We say that $L$ separates two words $x, y \\in \\Sigma^{*}$ with $x \\neq y$ if $|\\{x, y\\} \\cap L|=1$. We say that $L$ separates two languages $K_{1}, K_{2} \\subseteq \\Sigma^{*}$ if $K_{1} \\subseteq L$ and $K_{2} \\cap L=\\emptyset$, or $K_{2} \\subseteq L$ and $K_{1} \\cap L=\\emptyset$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 15,
      "text": "### 2.2 Automata and regular languages\n\nFor good introductions to the theory of formal languages and automata we refer to [15, 62, 68].\n\nThe standard description for regular languages are finite automata. Let $\\Sigma$ be a finite alphabet. A nondeterministic finite automaton (NFA) is a tuple\n\n$$\n\\mathcal{A}=(Q, \\Sigma, I, \\Delta, F)\n$$\n\nwhere $Q$ is the finite set of states, $I \\subseteq Q$ is the set of initial states, $\\Delta \\subseteq Q \\times \\Sigma \\times Q$ is the set of transitions, and $F \\subseteq Q$ is the set of final states. A run of $\\mathcal{A}$ on a word $w=a_{1} \\cdots a_{n} \\in \\Sigma^{*}$ is a finite sequence $\\pi=q_{0} a_{1} q_{1} a_{2} q_{2} \\cdots q_{n-1} a_{n} q_{n} \\in Q(\\Sigma Q)^{*}$ such that $\\left(q_{i-1}, a_{i}, q_{i}\\right) \\in \\Delta$ for all $1 \\leqslant i \\leqslant n$. We call $\\pi$ successful if $q_{0} \\in I$ and $q_{n} \\in F$. The language accepted by $\\mathcal{A}$ is defined as\n\n$$\n\\mathrm{L}(\\mathcal{A})=\\left\\{w \\in \\Sigma^{*} \\mid \\text { there exists a successful run of } \\mathcal{A} \\text { on } w\\right\\}\n$$\n\nA language $L \\subseteq \\Sigma^{*}$ is regular if it is accepted by some NFA. The size $|\\mathcal{A}|$ is defined as the number of states.\n\nA (left-)deterministic finite automaton (DFA) is an NFA $\\mathcal{A}=(Q, \\Sigma, I, \\Delta, F)$, where $I=\\left\\{q_{0}\\right\\}$ has exactly one initial state $q_{0}$, and for all $p \\in Q$ and $a \\in \\Sigma$ there exists exactly one transition $(p, a, q) \\in \\Delta$. We view $\\Delta$ as a transition function $\\delta: Q \\times \\Sigma \\rightarrow Q$ and write $\\mathcal{A}$ in the format $\\mathcal{A}=\\left(Q, \\Sigma, q_{0}, \\delta, F\\right)$. The transition function $\\delta$ can be extended to a right action $\\cdot: Q \\times \\Sigma^{*} \\rightarrow Q$ of the free monoid $\\Sigma^{*}$ on the state set $Q$ by setting $q \\cdot \\varepsilon=q$ and defining inductively $q \\cdot u a=\\delta(q \\cdot u, a)$ for all $q \\in Q, u \\in \\Sigma^{*}$, and $a \\in \\Sigma$. We write $\\mathcal{A}(w)$ instead of $q_{0} \\cdot w$. It is known that any NFA can be turned into an equivalent DFA by the power set construction.\n\nWe also consider automata with (possibly) infinitely many states as our formal model for streaming algorithms. A deterministic automaton $\\mathcal{A}$ has the same format $\\mathcal{A}=\\left(Q, \\Sigma, q_{0}, \\delta, F\\right)$ as a DFA but we drop the condition that $Q$ must be finite. We use the notations from the previous paragraph for general deterministic automata as well.\n\nIt is well-known that for every regular language $L$ there exists a minimal DFA $\\mathcal{A}_{L}$ for $L$, which is unique up to isomorphism and whose states are the Myhill-Nerode classes of $L$. This construction can be carried out for every language $L$ and yields a deterministic automaton $\\mathcal{A}_{L}$ for $L$ such that for every deterministic automaton $\\mathcal{B}$ for $L$, we have that $\\mathcal{B}(x)=\\mathcal{B}(y)$ implies $\\mathcal{A}_{L}(x)=\\mathcal{A}_{L}(y)$ for all $x, y \\in \\Sigma^{*}$ [30, Chapter III, Theorem 5.2]. We call this automaton the minimal deterministic automaton for $L$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 16,
      "text": "# 2.3 Streaming algorithms \n\nA stream is a finite sequence of elements $a_{1} \\cdots a_{m}$, which arrive element by element from left to right. So, it is just a finite word over some alphabet. In this paper, the elements $a_{i}$ are always symbols from a finite alphabet $\\Sigma$. A streaming algorithm reads the symbols of the input stream from left to right. At time instant $t$ the algorithm only has access to the symbol $a_{t}$ and the internal storage, which is encoded by a bit string. The goal of the streaming algorithm is to compute a function $\\varphi: \\Sigma^{*} \\rightarrow Y$, where $\\Sigma$ is a finite alphabet and $Y$ is a set of output values. For the remainder of this paper, we only consider the Boolean case, i.e., $Y=\\{0,1\\}$; in other\n\nwords, $\\varphi$ is the characteristic function of a language $L$. Furthermore, we abstract away the actual computation and only analyze the memory requirement.\n\nFormally, a deterministic streaming algorithm is the same as a deterministic automaton $\\mathcal{P}$ and we say that $\\mathcal{P}$ is a streaming algorithm for the language $L(\\mathcal{P})$. The letter $\\mathcal{P}$ stands for program. If $\\mathcal{P}=\\left(M, \\Sigma, m_{0}, \\delta, F\\right)$ then the states from $M$ are usually called memory states. We require $M \\neq \\emptyset$ but allow $M$ to be infinite. The space of $\\mathcal{P}$ (or number of bits used by $\\mathcal{P}$ ) is given by $s(\\mathcal{P})=\\log |M| \\in \\mathbb{R}_{\\geqslant 0} \\cup\\{\\infty\\}$. Here and in the rest of the paper, we denote with log the logarithm with base two, i.e., we measure space in bits. If $s(\\mathcal{P})=\\infty$ we will measure the space restricted to input streams where some parameter is bounded (namely the window size); see Section 2.5.\n\nWe remark that many streaming algorithms in the literature only produce a single answer after completely reading the entire stream. Also, the length of the stream is often known in advance. However, in the sliding window model we rather assume an input stream of unbounded and unknown length, and need to compute output values for every window, i.e., at every time instant.\n\nIn the following, we introduce the sliding window model in two different variants: the fixed-size sliding window model and the variable-size sliding window model.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 17,
      "text": "# 2.4 Fixed-size sliding window model \n\nWe fix an arbitrary padding symbol $\\square \\in \\Sigma$. Given a stream $x=a_{1} a_{2} \\cdots a_{m} \\in \\Sigma^{*}$ and a window size $n \\in \\mathbb{N}$, we define last ${ }_{n}(x) \\in \\Sigma^{n}$ by\n\n$$\n\\operatorname{last}_{n}(x)= \\begin{cases}a_{m-n+1} a_{m-n+2} \\cdots a_{m}, & \\text { if } n \\leqslant m \\\\ \\square^{n-m} a_{1} \\cdots a_{m}, & \\text { if } n>m\\end{cases}\n$$\n\nwhich is called the window of size $n$, or the active or current window. In other words, last ${ }_{n}(x)$ is the suffix of length $n$, padded with $\\square$-symbols on the left. We view $\\square^{n}$ as the initial window; its choice is completely arbitrary.\n\nLet $L \\subseteq \\Sigma^{*}$ be a language. The sliding window problem $\\mathrm{SW}_{n}(L)$ for $L$ and window size $n \\in \\mathbb{N}$ is the language\n\n$$\n\\mathrm{SW}_{n}(L)=\\left\\{x \\in \\Sigma^{*} \\mid \\operatorname{last}_{n}(x) \\in L\\right\\}\n$$\n\nNote that for every $L$ and every $n, \\mathrm{SW}_{n}(L)$ is regular. A sliding window algorithm (SW-algorithm) for $L$ and window size $n \\in \\mathbb{N}$ is a streaming algorithm for $\\mathrm{SW}_{n}(L)$. The function $\\mathrm{F}_{L}: \\mathbb{N} \\rightarrow \\mathbb{R}_{\\geqslant 0}$ is defined by\n\n$$\n\\mathrm{F}_{L}(n)=\\inf \\left\\{s\\left(\\mathcal{P}_{n}\\right) \\mid \\mathcal{P}_{n} \\text { is an SW-algorithm for } L \\text { and window size } n\\right\\}\n$$\n\nIt is called the space complexity of $L$ in the fixed-size sliding window model. Note that $\\mathrm{F}_{L}(n)<\\infty$ since $\\mathrm{SW}_{n}(L)$ is regular. A subtle point is that the space complexity $\\mathrm{F}_{L}(n)$ of a language $L$ in general depends on the underlying alphabet. A simple example is $L=a^{*}$ which has complexity\n\n$\\mathrm{F}_{L}(n)=O(1)$ over the singleton alphabet $\\{a\\}$ whereas it has complexity $\\mathrm{F}_{L}(n)=\\Theta(\\log n)$ over the alphabet $\\{a, b\\}$ (the latter follows from our results). Here, it is also important that the padding symbol $\\square$ belongs to the alphabet $\\Sigma$ over which the language $L$ is defined. An alternative definition would be to take a fresh padding symbol $\\square \\notin \\Sigma$ and define last $_{n}(x)$ and $\\operatorname{SW}_{n}(L)$ as above. For instance, for $L=a^{*}$ we would obtain $\\operatorname{SW}_{n}(L)=\\left\\{a^{i} \\mid i \\geqslant n\\right\\}$, whose minimal DFA has $n+1$ states. Thus, the space complexity would be $\\Omega(\\log n)$ instead of $O(1)$. Note that these differences only concern the space complexity during the first $n$ steps (until the window is filled up). Sliding window algorithms are usually used for streams that are much longer than the window size. So it might be acceptable, if during a short initial phase the space complexity is higher than for the rest of the stream.\n\nWe draw similarities to circuit complexity, where a language $L \\subseteq\\{0,1\\}^{*}$ is recognized by a family of circuits $\\left(C_{n}\\right)_{n \\in \\mathbb{N}}$ in the sense that $C_{n}$ recognizes the slice $L \\cap\\{0,1\\}^{n}$. Similarly, the sliding window problem $\\operatorname{SW}_{n}(L)$ is solely defined by the slice $L \\cap \\Sigma^{n}$. If we speak of an SW-algorithm for $L$ and omit the window size $n$, then this parameter is implicitly universally quantified, meaning that there exists a family of streaming algorithms $\\left(\\mathcal{P}_{n}\\right)_{n \\in \\mathbb{N}}$ such that every $\\mathcal{P}_{n}$ is an SW-algorithm for $L$ and window size $n$.\n\nLEMMA 2.1. For any language $L$ we have $\\mathrm{F}_{L}(n)=O(n)$.\nPROOF. A trivial SW-algorithm $\\mathcal{P}_{n}$ for $L$ explicitly stores the active window of size $n$ in a queue so that the algorithm can always test whether the window belongs to $L$. Formally, the state set of $\\mathcal{P}_{n}$ is $\\Sigma^{n}$ and it has transitions of the form $(b u, a, u a)$ for $a, b \\in \\Sigma, u \\in \\Sigma^{n-1}$. Viewed as an edge-labeled graph this automaton is also known under the name de Bruijn graph [20]. Since every word $w \\in \\Sigma^{n}$ can be encoded with $O(\\log |\\Sigma| \\cdot n)$ bits and $|\\Sigma|$ is a constant, the algorithm uses $O(n)$ bits.\n\nDepending on the language $L$ there are more space efficient solutions. Usually, sliding window algorithms are devised in the following way:\n\n- Specify some information or property $I(w)$ of the active window $w$ and show that it can be maintained by a streaming algorithm. This means that given $I(b u)$ and $a \\in \\Sigma$ one can compute $I(u a)$.\n- Show that one can decide $w \\in L$ from the information $I(w)$.\n\nNotice that the complexity function $\\mathrm{F}_{L}(n)$ is not necessarily monotonic. For instance, let $L$ be the intersection of $a \\Sigma^{*}$ and the set of words with even length. By Example 1.2(iii), we have $\\mathrm{F}_{L}(2 n)=\\Theta(n)$ but clearly we have $\\mathrm{F}_{L}(2 n+1)=O(1)$ since for odd window sizes the algorithm can always reject. Therefore, we can only show $\\mathrm{F}_{L}(n)=\\Theta^{\\infty}(n)$ (instead of $\\mathrm{F}_{L}(n)=\\Theta(n)$ which is false here), where $\\Theta^{\\infty}(g(n))$ was defined in the introduction.\n\nNote that the fixed-size sliding window model is a nonuniform model: for every window size we have a separate streaming algorithm and these algorithms do not have to follow a\n\ncommon pattern. Working with a nonuniform model makes lower bounds stronger. In contrast, the variable-size sliding window model that we discuss next is a uniform model in the sense that there is a single streaming algorithm that works for every window size. Let us remark that all presented upper bounds for the fixed-size model will be realized by uniform families of algorithms.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 18,
      "text": "# 2.5 Variable-size sliding window model \n\nFor an alphabet $\\Sigma$ we define the extended alphabet $\\Sigma_{\\downarrow}=\\Sigma \\cup\\{\\downarrow\\}$. In the variable-size model the active window $\\operatorname{wnd}(u) \\in \\Sigma^{*}$ for a stream $u \\in \\Sigma_{\\downarrow}^{+}$is defined as follows, where $a \\in \\Sigma$ :\n\n$$\n\\begin{array}{ll}\n\\operatorname{wnd}(\\varepsilon)=\\varepsilon & \\operatorname{wnd}(u \\downarrow)=\\varepsilon, \\text { if } \\operatorname{wnd}(u)=\\varepsilon \\\\\n\\operatorname{wnd}(u a)=\\operatorname{wnd}(u) a & \\operatorname{wnd}(u \\downarrow)=v, \\text { if } \\operatorname{wnd}(u)=a v\n\\end{array}\n$$\n\nThe symbol $\\downarrow$ represents the pop operation. We emphasize that a pop operation on an empty window leaves the window empty. The variable-size sliding window problem $\\operatorname{SW}(L)$ of a language $L \\subseteq \\Sigma^{*}$ is the language\n\n$$\n\\operatorname{SW}(L)=\\left\\{u \\in \\Sigma_{\\downarrow}^{+} \\mid \\operatorname{wnd}(u) \\in L\\right\\}\n$$\n\nNote that in general, $\\operatorname{SW}(L)$ is not a regular language (even if $L$ is regular). A variable-size sliding window algorithm (variable-size SW-algorithm) $\\mathcal{P}$ for $L$ is a streaming algorithm for $\\operatorname{SW}(L)$.\n\nThere are various possible definitions for the space complexity of a variable-size SWalgorithm. Here, we measure the space complexity as a function in the maximum window size over all read prefixes. This definition enjoys the property that every language $L$ has a variable-size SW-algorithm with smallest complexity among all variable-size SW-algorithms for $L$. If one would measure the space complexity in the current window size instead, this does not hold anymore, since the memory state encodings of any SW-algorithm can be permuted to yield an algorithm whose complexity is incomparable to the original one.\n\nTo be more formal, for a stream $u=a_{1} \\cdots a_{m} \\in \\Sigma_{\\downarrow}^{+}$let\n\n$$\nm w l(u)=\\max \\left\\{\\left|w n d\\left(a_{1} \\cdots a_{i}\\right)\\right| \\mid 0 \\leqslant i \\leqslant m\\right\\}\n$$\n\nbe the maximum window size of all prefixes of $u$. If $\\mathcal{P}=\\left(M, \\Sigma, m_{0}, \\delta, \\Gamma\\right)$ is a streaming algorithm over $\\Sigma_{\\downarrow}$ we define\n\n$$\nM_{n}=\\left\\{\\mathcal{P}(w) \\mid w \\in \\Sigma_{\\downarrow}^{+}, m w l(w)=n\\right\\}\n$$\n\nand $M_{\\leqslant n}=\\bigcup_{0 \\leqslant k \\leqslant n} M_{k}$. The space complexity of $\\mathcal{P}$ in the variable-size sliding window model is\n\n$$\nv(\\mathcal{P}, n)=\\log \\left|M_{\\leqslant n}\\right| \\in \\mathbb{R}_{\\geqslant 0} \\cup\\{\\infty\\}\n$$\n\nIn other words: when we say that the space complexity of a variable-size SW-algorithm is bounded by $f(n)$, we mean that the algorithm never has to store more than $f(n)$ bits when it\n\nprocesses a stream $u \\in \\Sigma_{\\downarrow}^{*}$ such that for every prefix of $u$ the size of the active window never exceeds $n$.\n\nNotice that $v(\\mathcal{P}, n)$ is a monotonic function. To prove upper bounds above $\\log n$ for the space complexity of $\\mathcal{P}$ it suffices to bound $\\log \\left|M_{n}\\right|$ as shown in the following.\n\nLEMMA 2.2. If $s(n) \\geqslant \\log n$ is a monotonic function and $\\log \\left|M_{n}\\right|=O(s(n))$ then $v(\\mathcal{P}, n)=$ $O(s(n))$.\n\nPROOF. Since $M_{\\leqslant n}=M_{0} \\cup M_{1} \\cup \\cdots \\cup M_{n}$, we have\n\n$$\n\\begin{aligned}\n\\log \\left|M_{\\leqslant n}\\right| & =\\log \\sum_{i=0}^{n}\\left|M_{i}\\right| \\\\\n& \\leqslant \\log \\left((n+1) \\cdot \\max _{0 \\leqslant i \\leqslant n}\\left|M_{i}\\right|\\right) \\\\\n& =\\log (n+1)+\\max _{0 \\leqslant i \\leqslant n} \\log \\left|M_{i}\\right| \\\\\n& \\leqslant \\log (n+1)+\\max _{0 \\leqslant i \\leqslant n} O(s(i)) \\\\\n& \\leqslant \\log (n+1)+O(s(n))=O(s(n))\n\\end{aligned}\n$$\n\nwhich proves the statement.\nLEMMA 2.3. For every language $L \\subseteq \\Sigma^{*}$ there exists a space-optimal variable-size SW-algorithm $\\mathcal{P}$, i.e., $v(\\mathcal{P}, n) \\leqslant v(Q, n)$ for every variable-size SW-algorithm $Q$ for $L$ and every $n \\in \\mathbb{N}$.\n\nPROOF. Let $\\mathcal{P}$ be the minimal deterministic automaton $\\mathcal{A}_{\\mathrm{SW}(L)}$ for $\\operatorname{SW}(L)$. If $Q$ is any deterministic automaton for $\\operatorname{SW}(L)$ then $Q(x)=Q(y)$ implies $\\mathcal{P}(x)=\\mathcal{P}(y)$. Then, we obtain\n\n$$\n\\begin{aligned}\nv(\\mathcal{P}, n) & =\\log \\left|\\left\\{\\mathcal{P}(w) \\mid w \\in \\Sigma_{\\downarrow}^{*}, \\operatorname{mwl}(w) \\leqslant n\\right\\}\\right| \\\\\n& \\leqslant \\log \\left|\\left\\{Q(w) \\mid w \\in \\Sigma_{\\downarrow}^{*}, \\operatorname{mwl}(w) \\leqslant n\\right\\}\\right|=v(Q, n)\n\\end{aligned}\n$$\n\nwhich proves the statement.\nOne could also define the space complexity $v(\\mathcal{P}, n)$ as the number of bits required to encode a state of $\\mathcal{P}$ where the current window size is $n$. It is not difficult to see that Lemma 2.3 fails for this definition.\n\nWe define the space complexity of $L$ in the variable-size sliding window model by $\\mathrm{V}_{L}(n)=$ $v(\\mathcal{P}, n)$ where $\\mathcal{P}$ is a space-optimal variable-size SW-algorithm for $\\operatorname{SW}(L)$ from Lemma 2.3. It is a monotonic function.\n\nLEMMA 2.4. For any language $L \\subseteq \\Sigma^{*}$ and $n \\in \\mathbb{N}$ we have $\\mathrm{F}_{L}(n) \\leqslant \\mathrm{V}_{L}(n)$.\nPROOF. If $\\mathcal{P}$ is a space-optimal variable-size SW-algorithm for $L$ then one obtains an SWalgorithm $\\mathcal{P}_{n}$ for window size $n \\in \\mathbb{N}$ as follows. Let us assume $n \\geqslant 1$ (for $n=0$ we use the trivial\n\nSW-algorithm). First one simulates $\\mathcal{P}$ on the initial window $\\square^{n}$. For every incoming symbol $a \\in \\Sigma$ we perform a pop operation $\\downarrow$ in $\\mathcal{P}$, followed by inserting $a$. Since the maximum window size is bounded by $n$ on any stream, the space complexity is bounded by $v(\\mathcal{P}, n)=\\mathrm{V}_{L}(n)$.\n\nThe following lemma states that in the variable-size model one must at least maintain the current window size if the language is neither empty nor universal. The issue at hand is performing a pop operation on an empty window.\n\nLEMMA 2.5. Let $\\mathcal{P}$ be a variable-size SW-algorithm for a language $\\emptyset \\subseteq L \\subseteq \\Sigma^{*}$. Then, $\\mathcal{P}(x)$ determines ${ }^{2}|\\operatorname{wnd}(x)|$ for all $x \\in \\Sigma_{L}^{*}$ and therefore $\\mathrm{V}_{L}(n) \\geqslant \\log (n+1)$.\n\nPROOF. Let $y \\in \\Sigma^{+}$be a length-minimal nonempty word such that $|\\{\\varepsilon, y\\} \\cap L|=1$. Consider streams $x_{1}, x_{2} \\in \\Sigma_{L}^{*}$ with $\\left|\\operatorname{wnd}\\left(x_{1}\\right)\\right|<\\left|\\operatorname{wnd}\\left(x_{2}\\right)\\right|=m$ and assume $\\mathcal{P}\\left(x_{1}\\right)=\\mathcal{P}\\left(x_{2}\\right)$. Then, we also have $\\mathcal{P}\\left(x_{1} y \\downarrow^{m}\\right)=\\mathcal{P}\\left(x_{2} y \\downarrow^{m}\\right)$. But $\\operatorname{wnd}\\left(x_{2} y \\downarrow^{m}\\right)=y$ whereas $\\operatorname{wnd}\\left(x_{1} y \\downarrow^{m}\\right)$ is a proper suffix of $y$. Now, by the choice of $y$ one these two words belongs to $L$ whereas the other does not, which contradicts $\\mathcal{P}\\left(x_{1} y \\downarrow^{m}\\right)=\\mathcal{P}\\left(x_{2} y \\downarrow^{m}\\right)$.\n\nFor the second statement: if the algorithm reads any stream $a_{1} \\cdots a_{n} \\in \\Sigma^{n}$ it must visit $n+1$ pairwise distinct memory states and hence $v(\\mathcal{P}, n) \\geqslant \\log (n+1)$.\n\nAlternative definitions of the variable-size model are conceivable, e.g. one could neglect streams where the popping of an empty window occurs, or assume that the window size is always known to the algorithm. Then the statement of Lemma 2.5 no longer holds.\n\nLEMMA 2.6. Let $\\Sigma$ be a finite alphabet. For any function $s(n)$ and $X \\in\\{F, V\\}$, the class $\\left\\{L \\subseteq \\Sigma^{*}\\right\\}$ $X_{L}(n)=\\mathcal{O}(s(n))\\}$ forms a Boolean algebra.\n\nPROOF. Let $L \\subseteq \\Sigma^{*}$ be a language. Given a SW-algorithm for $L$ for some fixed window size $n$ or in the variable-size model, we can turn it into an algorithm for the complement $\\Sigma^{*} \\backslash L$ by negating its output. Clearly, it has the same space complexity as the original algorithm.\n\nLet $L_{1}, L_{2} \\subseteq \\Sigma^{*}$ be two languages. Let $\\mathcal{P}_{1}, \\mathcal{P}_{2}$ be SW-algorithms for $L_{1}, L_{2}$, respectively, either for some fixed window size $n$ or in the variable-size model. Define $\\mathcal{P}$ to be the product automaton of $\\mathcal{P}_{1}$ and $\\mathcal{P}_{2}$ which outputs the disjunction of the outputs of the $\\mathcal{P}_{i}$.\n\nIn the case of a fixed window size $n, \\mathcal{P}$ has $2^{s\\left(\\mathcal{P}_{1}\\right)} \\cdot 2^{s\\left(\\mathcal{P}_{2}\\right)}=2^{s\\left(\\mathcal{P}_{1}\\right)+s\\left(\\mathcal{P}_{2}\\right)}$ many states and hence $s(\\mathcal{P})=s\\left(\\mathcal{P}_{1}\\right)+s\\left(\\mathcal{P}_{2}\\right)$. This implies $\\mathrm{F}_{L_{1} \\cup L_{2}}(n) \\leqslant \\mathrm{F}_{L_{1}}(n)+\\mathrm{F}_{L_{2}}(n)$. For the variable-size model, notice that $2^{v(\\mathcal{P}, n)} \\leqslant 2^{v\\left(\\mathcal{P}_{1}, n\\right)} \\cdot 2^{v\\left(\\mathcal{P}_{2}, n\\right)}=2^{v\\left(\\mathcal{P}_{1}, n\\right)+v\\left(\\mathcal{P}_{2}, n\\right)}$. Therefore, $\\mathrm{V}_{L_{1} \\cup L_{2}}(n) \\leqslant \\mathrm{V}_{L_{1}}(n)+\\mathrm{V}_{L_{2}}(n)$.\n\nREMARK 2.7. Before we start our investigation of the space complexity of regular languages in the sliding window model, we would like to discuss an aspect of our definition of the space complexities $\\mathrm{F}_{L}(n)$ and $\\mathrm{V}_{L}(n)$. Both complexity measures do not include the space needed\n\n[^0]\n[^0]:    3 In other words, for all $x_{1}, x_{2} \\in \\Sigma_{L}^{*}$, if $\\mathcal{P}\\left(x_{1}\\right)=\\mathcal{P}\\left(x_{2}\\right)$ then $\\left|\\operatorname{wnd}\\left(x_{1}\\right)\\right|=\\left|\\operatorname{wnd}\\left(x_{2}\\right)\\right|$.\n\nfor internal computations, i.e., the space needed for computing the memory updates of the streaming algorithm. Let us explain this in more detail for the variable-size model (the same arguments apply to the fixed-size model). Take the space-optimal variable-size SW-algorithm $\\mathcal{P}$ for a language $L$; see Lemma 2.3. The function $\\mathrm{V}_{L}(n)$ measures the number of bits needed to encode the states in the set $M_{\\leqslant n}$ (see the line after (3)). But the transition function of $\\mathcal{P}$ may be difficult to compute. In other words: if we have two memory states $p, q \\in M_{\\leqslant n}$ (both encoded by bit strings of length $\\mathrm{V}_{L}(n)$ ) and an $a$-labelled transition from $p$ to $q$ in $\\mathcal{P}$ then additional memory is needed in general in order to compute $q$ from $p$ and $a$. This memory is what we mean by the space needed for internal computations. Our definition of $\\mathrm{V}_{L}(n)$ does not include this space. One reason for this is that if we would include the space needed for internal computations in the total space bound, then it would be difficult to obtain lower bounds that match the upper bounds. In particular, techniques based on communication complexity that we use in the randomized setting (see Section 4) are not able to take space for internal calculations into account. In our setting, these techniques only allow to prove lower bounds on the number of memory states of a (randomized) streaming algorithm and therefore are not sensitive with respect to the space needed to go from one memory state to the next memory state.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 19,
      "text": "# 3. Deterministic sliding window algorithms \n\nIn this section, we will show that the space complexity of every regular language in both sliding window models is either constant, logarithmic or linear. In Example 1.2 we have already seen prototypical languages with these three space complexities, namely $\\Sigma^{*} a$ (constant), $\\Sigma^{*} a \\Sigma^{*}$ (logarithmic) and $a \\Sigma^{*}$ (linear) for $\\Sigma=\\{a, b\\}$. Intuitively, for languages of logarithmic space complexity it suffices to maintain a constant number of positions in the window. For languages of constant space complexity it suffices to maintain a constant-length suffix of the window. Moreover, we describe the languages with logarithmic and constant space complexity as finite Boolean combinations of simple atomic languages.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 20,
      "text": "### 3.1 Right-deterministic finite automata\n\nIt turns out that the appropriate representation of a regular language for the analysis in the sliding window model are deterministic finite automata which read the input word, i.e., the window, from right to left. Such automata are called right-deterministic finite automata (rDFA) in this paper. The reason why we use rDFAs instead of DFAs can be explained intuitively for the variable-size sliding window model as follows. The variable-size model contains operations in both \"directions\": On the one hand a variable-size window can be extended on the right, and on the other hand the window can be shortened to an arbitrary suffix. For regular languages the extension to longer windows is \"tame\" because the Myhill-Nerode right congruences have\n\nfinite index. Hence, it remains to control the structure of all suffixes with respect to the regular language, which is best captured by an rDFA for the language.\n\nFormally, a right-deterministic finite automaton (rDFA) $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ consists of a finite state set $Q$, a finite alphabet $\\Sigma$, a set of final states $F \\subseteq Q$, a transition function $\\delta: \\Sigma \\times Q \\rightarrow Q$, and an initial state $q_{0} \\in Q$. The transition function $\\delta$ extends to a left action $\\cdot: \\Sigma^{*} \\times Q \\rightarrow Q$ by $\\varepsilon \\cdot q=q$ and $(a w) \\cdot q=\\delta(a, w \\cdot q)$ for all $a \\in \\Sigma, w \\in \\Sigma^{*}, q \\in Q$. The language accepted by $\\mathcal{B}$ is $\\mathrm{L}(\\mathcal{B})=\\left\\{w \\in \\Sigma^{*} \\mid w \\cdot q_{0} \\in F\\right\\}$.\n\nA run of $\\mathcal{B}$ on a word $w=a_{1} \\cdots a_{n} \\in \\Sigma^{*}$ from $p_{n}$ to $p_{0}$ is a finite sequence\n\n$$\n\\pi=p_{0} a_{1} p_{1} a_{2} p_{2} \\cdots p_{n-1} a_{n} p_{n} \\in Q(\\Sigma Q)^{*}\n$$\n\nsuch that $p_{i-1}=a_{i} \\cdot p_{i}$ for all $1 \\leqslant i \\leqslant n$. Quite often we write such a run in the following way\n\n$$\n\\pi: p_{0} \\stackrel{a_{1}}{\\longleftarrow} p_{1} \\stackrel{a_{2}}{\\longleftarrow} p_{2} \\cdots p_{n-1} \\stackrel{a_{n}}{\\longleftarrow} p_{n}\n$$\n\nIf the intermediate states $p_{1}, \\ldots, p_{n-1}$ are not important we write this run also as\n\n$$\n\\pi: p_{0} \\stackrel{a_{1} a_{2} \\cdots a_{n}}{\\longleftarrow} p_{n}\n$$\n\nThe state $p_{n}$ is also called the starting state of the above run $\\pi$. The run $\\pi$ is accepting if $p_{0} \\in F$ (note that we do not require $p_{n}=q_{0}$ ) and otherwise rejecting. Its length $|\\rho|$ is the length $|w|$ of $w$. A run of length zero is called empty; note that it consists of a single state. A run of length one is also called a transition. If $\\pi=p_{0} a_{1} p_{1} \\cdots a_{n} p_{n}$ and $\\rho=r_{0} b_{1} r_{1} \\cdots b_{\\ell} r_{\\ell}$ are runs such that $p_{n}=r_{0}$ then their composition $\\pi \\rho$ is defined as $\\pi \\rho=p_{0} a_{1} p_{1} \\cdots a_{n} r_{0} b_{1} r_{1} \\cdots b_{\\ell} r_{\\ell}$; it is a run on $a_{1} \\cdots a_{n} b_{1} \\cdots b_{\\ell}$. This definition allows us to factorize runs in Section 3.3. We call a run $\\pi$ a $P$-run for a subset $P \\subseteq Q$ if all states occurring in $\\pi$ are contained in $P$.\n\nA state $q \\in Q$ is reachable from $p \\in Q$ if there exists a run from $p$ to $q$, in which case we write $q \\leq_{\\mathcal{B}} p$. We say that $q$ is reachable if it is reachable from the initial state $q_{0}$. A set of states $P \\subseteq Q$ is reachable if all $p \\in P$ are reachable. The reachability relation $\\leq_{\\mathcal{B}}$ is a preorder on $Q$, i.e., it is reflexive and transitive. Two states $p, q \\in Q$ are strongly connected if $p \\leq_{\\mathcal{B}} q \\leq_{\\mathcal{B}} p$. This yields an equivalence relation on $Q$ whose equivalence classes are the strongly connected components (SCCs) of $\\mathcal{B}$. A subset $P \\subseteq Q$ is strongly connected if it is contained in a single SCC, i.e., all $p, q \\in P$ are strongly connected.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 21,
      "text": "# 3.2 Space trichotomy \n\nIn this section, we state two technical results which directly imply Theorem 1.3. Let $\\mathcal{B}=$ $\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ be an rDFA. A set of states $P \\subseteq Q$ is well-behaved if for any two $P$-runs $\\pi_{1}, \\pi_{2}$ which start in the same state and have equal length, either both $\\pi_{1}$ and $\\pi_{2}$ are accepting or both are rejecting. If every reachable SCC in $\\mathcal{B}$ is well-behaved then $\\mathcal{B}$ is called well-behaved. A state $q \\in Q$ is transient if $x \\cdot q \\neq q$ for all $x \\in \\Sigma^{*}$. Every transient state in $\\mathcal{B}$ forms an SCC of size one (a transient SCC); however, not every SCC of size one is transient (there can be a loop at\n\n![img-1.jpeg](img-1.jpeg)\n\nFigure 2. A well-behaved rDFA consisting of three SCCs.\nthe unique state of the SCC). Let $U(\\mathcal{B}) \\subseteq Q$ be the set of states $q \\in Q$ for which there exists a nontransient state $p \\in Q$ such that $q$ is reachable from $p$ and $p$ is reachable from the initial state $q_{0}$. Notice that $q \\in U(\\mathcal{B})$ if and only if there exist runs of unbounded length from $q_{0}$ to $q$ (hence the symbol $U$ for unbounded). Moreover, if $U(\\mathcal{B})$ is well-behaved then $\\mathcal{B}$ must be well-behaved. This follows directly from the above definition and it is also a consequence of Theorem 3.2 below.\n\nEXAMPLE 3.1. Consider the rDFA $\\mathcal{A}$ in Figure 2. It consists of three SCCs, namely the green $\\operatorname{SCC}\\{p\\}$, the blue $\\operatorname{SCC}\\{q\\}$ and the red $\\operatorname{SCC}\\{r, s, t\\}$. The red SCC is well-behaved since any run starting in $r$ ends in a final state if and only if its length is even. The other SCCs are also wellbehaved and therefore, the entire automaton is well-behaved. State $p$ is a transient state and $U(\\mathcal{A})=\\{q, r, s, t\\}$.\n\nTHEOREM 3.2. Let $L \\subseteq \\Sigma^{*}$ be regular and $\\mathcal{B}$ be any $r D F A$ for $L$.\n(1) If $\\mathcal{B}$ is well-behaved then $\\mathrm{V}_{L}(n)=O(\\log n)$ and $\\mathrm{F}_{L}(n)=O(\\log n)$.\n(2) If $\\mathcal{B}$ is not well-behaved then $\\mathrm{V}_{L}(n)=\\Omega(n)$ and $\\mathrm{F}_{L}(n)=\\Omega^{\\infty}(n)$.\n(3) If $U(\\mathcal{B})$ is well-behaved then $\\mathrm{F}_{L}(n)=O(1)$.\n(4) If $U(\\mathcal{B})$ is not well-behaved then $\\mathrm{F}_{L}(n)=\\Omega^{\\infty}(\\log n)$.\n(5) If $L \\in\\left\\{\\emptyset, \\Sigma^{*}\\right\\}$ then $\\mathrm{V}_{L}(n)=O(1)$.\n(6) If $L \\notin\\left\\{\\emptyset, \\Sigma^{*}\\right\\}$ then $\\mathrm{V}_{L}(n)=\\Omega(\\log n)$.\n\nTheorem 3.2 implies that $\\mathrm{F}_{L}(n)$ is either $\\Theta(1), \\Theta^{\\infty}(\\log n)$, or $\\Theta^{\\infty}(n)$, and $\\mathrm{V}_{L}(n)$ is either $\\Theta(1)$, $\\Theta(\\log n)$, or $\\Theta(n)$. For the characterizations in Theorem 1.3 it remains to prove:\n\nTHEOREM 3.3. Let $L \\subseteq \\Sigma^{*}$ be regular.\n(i) $\\mathrm{F}_{L}(n)=O(1) \\Longleftrightarrow L \\in\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$.\n(ii) $\\mathrm{F}_{L}(n)=O(\\log n) \\Longleftrightarrow L \\in\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$.\n\nIn the rest of Section 3 we prove Theorem 3.2 and Theorem 3.3. We start with the path summary algorithm, which is our main deterministic SW-algorithm for the variable-size model.\n\n![img-2.jpeg](img-2.jpeg)\n\nFigure 3. Another rDFA partitioned into two SCCs.",
      "tables": {},
      "images": {
        "img-1.jpeg": "data:image/jpeg;base64,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QAR2oAwPCvg7RvB2n/ZNJtQm4gyzOd0kp9Wb+nAHaugoooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAExVS/wBOtNTspbO+tYbm2lGHimUMp/A/5FXKKAPLp/hRf6HcSXfgTxLdaOXYs1jcfvrdj9DnH1IY/Smi7+L+m/upNC0LVQOPNt5/KLe53MB+lep0UmkxNJnln9p/F+7/AHcXhbRLDPHm3F0JAPwR/wClJ/wrPxL4lZT438WSz2xOW0/TB5MR9i2BuH/Ac+9eqUUWQcqMzRPD+l+HLBbHSLGG0t152xj7x9SerH3Oa0qWimMKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoooPSgClqmr6founSX+pXkVrax/ellbAHt7n261zy/EzwmCgm1KW2MgDRLc2c0RlBIA2B0G/kjgZrj3c+OvjnLp92PM0fw1D5iwMMpJcEDkjvgnI/3Pek+IRTXfi94G8OocrbSNfzoPQHcAfTiJv8AvqgD1/NFNBzilJAoA8T+ItppVx8aPCUDRWts0KtqF/csFTMaHcDI3HAETdT3r0fQvH/hfxJqkumaTqqTXkS7jCYnjJX1Xco3D6Z45rzfT9Lj8afH/Xrq5/eaZo8ccLRH7ruuNqn23q7fVQDwTVvxGBP+0l4WjtFHnw2TNcOo6LiU4b8Dj/gVAHsdFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUHpRTXYIjOeigk0Aclr3jZLDXoPDukae+ra5KvmNbRyeUkEf8AfkkIO0e2CenHIzRs/Ht+vjuy8I6noK2+o3EZmMsF4JYVhCsd2dobJZdu0gdjmud+BYOrW3iHxZdfPf6lqDIzHkqigMAD6ZfGPRR6VH4Eu4vFPxw8V+IIXElrZW6WduQcggkKGX2Pluf+BUAex0UZooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKD0NFB6UAeSW+h+KvCPxP13V9K0BdW0/WlDhlukh8mTOTu3c4yW6A8Y9MVUk8LeMNH+K1r4mTSo9baezKzvHcrAkcpBBC7uQqjAHGSOeua9l6ijGaAPOvF+ueMNF8TeFDYx2TaVfXMVpeQoN7CVz82CcHaFBIIx935hivRe3IrEg0myn8TT6rNEZbyBVjheSRmESlcnYpO1Se5ABI46VuHpQB494GsPFng7+27q+8I3N7f6zcm7DW15AFDEk+W5ZxtwSTkbh81dL4H8Gahp2t6n4q8RyQy6/qZ2ssRyltEMYjU9+ign/ZHvnuzS0AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUHpRRQB5nofwrvtBlvtPsvE9xD4bu5zM9hHABLgjBQTEkgEYBIAJA7dasaH8Nb/w94u1XVNN8RG107UrhZ5rKK0TJ2kkIHOcKNzDgDg9iAa9EooAQDjmloooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9k=",
        "img-2.jpeg": "data:image/jpeg;base64,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QUB7CnUUAN24GAOKXHTpS0UAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFB6UUUAeLfEi9s5vjL4Str2RY7TSoW1CeTGdvJKjAySSY0AA5JYAda7XRPiRpeseJ/8AhHpLDVdN1Bo/Nhj1C38rzlHOV5J6AnnHQ1xfhqwh8V/HvxRrU4ElvoxS3iQ8gSAbAefQo59jg9hU2uf8TT9pLw9b2oDNptgZLpl/gBEhAP8A32n/AH1QB7FRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABSHO04xntmlooA8q8I+EvG/gyDU/s8Wh6hc6pObmSaW6lj8mQ54OEO9ec8bTkmuk8F+CG8N3F/quo3g1DXdTk8y8u9m1QOyIOyj9cD0GOxooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//2Q=="
      }
    },
    {
      "section_id": 22,
      "text": "# 3.3 The path summary algorithm \n\nIn the following, let $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ be a right-deterministic finite automaton. We call a run $\\pi$ internal if $\\pi$ is a $P$-run for some SCC $P$. The SCC-factorization of $\\pi$ is the unique factorization $\\pi=\\pi_{k} \\tau_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1}$, where every $\\pi_{i}$ is an internal (possibly empty) run but cannot be extended to an internal run. The $\\tau_{i}$ are single transitions (i.e., runs from $Q \\Sigma Q$ ) connecting distinct SCCs. Let $p_{k}, \\ldots, p_{1} \\in Q$ be the starting states of the runs $\\pi_{k}, \\ldots, \\pi_{1}$. Then, the path summary of $\\pi$ is defined as\n\n$$\n\\operatorname{ps}(\\pi)=\\left(\\left|\\pi_{k}\\right|, p_{k}\\right)\\left(\\left|\\tau_{k-1} \\pi_{k-1}\\right|, p_{k-1}\\right) \\cdots\\left(\\left|\\tau_{2} \\pi_{2}\\right|, p_{2}\\right)\\left(\\left|\\tau_{1} \\pi_{1}\\right|, p_{1}\\right)\n$$\n\nwhich is a sequence of pairs from $\\mathbb{N} \\times Q$. It specifies the first state that is visited in an SCC, and the length of the run until reaching the next SCC or the end of the word, respectively. The leftmost length $\\left|\\pi_{k}\\right|$ can be zero but all other lengths $\\left|\\tau_{i} \\pi_{i}\\right|=1+\\left|\\pi_{i}\\right|$ are strictly positive. We define $\\pi_{w, q}$ to be the unique run of $\\mathcal{B}$ on a word $w \\in \\Sigma^{*}$ starting from $q$, and $\\operatorname{PS}_{\\mathcal{B}}(w)=\\left\\{\\operatorname{ps}\\left(\\pi_{w, q}\\right) \\mid q \\in Q\\right\\}$.\n\nEXAMPLE 3.4. Consider the rDFA $\\mathcal{B}$ in Figure 3. For the moment, the final states are irrelevant. It consists of two SCCs, namely the blue SCC $\\{p, q\\}$ and the red $\\operatorname{SCC}\\{r\\}$. All its runs on the word $w=a a b a b b$ are listed here:\n\n$$\n\\begin{aligned}\n& r \\stackrel{a}{\\leftarrow} r \\stackrel{a}{\\leftarrow} q \\stackrel{b}{\\leftarrow} p \\stackrel{a}{\\leftarrow} p \\stackrel{b}{\\leftarrow} q \\stackrel{b}{\\leftarrow} p \\\\\n& r \\stackrel{a}{\\leftarrow} r \\stackrel{a}{\\leftarrow} r \\stackrel{b}{\\leftarrow} r \\stackrel{a}{\\leftarrow} q \\stackrel{b}{\\leftarrow} p \\stackrel{b}{\\leftarrow} q \\\\\n& r \\stackrel{a}{\\leftarrow} r \\stackrel{a}{\\leftarrow} r \\stackrel{b}{\\leftarrow} r \\stackrel{a}{\\leftarrow} r \\stackrel{b}{\\leftarrow} r \\stackrel{b}{\\leftarrow} r\n\\end{aligned}\n$$\n\nThen, $\\mathrm{PS}_{\\mathcal{B}}(w)$ contains the path summaries $(1, r)(5, p),(3, r)(3, q)$ and $(6, r)$.\nThe path summary algorithm for $\\mathcal{B}$ is a streaming algorithm over $\\Sigma_{\\downarrow}$ described in Algorithm 1. The data structure at time instant $t$ is denoted by $S_{t}$. The acceptance condition will be defined later.\n\nLEMMA 3.5. Algorithm 1 correctly maintains $\\mathrm{PS}_{\\mathcal{B}}(w)$ for the active window $w \\in \\Sigma^{*}$.\nPROOF. Initially $\\mathrm{PS}_{\\mathcal{B}}(\\varepsilon)$ contains the path summary of every empty run from every state, which is formally $\\{0\\} \\times Q$.\n\nAssume $S_{t-1}=\\mathrm{PS}_{\\mathcal{B}}(w)$ for some window $w \\in \\Sigma^{*}$ and that $a \\in \\Sigma$ is the incoming symbol. The claim is that the algorithm computes $S_{t}=\\mathrm{PS}_{\\mathcal{B}}(w a)$ from $S_{t-1}$. Suppose that $\\pi^{\\prime}$ is a run in $\\mathcal{B}$ on $w a$.\n\n```\n    Input: sequence of operations }\\mp@subsup{\\sigma}{1}{\\sigma_{2}\\sigma_{3}} \\cdots \\in \\Sigma_{\\downarrow}^{\\omega}\\)\n    \\(S_{0}=\\{0\\} \\times Q\\)\n    foreach \\(t \\geqslant 1\\) do\n        \\(S_{t}=\\emptyset\\)\n        if \\(\\sigma_{t} \\in \\Sigma\\) then\n            for \\(p_{0} \\in Q\\) do\n                let \\(p_{1}=\\sigma_{t} \\cdot p_{0}\\) and \\(\\left(\\ell_{k}, p_{k}\\right) \\cdots\\left(\\ell_{1}, p_{1}\\right) \\in S_{t-1}\\)\n                if \\(p_{0}\\) and \\(p_{1}\\) are strongly connected then\n                    add \\(\\left(\\ell_{k}, p_{k}\\right) \\cdots\\left(\\ell_{2}, p_{2}\\right)\\left(\\ell_{1}+1, p_{0}\\right)\\) to \\(S_{t}\\)\n                else\n                    add \\(\\left(\\ell_{k}, p_{k}\\right) \\cdots\\left(\\ell_{1}, p_{1}\\right)\\left(1, p_{0}\\right)\\) to \\(S_{t}\\)\n    if \\(\\sigma_{t}=\\downarrow\\) then\n            if \\(S_{t-1}=\\{0\\} \\times Q\\) then\n                \\(S_{t}=S_{t-1}\\)\n            else\n                for \\(\\left(\\ell_{k}, p_{k}\\right) \\cdots\\left(\\ell_{1}, p_{1}\\right) \\in S_{t-1}\\) do\n                    if \\(\\ell_{k} \\geqslant 1\\) then\n                        add \\(\\left(\\ell_{k}-1, p_{k}\\right)\\left(\\ell_{k-1}, p_{k-1}\\right) \\cdots\\left(\\ell_{1}, p_{1}\\right)\\) to \\(S_{t}\\)\n                    else\n                        add \\(\\left(\\ell_{k-1}-1, p_{k-1}\\right)\\left(\\ell_{k-2}, p_{k-2}\\right) \\cdots\\left(\\ell_{1}, p_{1}\\right)\\) to \\(S_{t}\\)\n```\n\nAlgorithm 1. The path summary algorithm\n\nIt can be factorized as $\\pi^{\\prime}=\\pi p_{1} a p_{0}$ with $\\operatorname{ps}(\\pi) \\in S_{t-1}$. Let $\\pi=\\pi_{k} \\tau_{k-1} \\pi_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1}$ be the SCC-factorization of $\\pi$. If $p_{0}$ and $p_{1}$ are strongly connected then the SCC-factorization of $\\pi^{\\prime}$ is $\\pi^{\\prime}=$ $\\pi_{k} \\tau_{k-1} \\pi_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1}^{\\prime}$ where $\\pi_{1}^{\\prime}=\\pi_{1} p_{1} a p_{0}$, and otherwise $\\pi^{\\prime}=\\pi_{k} \\tau_{k-1} \\pi_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1} p_{1} a p_{0}$. In this way the algorithm computes $\\operatorname{ps}\\left(\\pi^{\\prime}\\right)$ from $\\operatorname{ps}(\\pi)$.\n\nNow, consider the case $a=\\downarrow$. We have $w=\\varepsilon$ if and only if $\\mathrm{PS}_{\\mathcal{B}}(w)=\\{0\\} \\times Q$, and in this case the set of path summaries is unchanged, i.e., we set $S_{t}=S_{t-1}$. Otherwise assume $w=b v$ for some $b \\in \\Sigma$. We claim that the algorithm computes $S_{t}=\\mathrm{PS}_{\\mathcal{B}}(v)$ from $S_{t-1}$. Suppose that $\\pi^{\\prime}$ is a run in $\\mathcal{B}$ on $v$ which ends in state $p \\in Q$. If $q=\\delta(b, p)$ in $\\mathcal{B}$ then let $\\pi=q b p \\pi^{\\prime}$. We have $\\operatorname{ps}(\\pi) \\in S_{t-1}$. Let $\\pi=\\pi_{k} \\tau_{k-1} \\pi_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1}$ be the SCC-factorization of $\\pi$. If $\\left|\\pi_{k}\\right| \\geqslant 1$ then $\\pi^{\\prime}=\\pi_{k}^{\\prime} \\tau_{k-1} \\pi_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1}$ is the SCC-factorization of $\\pi^{\\prime}$ where $\\pi_{k}=q b p \\pi_{k}^{\\prime}$. Otherwise $\\pi_{k}$ is empty and $\\tau_{k-1}=q b p$. Therefore, $\\pi^{\\prime}=\\pi_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1}$ is the SCC-factorization of $\\pi^{\\prime}$. In this way the algorithm computes $\\operatorname{ps}\\left(\\pi^{\\prime}\\right)$ from $\\operatorname{ps}(\\pi)$.\n\nObserve that Algorithm 1 cannot be directly adapted to work for (left-)DFA: For a pop operation, one would need to remove the first transition from each path summary, which is generally not possible since a path summary does not store its second state.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 23,
      "text": "# 3.4 Proof of Theorem 3.2(1) \n\nUsing the path summary algorithm we can prove Theorem 3.2(1):\nPROPOSITION 3.6. If $\\mathcal{B}$ is well-behaved then the regular language $L=\\mathrm{L}(\\mathcal{B})$ has space complexity $\\mathrm{V}_{L}(n)=O\\left(|\\mathcal{B}|^{2} \\cdot \\log n\\right)$, which is $O(\\log n)$ for a fixed $\\mathcal{B}$.\n\nPROOF. Let $\\mathcal{B}$ be well-behaved. Call a path summary accepting if it is the path summary of some accepting run. The variable-size sliding window algorithm for $L$ is the path summary algorithm for $\\mathcal{B}$ where the algorithm accepts if the path summary starting in $q_{0}$ is accepting.\n\nFor the correctness of the algorithm it suffices to show that any run $\\pi$ starting in $q_{0}$ is accepting if and only if $\\mathrm{ps}(\\pi)$ is accepting. The direction from left to right is immediate by definition. For the other direction, consider the path summary $\\operatorname{ps}(\\pi)=\\left(\\ell_{k}, p_{k}\\right) \\cdots\\left(\\ell_{1}, p_{1}\\right)$ and the SCC-factorization $\\pi=\\pi_{k} \\tau_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1}$. Since ps $(\\pi)$ is accepting, there is an accepting run $\\pi_{k}^{\\prime}$ that starts in $p_{k}$ and has length $\\ell_{k}$. Since $\\mathcal{B}$ is well-behaved, the SCC of $p_{k}$ is well-behaved. Therefore, since $\\pi_{k}^{\\prime}$ is accepting and $\\left|\\pi_{k}\\right|=\\left|\\pi_{k}^{\\prime}\\right|=\\ell_{k}, \\pi_{k}$ must also be accepting and thus $\\pi$ is accepting.\n\nWe claim that the space complexity of the path summary algorithm is bounded by $O\\left(|\\mathcal{B}|^{2}\\right.$. $\\left.(\\log n+\\log |\\mathcal{B}|)\\right)$. Observe that $\\mathrm{PS}_{\\mathcal{B}}(w)$ contains $|\\mathcal{B}|$ path summaries, and a single path summary $\\mathrm{ps}(\\pi)$ consists of a sequence of at most $|\\mathcal{B}|$ states and a sequence $\\left(\\ell_{k}, \\ldots, \\ell_{1}\\right)$ of $k \\leqslant|\\mathcal{B}|$ numbers up to $|\\pi|$. Hence, the path summary $\\operatorname{ps}(\\pi)$ can be encoded using $O(|\\mathcal{B}| \\cdot(\\log |\\mathcal{B}|+\\log |\\pi|))$ bits, which yields the total space complexity $O\\left(|\\mathcal{B}|^{2} \\cdot(\\log n+\\log |\\mathcal{B}|)\\right)$.\n\nTo reduce the space complexity to $O\\left(|\\mathcal{B}|^{2} \\cdot \\log n\\right)$ we need to make a case distinction. The algorithm maintains the window size $n \\in \\mathbb{N}$ and the maximal suffix of the window of length up to $|\\mathcal{B}|$ (explicitly) using $O(\\log n+|\\mathcal{B}|)$ bits. If $n \\leqslant|\\mathcal{B}|$ then this information suffices to test membership of the window to $L$. As soon as $n$ exceeds $|\\mathcal{B}|$ we initialize $\\mathrm{PS}_{\\mathcal{B}}(w)$ and use the path summary algorithm as described above. If $n>|\\mathcal{B}|$ then its space complexity is $O\\left(|\\mathcal{B}|^{2} \\cdot(\\log n+\\log |\\mathcal{B}|)\\right) \\subseteq O\\left(|\\mathcal{B}|^{2} \\cdot \\log n\\right)$.\n\nObserve that the path summary algorithm only stores $O(\\log n)$ bits where $n$ is the current (not the maximum) window size.\n\nBefore we continue with the proof of the other points from Theorem 3.2, we discuss some implementation details for our logspace SW-algorithm. ${ }^{4}$ To implement the path summary algorithm on a realistic computation model, we have to be able to efficiently determine whether\n\n[^0]\n[^0]:    4 These details are not needed for the proof of Proposition 3.6 since we abstract from internal computations in our sliding window model; see Remark 2.7.\n\na path summary is accepting. Given a number $d \\geqslant 1$, a set of natural numbers $X \\subseteq \\mathbb{N}$ is $d$-periodic if we have $x \\in X$ if and only if $x+d \\in X$.\n\nLEMMA 3.7. Let $P \\subseteq Q$ be a well-behaved subset in $\\mathcal{B}$ and $p_{0} \\in P$ be nontransient. Then $\\operatorname{Acc}\\left(P, p_{0}\\right):=\\left\\{|\\pi|: \\pi\\right.$ is an accepting $P$-run starting in $\\left.p_{0}\\right\\}$ is $d$-periodic for some $\\left.d \\leqslant|Q|\\right$.\n\nPROOF. Let $\\pi_{0}$ be any nonempty run from $p_{0}$ to $p_{0}$, which exists because $p_{0}$ is nontransient. Furthermore, we can choose $\\pi_{0}$ such that its length $d:=\\left|\\pi_{0}\\right|$ is at most $|Q|$.\n\nIf $\\ell \\in \\operatorname{Acc}\\left(P, p_{0}\\right)$, then there exists an accepting $P$-run $\\pi$ starting in $p_{0}$ of length $\\ell$. Then $\\pi \\pi_{0}$ is also an accepting $P$-run and we conclude $\\left|\\pi \\pi_{0}\\right|=\\ell+d \\in \\operatorname{Acc}\\left(P, p_{0}\\right)$.\n\nNow we need to show that $\\ell \\notin \\operatorname{Acc}\\left(P, p_{0}\\right)$ implies $\\ell+d \\notin \\operatorname{Acc}\\left(P, p_{0}\\right)$. Towards a contradiction assume that $\\ell \\notin \\operatorname{Acc}\\left(P, p_{0}\\right)$ and $\\ell+d \\in \\operatorname{Acc}\\left(P, p_{0}\\right)$, i.e., there exists an accepting $P$-run $\\pi$ starting in $p_{0}$ of length $\\ell+d$. Factorize $\\pi=\\pi_{1} \\pi_{2}$ where $\\left|\\pi_{2}\\right|=\\ell$. Now $\\pi_{2}$ must be rejecting since $\\ell \\notin \\operatorname{Acc}\\left(P, p_{0}\\right)$. But then $\\pi_{2} \\pi_{0}$ is a rejecting $P$-run of length $\\ell+d$, which contradicts the wellbehavedness of $P$ since $\\ell+d \\in \\operatorname{Acc}\\left(P, p_{0}\\right)$.\n\nIn the following we describe how to implement the algorithm from Proposition 3.6. We do the following preprocessing on the well-behaved rDFA $\\mathcal{B}$. Using depth-first search we compute all SCCs in $\\mathcal{B}$. For every SCC $P$ we pick a state $p \\in P$ and compute the distance $\\operatorname{dist}(p, q)$ from $p$ to all states $q \\in P$ using any shortest path algorithm. Furthermore let $d$ be the minimal length of a nonempty run from $p$ to $p$ itself, which is the period $d$ from Lemma 3.7. If no such run exists then we store the information that $p$ is transient. Otherwise we assign to each state $q \\in P$ the distance from $p$ modulo $d$. By traversing an arbitrary $P$-run of length $d$ from $p$ we can compute a bit vector of length $d$ which represents $\\operatorname{Acc}\\left(P, p_{0}\\right)$. Using this information we can easily answer whether a path summary $\\left(\\ell_{k}, p_{k}\\right) \\cdots\\left(\\ell_{1}, p_{1}\\right)$ is accepting: it is accepting if and only if either $p_{k}$ is transient, $\\ell_{k}=0$ and $p_{k} \\in F$, or $\\operatorname{dist}\\left(p_{0}, p_{k}\\right)+\\ell_{k} \\bmod d$ belongs to $\\operatorname{Acc}\\left(P, p_{0}\\right)$ where $P$ is the SCC of $p_{k}$ and $p_{0}$ is the picked state in $P$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 24,
      "text": "# 3.5 Proof of Theorem 3.2(2) \n\nWe continue with proving a linear lower bound for rDFA which are not well-behaved.\nLEMMA 3.8. If $\\mathcal{B}$ is not well-behaved then there exist words $u_{1}, u_{2}, v_{1}, v_{2}, z \\in \\Sigma^{*}$ where $\\left|u_{i}\\right|=\\left|v_{i}\\right|$ for $i \\in\\{1,2\\}$ such that $L=\\mathrm{L}(\\mathcal{B})$ separates $u_{2}\\left\\{u_{1} u_{2}, v_{1} v_{2}\\right\\}^{*} z$ and $v_{2}\\left\\{u_{1} u_{2}, v_{1} v_{2}\\right\\}^{*} z$.\n\nPROOF. The automaton structure is illustrated in Figure 4. Since $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ is not well-behaved, there is a reachable SCC $S$ that is not well-behaved. Take a state $p \\in S$ and a word $z \\in \\Sigma^{*}$ with\n\n$$\np \\stackrel{z}{\\leftarrow} q_{0}\n$$\n\n![img-3.jpeg](img-3.jpeg)\n\nFigure 4. Forbidden pattern for well-behaved rDFAs where $\\left|u_{1}\\right|=\\left|v_{1}\\right|$ and $\\left|u_{2}\\right|=\\left|v_{2}\\right|$.\n\nMoreover, since $S$ is strongly connected and not well-behaved there are states $q \\in S \\cap F, r \\in S \\backslash F$ and nonempty words $u_{2}, v_{2} \\in \\Sigma^{*}$ such that $\\left|u_{2}\\right|=\\left|v_{2}\\right|$ and\n\n$$\nq \\stackrel{u_{2}}{\\longleftarrow} p \\stackrel{z}{\\longleftarrow} q_{0} \\quad \\text { and } \\quad r \\stackrel{v_{2}}{\\longleftarrow} p \\stackrel{z}{\\longleftarrow} q_{0}\n$$\n\nFinally, since $S$ is strongly connected, there are words $u_{1}, v_{1} \\in \\Sigma^{*}$ such that\n\n$$\np \\stackrel{u_{1}}{\\longleftarrow} q \\stackrel{u_{2}}{\\longleftarrow} p \\stackrel{z}{\\longleftarrow} q_{0} \\quad \\text { and } \\quad p \\stackrel{v_{1}}{\\longleftarrow} r \\stackrel{v_{2}}{\\longleftarrow} p \\stackrel{z}{\\longleftarrow} q_{0}\n$$\n\nWe can ensure that $\\left|u_{1}\\right|=\\left|v_{1}\\right|$ and hence also $|u|=|v|$ for $u=u_{1} u_{2}, v=v_{1} v_{2}$. If $k=|u|$ and $\\ell=|v|$ we replace $u_{1}$ by $u^{\\ell-1} u_{1}$ and $v_{1}$ by $v^{k-1} v_{1}$ (note that $k>0$ and $\\ell>0$ since $u$ and $v$ are nonempty), which preserves all properties above. Then, $u_{2}\\left\\{u, v\\right\\}^{*} z$ and $v_{2}\\left\\{u, v\\right\\}^{*} z$ are separated by $L$.\n\nWe can now show Theorem 3.2(2):\nPROPOSITION 3.9. If $\\mathcal{B}$ is not well-behaved then the language $L=\\mathrm{L}(\\mathcal{B})$ satisfies $\\mathrm{F}_{L}(n)=\\Omega^{\\infty}(n)$ and $\\mathrm{V}_{L}(n)=\\Omega(n)$.\n\nPROOF. Let $u_{1}, u_{2}, v_{1}, v_{2}, z \\in \\Sigma^{*}$ be the words from Lemma 3.8 and let $u=u_{1} u_{2}$ and $v=v_{1} v_{2}$. Now, consider an SW-algorithm $\\mathcal{P}_{n}$ for $L$ and window size $n=\\left|u_{2}\\right|+|u| \\cdot(m-1)+|z|$ for some $m \\geqslant 1$. We prove that $\\mathcal{P}_{n}$ has at least $2^{m}$ many states by showing that $\\mathcal{P}_{n}(x) \\neq \\mathcal{P}_{n}(y)$ for any $x, y \\in\\{u, v\\}^{m}$ with $x \\neq y$. Notice that $\\left|\\left\\{u, v\\right\\}^{m}\\right|=2^{m}$ since $u \\neq v$ and $|u|=|v|$.\n\nRead two distinct words $x, y \\in\\{u, v\\}^{m}$ into two instances of $\\mathcal{P}_{n}$. Consider the right most $\\{u, v\\}$-block where $x$ and $y$ differ. Without loss of generality assume $x=x^{\\prime} u s$ and $y=y^{\\prime} v s$ for some $x^{\\prime}, y^{\\prime}, s \\in\\{u, v\\}^{*}$ with $\\left|x^{\\prime}\\right|=\\left|y^{\\prime}\\right|$. By reading $x^{\\prime} z$ into both instances the window of the $x$-instance becomes last ${ }_{n}\\left(x x^{\\prime} z\\right)=u_{2} s x^{\\prime} z$ and the window of the $y$-instance becomes last ${ }_{n}\\left(y x^{\\prime} z\\right)=v_{2} s x^{\\prime} z$. By Lemma 3.8 the two windows are separated by $L$, and therefore the algorithm $\\mathcal{P}_{n}$ must accept one of the streams $x x^{\\prime} z$ and $y x^{\\prime} z$, and reject the other. In conclusion $\\mathcal{P}_{n}(x) \\neq \\mathcal{P}_{n}(y)$ and hence $\\mathcal{P}_{n}$ must use at least $m=\\Omega(n)$ bits. This holds for infinitely many $n$, namely all $n$ of the form $\\left|u_{2}\\right|+|z|+|u| \\cdot(m-1)$ for some $m \\geqslant 1$.\n\nThe argument above shows that there exist numbers $c, d \\in \\mathbb{N}$ such that for all $m \\geqslant 1$ we have $\\mathrm{V}_{L}(c m+d) \\geqslant \\mathrm{F}_{L}(c m+d)=\\Omega(m)$. If $n \\geqslant d$ then $m=\\lfloor(n-d) / c\\rfloor=\\Omega(n)$ satisfies $c m+d \\leqslant n$. Therefore, $\\mathrm{V}_{L}(n) \\geqslant \\mathrm{V}_{L}(c m+d)=\\Omega(m)$ by monotonicity of $\\mathrm{V}_{L}$ and hence $\\mathrm{V}_{L}(n)=\\Omega(n)$.\n\nFrom Proposition 3.6 and Proposition 3.9 we obtain:\n\nCOROLLARY 3.10. Let $\\mathrm{X} \\in\\{\\mathrm{F}, \\mathrm{V}\\}$. A regular language $L \\subseteq \\Sigma^{*}$ satisfies $\\mathrm{X}_{L}(n)=O(\\log n)$ if and only if $L$ is recognized by a well-behaved $r D F A$.",
      "tables": {},
      "images": {
        "img-3.jpeg": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wAARCAFfAckDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD3+iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAA9Kyta8RaT4csDe6xqEFnB0DSn7x9FHUn2AJrF8a+NG8Npa6dptr/aHiDUTssbFe57u/PCD+h7AkeZR21xL4maCO2Txj44HNzc3R/wCJfpXP3QMYJHoOcjgZGKAO2X4o32rnPhXwZrGrQkkLczYtYJPdXbOR9cUf8JR8TFO8/D62ZR1jXV4t2Pr0/So4/hnqWs/vfF3i3U752HzWdk/2a3Uf3dq9QPXipT8EfAYTK6ZcJKOfOF7Lu+v3sUAIPiuNMkEfizwzq+ggkA3Dxefbg/8AXRBz+ArudN1Sx1iyjvdOvILu2f7skLh1+mR39RXn8/w+8QaHE7+E/Fd3JFjDaZrR+028g7pnqox6Dn1rkLBbq28Qz/8ACP2v/CL+M4V8y50KV82eqIOpi7ZPJGPfB4JAB75RXN+DvF9r4v0k3MUbW17buYb6ylGHt5RwVI64yDg9/Y5A6SgAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAqrf38Gmadc393JstreJppHPZVBJP5Varz74yTyDwINMhYpLq19b2CsP9t8n9FI/GgDgIbzVr4R6vCCni/wAZO0Wnkn/kHaep5Yeny8579RznPsfhTwvpvhDRIdL02LCrzLKR88z93Y9yf0HFcf4PtIb/AOK3iW/RR9n0W3g0eyX+4oXLgemCP1r0zAHagAwKbnvzj2rF8YeI4/CnhPUdbkQSfZYsohPDuSFQH2LEV5xf6FbWnwp1HxX4pX+0NfubE3P2idjm2dx+6SLH+r2lk6dTn2oA9h6jGfyrmPG3g638XaQEV/suqWh82wvV4e3lHIORztOBke2eoFM+Gmmvpnw50OCUkyyWwuJCTyWkJkOf++sV1mOKAPBbXxDPp95ZeO3iFteWtz/Y3iq1UYBIO1ZsDjg4/HAHQ595VgwBU5UjORXkHifR4z8SNd0hVH2bxRoLNt7faYQdpx6gAH8a7P4Y6o2sfDbQLyRiXNsImY9SYyYyfx20AddRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABXnXxc/dWXhW6bPl2/iSzkl9lG7n+X516LXJfEjQZfEngDVrC3VjdiMTQBepkQhwB7nbj8aAMb4bnyfFvj6zf/AFy6x55H+xIpK/oDXo1eLaB4lht/Gmi+LS6ppni2yS0u36LDfRfKM+gONo+ua9mVi3/16AOR+Jvhu98V+A9Q0nTsG8fZJErNtDlXDbc9BnHGa88+I1x4i1rwbouk6npn9jm8vbeyS2E6yPNKer/LkCMYwATklgcDaM+5kcGuN8ZeDr7xLq+g6hY6rBZNo8zXCRzWxlSRztxkBlxjb+tAHXwxJBDHDEu2ONQir6AcD9Kk7VFGXESeYVLgDcQMAnvjk/zNOLbVLEgADJJoA848Szxr8avDDEj/AEPTby4lz2QqQCfbINWvgpE0Xwl0TeCC3nMAewMz4/xrzzXvEaXVp4w8aLIojv4x4e0ZmO0SJn97ICeg6sCenINeleG/FPgzQPDmm6TH4p0ZhZ2yRE/bY/mIGCevc8/jQB3NFUtP1Wx1e2W5028gu7cnAlgcOhPfkdfwq7QAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABSUtFAHiPizQLPwtqGoWGpRMPBXiGXzPPRcnS7zs4x0Qn/AA4A+boPDXji48O3UHhrxtMkc5UfYNX3f6PfxjgEv0D4Izk8/iN3ot7YWmo2M1le20dxbTIUkilXcrD3ryvVPA2u+G7GWx0i0g8TeF3OW0S/fEsH/XGQ9O+OQR2yTmgD1pXDgFWyp5BHOR607oK+eLPVNM0Of7NpXi/xB4MmB/5Bet2RuIVPcJkEKPc81st4x10xfN8VfCoQ8b0tQX/75oA9qnmit4XmmkSONBlncgBR3JJ6CvJvE3ix/HSXWkaDd/Y/DUAP9sa+/wAsYjH3o4ifvE9M+/p15OW80jxBdrHd6x4k+IN2rArZWds1tZhuxdRjAz3HFWte0zW7O50HUfG9lbW3g9LkRSaNprYhsgRiNpQv3hu69uMfxYIBt+GPC1n4+uY7+8042/g/T7Z7LRbFwVaUMMPO3uex9cHqMngbP4U6rpXxJn0eAWM8lvCb2wOowF4LyMEDYw7Ebufp7ivpy2WFbeJbcIIQoEYjHy7e2MU2Wwtprq3uZIVM1uWMT45TcMHB9CO309KAOD0r4mW+nXUWjeMNMfw1fAbI2kwbSUDjKSDgD68D1r0JJFkVXRgyNggjoR9fSq2p6VYaxYSWWo2cF3bP1imQMufX2PvXnj+CvEngxzd+BNRNxYA7n0LUJN0ZHcRP/AfYn6k9KAPT6K43wx8RdM8Q3R0y6im0nXIx+9029GyTP+wTgOPpz3wBXYKSQP8ADFADqKKKAA9OKr3V5BY273F3PFBAmN0krBFUdOSferB6c9KyPE11b2HhbVby7iSaC2tZJmjkUMG2qWxg8HkCgC7ZajZ6jCZrG7guogdpkhkV1B9MjvzS2l9a38Xm2lzDcRbiN8Mgdcjtkf55ry/wYyeDP2fjqTsI5jZzXYbpl3z5f5/IKueDJLjwX8GNFmttNkvr2dY5Et4zt3vO+V3Ng7QAwyccAUAem0VyemeKdQ/4S/8A4RnWbCCG7ez+2wzWkxkidN20qdyqQQfbB9uldZQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFJgelLRQBDc2lteRGK6t4p4z/BKgYfkazB4R8NB948PaUH/AL32OPP8q2aKAI4oIoIlihiSONeiIoAH4CoNS0yz1bTLjTr2FZbW4jMckZ6EH+Xse1W6KAPNfAmp3XhnW5fh/rc+97dTJpF0xx9pt+fk5/iXpj0BHRcn0jPPXPauV8eeET4p0mN7OQW2s2D/AGjT7rvHIOcZ/unABo8CeLh4r0h/tMX2XV7F/I1Czb70Uo4zg84OCfbkdQaAOspMD0paKAOe8UeDNF8X2qxanbEzR8w3UR2TQnsVYc9ecdM9q45Nc8T/AA3kEPiXzdc8NggJq0KZnth2EyjqP9r9cnbXqWBTHjR0KsoZSCCCMg560AVtN1Sy1exhvdPuY7m2mGUkibcD/gfUdquV5nqXgzVvCd/JrngAoqu3mXehSNiC4Hcxf3G+mB+Hynp/CXjXTPF9o7Wpa3voDturCcbZrduhBX0z3/8A1UAdLWD4y0ObxL4P1PRredYJruEojvnaDnIzjnBxg1vUmBQB5XqHgLxP4g+HQ8O6pd6bbyWtpFBZxWpcxu8e3EkjEA9FK7QMDcTzwB12j3F94c8IRy+JpLCFbKFI8We9lCqAoHIyzEjAUDqcDNdNtHpWZrvhzSvEtillq1s08CSrKqrK8ZVxnBDIQe570AYeg2TLr7eIdc2watqa/ZbK1Y/NbW6hnEee7nBd+wOAOmT2FcxpXw88MaJqsOqWFhKl5AHEckl5PLt3DDcO5HOfSunoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAEPQ15z420W+0TWI/HvhyIve2ybdTslGPttv3OP76gfXgemD6P1pNoHIHNAGZoOu2XiTR7XVNNmWW1uE3KR1B7qR2IPBrUrynVLaf4V+IZte02EyeE9QkB1OzjGfscp4E0Y7KeMjt/3zj061vIb21hubWaOaCZQ8ciHIZDyCKALFFFFACYGDXE+LvAv9rXkevaFc/2X4lthuhu4x8s2P4JV/iU9M9vccV29JgUAcb4O8cHWp5tE1q2/szxLaDFxZueJR/z0iP8AEp68dPpzXZZ5rlfGngq38V20M8MzWGs2Z32WoRffib0PqpPUfWqXgzxlc395L4b8SQLZeJbMZkT+C7TtLEe4Pcdv0AB3FFJknFLQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQBFPbw3MDwzxJLFIpV0dcqwIwQQevHFeWxPdfCDVvJlMs/ga9l/duSXbS5GPQ9/LJ/wA5zu9XqveWNtf2ctpdQJNbyoY5I3GVZT2IoAdDOlxHHLE6yRSKGR0OVZSMggjgj396mryeKXUPhDfCC58698EXEn7qYAvJpjE/dbuYySf/ANf3vUba5ivIY7m3njmt5VDxyRkMrqehBHBBoAnooooATArk/G3guLxTYwzWsv2LWrE+ZYXycNGw/hPqp7iutpMCgDjPA3jKTXDcaNrMIsvEunHbeWpP3x0Eqeqnj6ZHqCe0rifHPhC51ZrbX9AkFr4l035raXgCde8T+qkE4z0yfU1oeCvGFv4w0YXSoba+gbyb6zcYe3lHVSOuODgn+YIoA6aiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKK43xR43uvDXiDR9NbRjcw6rcLbQ3CXIG1yQDlNucDOc1c8SeL08PaxoGl/ZGuLjWLryECyBfLUY3OeOQNw4oA6aikzQD/hQBFc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"
      }
    },
    {
      "section_id": 25,
      "text": "# 3.6 Proof of Theorem 3.2(3)-(6) \n\nNext, we study which regular languages have sublogarithmic complexity. Recall that in the variable-size model any such language must be empty or universal because the algorithm must at least maintain the current window size by Lemma 2.5.\n\nCOROLLARY 3.11. The empty language $L=\\emptyset$ and the universal language $L=\\Sigma^{*}$ satisfy $\\mathrm{V}_{L}(n)=O(1)$. All other languages satisfy $\\mathrm{V}_{L}(n)=\\Omega(\\log n)$.\n\nThis proves points (5) and (6) in Theorem 3.2. Now, we can turn to the fixed-size model and prove the points (3) and (4). Point (3) follows from:\n\nPROPOSITION 3.12. If $U(\\mathcal{B})$ is well-behaved then $L=\\mathrm{L}(\\mathcal{B})$ has space complexity $\\mathrm{F}_{L}(n)=$ $O(|\\mathcal{B}|)$, which is $O(1)$ when $\\mathcal{B}$ is fixed.\n\nPROOF. Let $k=|\\mathcal{B}|$. The SW-algorithm $\\mathcal{P}_{n}$ for $\\operatorname{SW}_{n}(L)$ maintains last ${ }_{k}(x)$ for an input stream $x \\in \\Sigma^{*}$ using $O(k)$ bits. If $n \\leqslant k$ then last ${ }_{n}(x)$ is a suffix of last ${ }_{k}(x)$ and hence $\\mathcal{P}_{n}$ can determine whether last $_{n}(x) \\in L$. If $n>k$ then last $_{k}(x)$ is a suffix of last $_{n}(x)$, say last $_{n}(x)=s$ last $_{k}(x)$. We can decide if last $_{n}(x) \\in L$ as follows: Consider the run of $\\mathcal{B}$ on last $_{n}(x)$ starting from the initial state:\n\n$$\nr \\stackrel{s}{\\leftarrow} q \\stackrel{\\text { last }_{k}(x)}{\\longleftarrow} q_{0}\n$$\n\nBy the choice of $k$ some state $p \\in Q$ must occur twice in the run $q \\stackrel{\\text { last }_{k}(x)}{\\longleftarrow} q_{0}$. Therefore, $p$ is nontransient and all states in the run $r \\stackrel{s}{\\leftarrow} q$ belong to $U(\\mathcal{B})$. Since $U(\\mathcal{B})$ is well-behaved, $r$ is final if and only if some run of length $|s|=n-k$ starting in $q$ is accepting. This information can be precomputed for each state $q$ in the fixed-size model.\n\nFor the lower bound in Theorem 3.2(4) we need the following lemma:\nLEMMA 3.13. If $U(\\mathcal{B})$ is not well-behaved then there exist words $x, y, z \\in \\Sigma^{*}$ where $|x|=|y|$ such that $L=\\mathrm{L}(\\mathcal{B})$ separates $x y^{*} z$ and $y^{*} z$.\n\nPROOF. Since $U(\\mathcal{B})$ is not well-behaved, there are $U(\\mathcal{B})$-runs $\\pi$ and $\\rho$ from the same starting state $q \\in U(\\mathcal{B})$ such that $|\\pi|=|\\rho|$ and exactly one of the runs $\\pi$ and $\\rho$ is accepting. By definition of $U(\\mathcal{B})$ the state $q$ is reachable from a nontransient state $p$ via some run $\\sigma$ such that $p$ is reachable from the initial state $q_{0}$, say $p \\stackrel{z_{0}}{\\longleftarrow} q_{0}$. We can replace $\\pi$ by $\\pi \\sigma$ and $\\rho$ by $\\rho \\sigma$ preserving the properties of being $U(\\mathcal{B})$-runs and $|\\pi|=|\\rho|$. Assume that $\\pi$ and $\\rho$ are runs on words $v \\in \\Sigma^{*}$ and $w \\in \\Sigma^{*}$, respectively. Since $p$ is nontransient, we can construct runs from $p$ to $p$ of unbounded lengths. Consider such a run $p \\stackrel{u}{\\longleftarrow} p$ of length $|u| \\geqslant|v|=|w|$. Then, $L$ separates\n\n$v u^{*} z_{0}$ and $w u^{*} z_{0}$. Factorize $u=u_{1} u_{2}$ so that $\\left|u_{2}\\right|=|\\nu|=|w|$. Notice that all words in $u_{2} u^{*} z_{0}$ reach the same state in $\\mathcal{B}$ and hence $u_{2} u^{*} z_{0}$ is either contained in $L$ or disjoint from $L$. Then, $L$ separates either $u_{2} u^{*} z_{0}$ and $v u^{*} z_{0}$, or $u_{2} u^{*} z_{0}$ and $w u^{*} z_{0}$. Hence, $L$ also separates $\\left(u_{2} u_{1}\\right)^{*} u_{2} z_{0}$ from either $v u_{1}\\left(u_{2} u_{1}\\right)^{*} u_{2} z_{0}$ or from $w u_{1}\\left(u_{2} u_{1}\\right)^{*} u_{2} z_{0}$. This yields the words $z=u_{2} z_{0}, y=u_{2} u_{1}$ and $x=v u_{1}$ or $x=w u_{1}$ with the claimed properties.\n\nPROPOSITION 3.14. If $U(\\mathcal{B})$ is not well-behaved then $L=\\mathrm{L}(\\mathcal{B})$ satisfies $\\mathrm{F}_{L}(n) \\geqslant \\log n-\\mathcal{O}(1)$ for infinitely many $n$. In particular, $\\mathrm{F}_{L}(n)=\\Omega^{\\infty}(\\log n)$.\n\nPROOF. Let $x, y, z \\in \\Sigma^{*}$ be the words from Lemma 3.13. Consider an SW-algorithm $\\mathcal{P}_{n}$ for $L$ and window size $n=|x|+|y| \\cdot m+|z|$ for some $m \\geqslant 1$. We prove that $\\mathcal{P}_{n}$ has at least $m$ many states by showing that $\\mathcal{P}_{n}\\left(x y^{i}\\right) \\neq \\mathcal{P}_{n}\\left(x y^{j}\\right)$ for any $1 \\leqslant i<j \\leqslant m$. Let $1 \\leqslant i<j \\leqslant m$. Then, we have\n\n$$\n\\operatorname{last}_{n}\\left(x y^{i} y^{m-i} z\\right)=\\operatorname{last}_{n}\\left(x y^{m} z\\right)=x y^{m} z\n$$\n\nand\n\n$$\n\\operatorname{last}_{n}\\left(x y^{j} y^{m-i} z\\right)=\\operatorname{last}_{n}\\left(x y^{m+j-i} z\\right)=y^{m+1} z\n$$\n\nSince exactly one of the words $x y^{m} z$ and $y^{m+1} z$ belongs to $L$, it also holds that exactly one of the streams $x y^{i} y^{m-i} z$ and $x y^{j} y^{m-i} z$ is accepted by $\\mathcal{P}_{n}$. This proves that $\\mathcal{P}_{n}$ must reach different memory states on inputs $x y^{i}$ and $x y^{j}$. In conclusion $\\mathcal{P}_{n}$ must use $\\log m \\geqslant \\log n-\\mathcal{O}(1)$ bits, and this holds for infinitely many $n$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 26,
      "text": "# 3.7 Characterization of constant space \n\nNext, we prove that a regular language $L$ has constant space complexity $\\mathrm{F}_{L}(n)$ if and only if it is a Boolean combination of suffix testable languages and regular length languages (Theorem 3.3(i)).\n\nThe language $L$ is called $k$-suffix testable if for all $x, y \\in \\Sigma^{*}$ and $z \\in \\Sigma^{k}$ we have $x z \\in L$ if and only if $y z \\in L$. Equivalently, $L$ is a Boolean combination of languages of the form $\\Sigma^{*} w$ where $w \\in \\Sigma^{\\leqslant k}$. Clearly, a language is suffix testable if and only if it is $k$-suffix testable for some $k \\in \\mathbb{N}$. Let us remark that the class of suffix testable languages corresponds to the variety $\\mathbf{D}$ of definite monoids [87]. Clearly, every finite language is suffix testable: If $k$ is the maximum length of a word in $L \\subseteq \\Sigma^{*}$ then $L$ is $(k+1)$-suffix testable since $L=\\bigcup_{w \\in L}\\{w\\}$ and $\\{w\\}=\\Sigma^{*} w \\backslash \\bigcup_{a \\in \\Sigma} \\Sigma^{*} a w$.\n\nWe will utilize a distance notion between states in a DFA, which is also studied in [51]. The symmetric difference of two sets $A$ and $B$ is $A \\Delta B=(A \\cup B) \\backslash(A \\cap B)$. We define the distance $d(K, L)$ of two languages $K, L \\subseteq \\Sigma^{*}$ by\n\n$$\nd(K, L)= \\begin{cases}\\sup _{u \\in K \\Delta L}|u|+1, & \\text { if } K \\neq L \\\\ 0, & \\text { if } K=L\\end{cases}\n$$\n\nNotice that $d(K, L)<\\infty$ if and only if $K \\triangle L$ is finite. For a DFA $\\mathcal{A}=\\left(Q, \\Sigma, q_{0}, \\delta, F\\right)$ and a state $p \\in Q$, we define $\\mathcal{A}_{p}=(Q, \\Sigma, p, \\delta, F)$. Moreover, for two states $p, q \\in Q$, we define the distance\n\n$d(p, q)=d\\left(L\\left(\\mathcal{A}_{p}\\right), L\\left(\\mathcal{A}_{q}\\right)\\right)$. If we have two runs $p \\xrightarrow{u} p^{\\prime}$ and $q \\xrightarrow{u} q^{\\prime}$ where $p^{\\prime} \\in F, q^{\\prime} \\notin F$ and $|u| \\geqslant|Q|^{2}$ then some state pair occurs twice in the runs and we can pump the runs to unbounded lengths. Therefore, $d(p, q)<\\infty$ implies $d(p, q) \\leqslant|Q|^{2}$. In fact $d(p, q)<\\infty$ implies $d(p, q) \\leqslant|Q|$ by [51, Lemma 1].\n\nLEMMA 3.15. Let $L \\subseteq \\Sigma^{*}$ be regular and $\\mathcal{A}=\\left(Q, \\Sigma, q_{0}, \\delta, F\\right)$ be its minimal DFA. We have:\n(i) for all $p, q \\in Q, d(p, q) \\leqslant k$ if and only if $\\forall z \\in \\Sigma^{k}: p \\cdot z=q \\cdot z$,\n(ii) $L$ is $k$-suffix testable if and only if $d(p, q) \\leqslant k$ for all $p, q \\in Q$,\n(iii) if there exists $k \\geqslant 0$ such that $L$ is $k$-suffix testable, then $L$ is $|Q|$-suffix testable.\n\nPROOF. The proof of (i) is an easy induction. If $k=0$, the statement is $d(p, q)=0$ if and only if $p=q$, which is true because $\\mathcal{A}$ is minimal. For the induction step, we have $d(p, q) \\leqslant k+1$ if and only if $d(\\delta(p, a), \\delta(q, a)) \\leqslant k$ for all $a \\in \\Sigma$ if and only if $\\delta(p, a) \\cdot z=\\delta(q, a) \\cdot z$ for all $z \\in \\Sigma^{k}$ if and only if $p \\cdot z=q \\cdot z$ for all $z \\in \\Sigma^{k+1}$.\n\nFor (ii), assume that $L$ is $k$-suffix testable and consider two states $p=\\mathcal{A}(x)$ and $q=\\mathcal{A}(y)$. If $z \\in \\mathrm{~L}\\left(\\mathcal{A}_{p}\\right) \\Delta \\mathrm{L}\\left(\\mathcal{A}_{q}\\right)$, then $|z|<k$ because $x z \\in L$ if and only if $y z \\notin L$ and $L$ is $k$-suffix testable.\n\nNow, assume that $d(p, q) \\leqslant k$ for all $p, q \\in Q$ and consider $x, y \\in \\Sigma^{*}, z \\in \\Sigma^{k}$. Since we have $d(\\mathcal{A}(x), \\mathcal{A}(y)) \\leqslant k$, (i) implies $\\mathcal{A}(x z)=\\mathcal{A}(y z)$, and in particular $x z \\in L$ if and only if $y z \\in L$. Therefore, $L$ is $k$-suffix testable.\n\nPoint (iii) follows from (ii) and from the above cited [51, Lemma 1].\nLEMMA 3.16. For any $L \\subseteq \\Sigma^{*}$ and $n \\geqslant 0$, the language $\\mathrm{SW}_{n}(L)$ is $2^{\\mathrm{F}_{L}(n)}$-suffix testable.\nPROOF. Let $\\mathcal{P}_{n}$ be an SW-algorithm for $L$ and window size $n$ with space complexity $\\mathrm{F}_{L}(n)$. Therefore, $\\mathcal{P}_{n}$ has at most $2^{\\mathrm{F}_{L}(n)}$ states. The definition of $\\mathrm{SW}_{n}(L)$ directly implies that $\\mathrm{SW}_{n}(L)$ is $n$-suffix testable. By Lemma 3.15(iii) $\\mathrm{SW}_{n}(L)$ is $2^{\\mathrm{F}_{L}(n)}$-suffix testable.\n\nNote that Lemma 3.16 holds for arbitrary languages and not only for regular languages.\nPROOF OF THEOREM 3.3(i). First, let $L \\subseteq \\Sigma^{*}$ be a regular language with $\\mathrm{F}_{L}(n)=O(1)$ and let $k=\\max _{n \\in \\mathbb{N}} 2^{\\mathrm{F}_{L}(n)}$. By Lemma 3.16 the language $\\mathrm{SW}_{n}(L)$ is $k$-suffix testable for all $n \\geqslant 0$. We can express $L$ as the Boolean combination\n\n$$\nL=\\left(L \\cap \\Sigma^{<k-1}\\right) \\cup \\bigcup_{z \\in \\Sigma^{k}}\\left(L z^{-1}\\right) z=\\left(L \\cap \\Sigma^{<k-1}\\right) \\cup \\bigcup_{z \\in \\Sigma^{k}}\\left(\\left(L z^{-1}\\right) \\Sigma^{k} \\cap \\Sigma^{*} z\\right)\n$$\n\nwhere the right quotient $L z^{-1}=\\left\\{x \\in \\Sigma^{*} \\mid x z \\in L\\right\\}$ is regular [15, Chapter 3, Example 5.7]. The set $L \\cap \\Sigma^{<k-1}$ is finite and hence suffix testable. It remains to show that each $L z^{-1}$ for $z \\in \\Sigma^{k}$ is a length language. Consider two words $x, y \\in \\Sigma^{*}$ of the same length $|x|=|y|=n$. Since $|x z|=|y z|=n+k$ and $\\mathrm{SW}_{n+k}(L)$ is $k$-suffix testable, we have $x z \\in L$ if and only if $y z \\in L$, and hence $x \\in L z^{-1}$ if and only if $y \\in L z^{-1}$.\n\nFor the other direction note that (i) if $L$ is a length language or a suffix testable language then clearly $\\mathrm{F}_{L}(n)=\\mathcal{O}(1)$, and (ii) $\\left\\{L \\subseteq \\Sigma^{*} \\mid \\mathrm{F}_{L}(n)=\\mathcal{O}(1)\\right\\}$ is closed under Boolean operations by Lemma 2.6. This proves the theorem.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 27,
      "text": "# 3.8 Characterization of logarithmic space \n\nRecall from Theorem 3.2 that well-behaved rDFAs precisely define those regular languages with logarithmic space complexity $\\mathrm{F}_{L}(n)$ or equivalently $\\mathrm{V}_{L}(n)$. In the following, we will show that well-behaved rDFAs recognize precisely the finite Boolean combinations of regular left ideals and regular length languages, which therefore are precisely the regular languages with logarithmic space complexity (Theorem 3.3(ii)). Let us start with the easy direction:\n\nPROPOSITION 3.17. Every language $L \\in\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$ is recognized by a well-behaved rDFA.\nPROOF. Let $\\mathcal{B}$ be an rDFA for $L$. If $L$ is a length language then for all reachable states $q$ and all runs $\\pi, \\pi^{\\prime}$ starting from $q$ with $|\\pi|=\\left|\\pi^{\\prime}\\right|$ we have: $\\pi$ is accepting if and only if $\\pi^{\\prime}$ is accepting. If $L$ is a left ideal, then whenever a final state $p$ is reachable, and $q$ is reachable from $p$, then $q$ is also final. Hence, for every reachable SCC $P$ in $\\mathcal{B}$ either all states of $P$ are final or all states of $P$ are nonfinal. In particular, $\\mathcal{B}$ is well-behaved.\n\nIt remains to show that the class of languages $L \\subseteq \\Sigma^{*}$ recognized by well-behaved rDFAs is closed under Boolean operations. If $\\mathcal{B}$ is well-behaved then the complement automaton $\\overline{\\mathcal{B}}$ is also well-behaved. Given two well-behaved rDFAs $\\mathcal{B}_{1}, \\mathcal{B}_{2}$, we claim that the product automaton $\\mathcal{B}_{1} \\times \\mathcal{B}_{2}$ recognizing the intersection language is also well-behaved. Suppose that $\\mathcal{B}_{i}=\\left(Q_{i}, \\Sigma, F_{i}, \\delta_{i}, q_{0, i}\\right)$ for $i \\in\\{1,2\\}$. The product automaton for the intersection language is defined by\n\n$$\n\\mathcal{B}_{1} \\times \\mathcal{B}_{2}=\\left(Q_{1} \\times Q_{2}, \\Sigma, F_{1} \\times F_{2}, \\delta,\\left(q_{0,1}, q_{0,2}\\right)\\right)\n$$\n\nwhere $\\delta\\left(a,\\left(q_{1}, q_{2}\\right)\\right)=\\left(\\delta_{1}\\left(a, q_{1}\\right), \\delta_{2}\\left(a, q_{2}\\right)\\right)$ for all $q_{1} \\in Q_{1}, q_{2} \\in Q_{2}$ and $a \\in \\Sigma$. Consider an SCC $S$ of $\\mathcal{B}_{1} \\times \\mathcal{B}_{2}$ which is reachable from the initial state and let $\\left(p_{1}, p_{2}\\right),\\left(q_{1}, q_{2}\\right),\\left(r_{1}, r_{2}\\right) \\in S$ such that\n\n$$\n\\left(q_{1}, q_{2}\\right) \\stackrel{u}{\\longleftarrow}\\left(p_{1}, p_{2}\\right) \\text { and }\\left(r_{1}, r_{2}\\right) \\stackrel{v}{\\longleftarrow}\\left(p_{1}, p_{2}\\right)\n$$\n\nfor some words $u, v \\in \\Sigma^{*}$ with $|u|=|\\nu|$. Since for $i \\in\\{1,2\\}$ we have $q_{i} \\stackrel{u}{\\longleftarrow} p_{i}$ and $r_{i} \\stackrel{v}{\\longleftarrow} p_{i}$, and $\\left\\{p_{i}, r_{i}, q_{i}\\right\\}$ is contained in an SCC of $\\mathcal{B}_{i}$ (which is also reachable from the initial state $q_{0, i}$ ), we have\n\n$$\n\\begin{aligned}\n\\left(q_{1}, q_{2}\\right) \\text { is final } & \\Longleftrightarrow q_{1} \\text { and } q_{2} \\text { are final } \\\\\n& \\Longleftrightarrow r_{1} \\text { and } r_{2} \\text { are final } \\\\\n& \\Longleftrightarrow\\left(r_{1}, r_{2}\\right) \\text { is final, }\n\\end{aligned}\n$$\n\nand therefore $\\mathcal{B}_{1} \\times \\mathcal{B}_{2}$ is well-behaved.\n\nIt remains to prove that every well-behaved rDFA recognizes a finite Boolean combination of regular left ideals and regular length languages. With a right-deterministic finite automaton $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ we associate the directed graph $(Q, E)$ with edge set $E=\\{(p, a \\cdot p) \\mid p \\in$ $Q, a \\in \\Sigma\\}$. The period $g(G)$ of a directed graph $G$ is the greatest common divisor of all cycle lengths in $G$. If $G$ is acyclic we define the period to be $\\infty$. We will apply the following lemma from Alon et al. [2] to the nontransient SCCs of $\\mathcal{B}$.\n\nLEMMA 3.18 ([2]). Let $G=(V, E)$ be a strongly connected directed graph with $E \\neq \\emptyset$ and finite period $g$. Then there exist a partition $V=\\bigcup_{i=0}^{g-1} V_{i}$ and a constant $m(G) \\leqslant 3|V|^{2}$ with the following properties:\n\n- For every $0 \\leqslant i, j \\leqslant g-1$ and for every $u \\in V_{i}, v \\in V_{j}$ the length of every directed path from $u$ to $v$ in $G$ is congruent to $j-i$ modulo $g$.\n- For every $0 \\leqslant i, j \\leqslant g-1$, for every $u \\in V_{i}, v \\in V_{j}$ and every integer $r \\geqslant m(G)$, if $r$ is congruent to $j-i$ modulo $g$, then there exists a directed path from $u$ to $v$ in $G$ of length $r$.\n\nLEMMA 3.19 (uniform period). For every regular language there exists an rDFA $\\mathcal{B}$ recognizing $L$ and a number $g$ such that every nontransient SCC $C$ in $\\mathcal{B}$ has period $g(C)=g$.\n\nPROOF. Let $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ be any rDFA for $L$. Let $g$ be the product of all periods $g(C)$ over all nontransient SCCs $C$ in $\\mathcal{B}$. In the following, we compute in the additive group $\\mathbb{Z}_{g}=$ $\\{0, \\ldots, g-1\\}$. We define\n\n$$\n\\mathcal{B} \\times \\mathbb{Z}_{g}=\\left(Q \\times \\mathbb{Z}_{g}, \\Sigma, F \\times \\mathbb{Z}_{g}, \\delta^{\\prime},\\left(q_{0}, 0\\right)\\right)\n$$\n\nwhere for all $(p, i) \\in Q \\times \\mathbb{Z}_{g}$ and $a \\in \\Sigma$ we set\n\n$$\n\\delta^{\\prime}(a,(p, i))= \\begin{cases}(\\delta(a, p), i+1), & \\text { if } p \\text { and } \\delta(a, p) \\text { are strongly connected } \\\\ (\\delta(a, p), 0), & \\text { otherwise }\\end{cases}\n$$\n\nClearly, $\\mathrm{L}\\left(\\mathcal{B} \\times \\mathbb{Z}_{g}\\right)=\\mathrm{L}(\\mathcal{B})$. We show that every nontransient SCC of $\\mathcal{B} \\times \\mathbb{Z}_{g}$ has period $g$. Let $D$ be a nontransient SCC of $\\mathcal{B} \\times \\mathbb{Z}_{g}$. Clearly, every cycle length in $D$ is a multiple of $g$. Take any state $(q, i) \\in D$ and let $C$ be the SCC of $q$ in $\\mathcal{B}$. Since $D$ is nontransient, there exists a cycle in $\\mathcal{B} \\times \\mathbb{Z}_{g}$ containing $(q, i)$, which induces a cycle in $\\mathcal{B}$ containing $q$. This implies that $C$ is nontransient. Hence, we can apply Lemma 3.18 and obtain a cycle of length $k \\cdot g(C)$ in $C$ for every sufficiently large $k \\in \\mathbb{N}(k \\geqslant m(C)$ suffices). Since $g$ is a multiple of $g(C), C$ also contains a cycle of length $k \\cdot g$ for every sufficiently large $k$. But every such cycle induces a cycle of the same length $k \\cdot g$ in $D$. Hence, there exists $k \\in \\mathbb{N}$ such that $D$ contains cycles of length $k \\cdot g$ and $(k+1) \\cdot g$. It follows that the period of $D$ divides $\\operatorname{gcd}(k \\cdot g,(k+1) \\cdot g)=g$. This proves that the period of $D$ is exactly $g$.\n\nPROOF OF THEOREM 3.3(ii). It remains to show the direction from left to right. Consider a well-behaved rDFA $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ for a regular language $L \\subseteq \\Sigma^{*}$. We prove that $L$ is a finite\n\nBoolean combination of regular left ideals and regular length languages. By Lemma 3.19 we can ensure that all nontransient SCCs in $\\mathcal{B}$ have the same period $g$. This new rDFA $\\mathcal{B}$ is also wellbehaved since in fact any rDFA for $L$ must be well-behaved; this follows from Proposition 3.9 and Corollary 3.10. Alternatively, one can verify that the transformation from Lemma 3.19 preserves the well-behavedness of $\\mathcal{B}$.\n\nA path description $P$ is a sequence\n\n$$\nC_{k},\\left(q_{k}, a_{k-1}, p_{k-1}\\right), C_{k-1}, \\ldots,\\left(q_{3}, a_{2}, p_{2}\\right), C_{2},\\left(q_{2}, a_{1}, p_{1}\\right), C_{1}, q_{1}\n$$\n\nwhere $C_{k}, \\ldots, C_{1}$ are pairwise distinct SCCs of $\\mathcal{B}, q_{1}=q_{0},\\left(q_{i+1}, a_{i}, p_{i}\\right)$ is a transition in $\\mathcal{B}$ for all $1 \\leqslant i \\leqslant k-1, p_{i}, q_{i} \\in C_{i}$ for all $1 \\leqslant i \\leqslant k-1$, and $q_{k} \\in C_{k}$. A run $\\pi$ in $\\mathcal{B}$ respects the path description $P$ if the SCC-factorization of $\\pi$ is $\\pi=\\pi_{k} \\tau_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1}, \\pi_{i}$ is a $C_{i}$-internal run from $q_{i}$ to $p_{i}$ for all $1 \\leqslant i \\leqslant k-1, \\tau_{i}=q_{i+1} a_{i} p_{i}$ for all $1 \\leqslant i \\leqslant k-1$, and $\\pi_{k}$ is a $C_{k}$-internal run starting in $q_{k}$. Let $L_{P}$ be the set of words $w \\in \\Sigma^{*}$ such that the unique run of $\\mathcal{B}$ on $w$ starting in $q_{0}$ respects the path description $P$. We can write $L=\\bigcup_{P}\\left(L_{P} \\cap L\\right)$ where $P$ ranges over all path descriptions. Notice that the number of path descriptions is finite.\n\nLet us fix a path description $P$ as in (4). We prove that $L_{P} \\cap L$ is a finite Boolean combination of regular left ideals and regular length languages. First, we claim that $L_{P}$ is a finite Boolean combination of regular left ideals. Let $\\Delta=\\{(a \\cdot p, a, p) \\mid p \\in Q, a \\in \\Sigma\\}$ be the set of all transition triples and let $\\Delta_{P} \\subseteq \\Delta$ be the set of transition triples contained in any of the SCCs $C_{k}, \\ldots, C_{1}$ together with the transition triples $\\left(q_{i+1}, a_{i}, p_{i}\\right)$ for $1 \\leqslant i \\leqslant k-1$. A word $w \\in \\Sigma^{*}$ then belongs to $L_{P}$ if and only if $w$ belongs to the regular left ideal $\\Sigma^{*} L_{P}$ and the run of $\\mathcal{B}$ on $w$ starting in $q_{0}$ does not use any transitions from $\\Delta \\backslash \\Delta_{P}$. It is easy to construct for every $\\tau \\in \\Delta \\backslash \\Delta_{P}$ an rDFA $\\mathcal{D}_{\\tau}$ which accepts all words $w$ such that the run of $\\mathcal{B}$ on $w$ starting in $q_{0}$ uses the transition $\\tau$. Clearly, this language is a left ideal. In total we have $L_{P}=\\Sigma^{*} L_{P} \\backslash \\bigcup_{\\tau \\in \\Delta \\backslash \\Delta_{P}} \\mathrm{~L}\\left(\\mathcal{D}_{\\tau}\\right)$, which proves the claim.\n\nIf $C_{k}$ is a transient SCC then $L_{P} \\cap L$ is either empty or $L_{P}$, and we are done. For the rest of the proof we assume that $C_{k}$ is nontransient. Recall that all nontransient SCCs in $\\mathcal{B}$ have period $g$. Furthermore, $C_{k}$ is well-behaved since it is reachable from $q_{0}$ according to the path description $P$. Let $C_{k}=\\bigcup_{i=0}^{g-1} V_{i}$ be the partition from Lemma 3.18. We claim that $F \\cap C_{k}$ is a union of some of the $V_{i}$ 's. Towards a contradiction assume that there exist states $p, q \\in V_{i}$ where $p \\in F$ and $q \\notin F$. Let $r \\geqslant m(C)$ be any number divisible by $g$. Then, by Lemma 3.18 there exist runs from $p$ to $p$ and from $p$ to $q$, both of length $r$. This contradicts the fact that $C_{k}$ is well-behaved.\n\nLet $\\pi, \\pi^{\\prime}$ be two runs of $\\mathcal{B}$ starting from $q_{0}$ which respect $P$. We claim that $|\\pi| \\equiv\\left|\\pi^{\\prime}\\right|$ $(\\bmod g)$ if and only if $\\pi$ and $\\pi^{\\prime}$ end in the same part $V_{i}$ of $C_{k}$. Consider the SCC-factorizations $\\pi=\\pi_{k} \\tau_{k-1} \\pi_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1}$ and $\\pi^{\\prime}=\\pi_{k}^{\\prime} \\tau_{k-1} \\pi_{k-1}^{\\prime} \\cdots \\tau_{2} \\pi_{2}^{\\prime} \\tau_{1} \\pi_{1}^{\\prime}$. For all $1 \\leqslant i \\leqslant k-1$ the subruns $\\pi_{i}$ and $\\pi_{i}^{\\prime}$ start in $q_{i}$ and end in $p_{i}$. If $C_{i}$ is nontransient then $\\left|\\pi_{i}\\right| \\equiv\\left|\\pi_{i}^{\\prime}\\right|(\\bmod g)$ by Lemma 3.18, and otherwise $\\left|\\pi_{i}\\right|=\\left|\\pi_{i}^{\\prime}\\right|=0$. This implies $\\left|\\tau_{k-1} \\pi_{k-1} \\cdots \\tau_{2} \\pi_{2} \\tau_{1} \\pi_{1}\\right| \\equiv\\left|\\tau_{k-1} \\pi_{k-1}^{\\prime} \\cdots \\tau_{2} \\pi_{2}^{\\prime} \\tau_{1} \\pi_{1}^{\\prime}\\right|(\\bmod g)$.\n\nAlso by Lemma 3.18 we know that $\\left|\\pi_{k}\\right| \\equiv\\left|\\pi_{k}^{\\prime}\\right|(\\bmod g)$ if and only if $\\pi$ and $\\pi^{\\prime}$ end in the same part $V_{i}$. This proves the claim.\n\nIt follows that we can write $L_{P} \\cap L=L_{P} \\cap K$ where\n\n$$\nK=\\left\\{w \\in \\Sigma^{*} \\mid \\exists r \\in R:|w| \\equiv r \\quad(\\bmod g)\\right\\}\n$$\n\nfor some $R \\subseteq\\{0, \\ldots, g-1\\}$. Since $K$ is a regular length language, we have proved the claim that $L$ is a Boolean combination of regular left ideals and regular length languages. This concludes the proof of Theorem 3.3(ii).",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 28,
      "text": "# 4. Randomized sliding window algorithms \n\nMost of the work in the context of streaming uses randomness and/or approximation to design space- and time-efficient algorithms. For example, the AMS-algorithm [3] approximates the number of distinct elements in a stream with high probability in $\\mathcal{O}(\\log m)$ space where $m$ is the size of the universe. Furthermore, it is proved that any deterministic approximation algorithm and any randomized exact algorithm must use $\\Omega(n)$ space [3]. On the other hand, the exponential histogram algorithm by Datar et al. [27] for approximating the number of 1's in a sliding window is a deterministic sliding window approximation algorithm that uses $\\mathcal{O}\\left(\\frac{1}{e} \\log ^{2} n\\right)$ bits. It is proven in [27] that $\\Omega\\left(\\frac{1}{e} \\log ^{2} n\\right)$ bits are necessary even for randomized (Monte Carlo or Las Vegas) sliding window algorithms.\n\nIn this section, we will study if and how randomness helps for testing membership to regular languages over sliding windows. The main result of this section is a space tetrachotomy in the fixed-size sliding window model, stating that every regular language has optimal space complexity $\\Theta(1), \\Theta^{\\infty}(\\log \\log n), \\Theta^{\\infty}(\\log n)$ or $\\Theta^{\\infty}(n)$ if the streaming algorithms are randomized with two-sided error.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 29,
      "text": "### 4.1 Randomized streaming algorithms\n\nIn the following, we will introduce probabilistic automata [78, 81] as a model of randomized streaming algorithms. With $[0,1]$ we denote the set of all real numbers $r$ with $0 \\leqslant r \\leqslant 1$. A probabilistic automaton $\\mathcal{P}=(Q, \\Sigma, \\iota, \\rho, F)$ consists of a nonempty countable set of states $Q$, a finite alphabet $\\Sigma$, an initial state distribution $\\iota: Q \\rightarrow[0,1]$, a transition probability function $\\rho: Q \\times \\Sigma \\times Q \\rightarrow[0,1]$, and a set of final states $F \\subseteq Q$, such that\n(i) $\\sum_{q \\in Q} \\iota(q)=1$,\n(ii) $\\sum_{q \\in Q} \\rho(p, a, q)=1$ for all $p \\in Q, a \\in \\Sigma$.\n\nIf $Q$ is infinite then this means of course that the above infinite sums converge to 1 . This implies that these sums are absolutely convergent (all $\\iota(q)$ and $\\rho(p, a, q)$ are non-negative) and therefore the order of summation is not relevant.\n\nIf $\\iota$ and $\\rho$ map into $\\{0,1\\}$, then $\\mathcal{P}$ can be viewed as a deterministic automaton. We will refer to probabilistic automata also as randomized streaming algorithms.\n\nFor a word $w \\in \\Sigma^{*}$ and a state $q$ we define the probability $\\mathcal{P}(w, q)$ that $\\mathcal{P}$ after reading the word $w$ arrives in state $q$ inductively over the length of $w$ as follows, where $q \\in Q, v \\in \\Sigma^{*}$ and $a \\in \\Sigma$ :\n$-\\mathcal{P}(\\varepsilon, q)=\\iota(q)$ and\n$-\\mathcal{P}(v a, q)=\\sum_{p \\in Q} \\mathcal{P}(v, p) \\cdot \\rho(p, a, q)$.\nThen the probability that $\\mathcal{P}$ accepts the word $w$ is\n\n$$\n\\operatorname{Pr}[\\mathcal{P} \\text { accepts } w]=\\sum_{q \\in F} \\mathcal{P}(w, q)\n$$\n\nand the probability that $\\mathcal{P}$ rejects the word $w$ is\n\n$$\n\\operatorname{Pr}[\\mathcal{P} \\text { rejects } w]=\\sum_{q \\in Q \\backslash F} \\mathcal{P}(w, q)\n$$\n\nThe space of $\\mathcal{P}$ (or number of bits used by $\\mathcal{P}$ ) is given by $s(\\mathcal{P})=\\log |Q| \\in \\mathbb{R}_{\\geqslant 0} \\cup\\{\\infty\\}$. We say that $\\mathcal{P}$ is a randomized streaming algorithm for $L \\subseteq \\Sigma^{*}$ with error probability $0 \\leqslant \\lambda \\leqslant 1$ if\n$-\\operatorname{Pr}[\\mathcal{P}$ accepts $w] \\geqslant 1-\\lambda$ for all $w \\in L$,\n$-\\operatorname{Pr}[\\mathcal{P}$ rejects $w] \\geqslant 1-\\lambda$ for all $w \\notin L$.\nThe error probability $\\lambda$ is also called a two-sided error. If we omit $\\lambda$ we choose $\\lambda=1 / 3$.\nFor a randomized streaming algorithm $\\mathcal{P}=(Q, \\Sigma, \\iota, \\rho, F)$ and a number $k \\geqslant 1$ let $\\mathcal{P}^{(k)}$ be the randomized streaming algorithm which simulates $k$ instances of $\\mathcal{P}$ in parallel with independent random choices and outputs the majority vote. Formally the states of $\\mathcal{P}^{(k)}$ are multisets of size $k$ over $Q$ (using multisets instead of ordered tuples will yield a better space bound in Section 4.3). Therefore, $s\\left(\\mathcal{P}^{(k)}\\right) \\leqslant k \\cdot s(\\mathcal{P})$.\n\nLEMMA 4.1 (probability amplification). For all $0<\\lambda^{\\prime}<\\lambda<1 / 2$ there exists a number $k=O\\left(\\log \\left(\\frac{1}{\\lambda^{\\prime}}\\right) \\cdot\\left(\\frac{1}{2}-\\lambda\\right)^{-2}\\right)$ such that for all randomized streaming algorithms $\\mathcal{P}$ and all $w \\in \\Sigma^{*}$ we have:\n(i) If $\\operatorname{Pr}[\\mathcal{P}$ accepts $w] \\geqslant 1-\\lambda$ then $\\operatorname{Pr}\\left[\\mathcal{P}^{(k)}\\right.$ accepts $\\left.w\\right] \\geqslant 1-\\lambda^{\\prime}$.\n(ii) If $\\operatorname{Pr}[\\mathcal{P}$ rejects $w] \\geqslant 1-\\lambda$ then $\\operatorname{Pr}\\left[\\mathcal{P}^{(k)}\\right.$ rejects $\\left.w\\right] \\leqslant 1-\\lambda^{\\prime}$.\n\nPROOF. We will choose $k$ later. Let $X_{1}, \\ldots, X_{k}$ be independent Bernoulli random variables with $\\operatorname{Pr}\\left[X_{i}=0\\right]=\\lambda$ and $\\operatorname{Pr}\\left[X_{i}=1\\right]=1-\\lambda$. Let $X=\\sum_{i=1}^{k} X_{i}$ with expectation $\\mu=k(1-\\lambda)$. Suppose that $\\mathcal{P}$ accepts $w$ with probability $\\geqslant 1-\\lambda$, i.e., $\\mathcal{P}$ rejects $w$ with probability at most $\\lambda$. Then, $\\mathcal{P}^{(k)}$ rejects $w$ with probability at most $\\operatorname{Pr}[X \\leqslant k / 2]$. By the Chernoff bound [75, Theorem 4.5], for any $0<\\delta<1$ we have\n\n$$\n\\operatorname{Pr}[X \\leqslant(1-\\delta) \\mu] \\leqslant \\exp \\left(-\\frac{\\mu \\delta^{2}}{2}\\right)\n$$\n\nBy choosing $\\delta=1-\\frac{1}{2(1-\\lambda)}$ we get $(1-\\delta) \\mu=k / 2$. Then, (5) gives the following estimate:\n\n$$\n\\begin{aligned}\n\\operatorname{Pr}[X \\leqslant k / 2] & \\leqslant \\exp \\left(-\\frac{k(1-\\lambda)\\left(1-\\frac{1}{2(1-\\lambda)}\\right)^{2}}{2}\\right) \\\\\n& =\\exp \\left(-\\frac{k}{2} \\cdot \\frac{\\left(\\frac{1}{2}-\\lambda\\right)^{2}}{1-\\lambda}\\right) \\\\\n& \\leqslant \\exp \\left(-\\frac{k}{2} \\cdot\\left(\\frac{1}{2}-\\lambda\\right)^{2}\\right)\n\\end{aligned}\n$$\n\nBy choosing\n\n$$\nk \\geqslant 2 \\cdot \\ln \\left(\\frac{1}{\\lambda^{\\prime}}\\right) \\cdot\\left(\\frac{1}{2}-\\lambda\\right)^{-2}\n$$\n\nwe can bound the probability that $\\mathcal{P}^{(k)}$ rejects $w$ by $\\lambda^{\\prime}$. Statement (ii) can be shown analogously.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 30,
      "text": "# 4.2 Space tetrachotomy \n\nA randomized sliding window algorithm for a language $L$ and window size $n$ is a randomized streaming algorithm for $\\mathrm{SW}_{n}(L)$. The randomized space complexity $\\mathrm{F}_{L}^{\\prime}(n)$ of $L$ in the fixed-size sliding window model is the minimal space complexity $s\\left(\\mathcal{P}_{n}\\right)$ of a randomized sliding window algorithm $\\mathcal{P}_{n}$ for $L$ and window size $n$. For this to be well-defined it is important that we require the error probability to be at most $1 / 3$.\n\nBefore we investigate randomized streaming algorithms in more detail, let us first comment on the fact that in our definition of randomized SW-algorithms we allow arbitrary (even irrational) probabilities in the state transitions. On the other hand, in all correctness proofs for our randomized SW-algorithms we only need the fact that the probabilities are from a certain interval $I \\subseteq[0,1]$. Therefore, if $d$ is the length of the interval $I$, we can always choose a probability $p \\in I$ with $O\\left(\\log _{2}(1 / d)\\right)$ bits such that the algorithm still achieves an error probability of at most $1 / 3$. However, the size of the interval $I$ may depend on the window size $n$; more precisely it may shrink when $n$ grows. In particular, the number of bits needed to write down the probabilities used in $\\mathcal{P}_{n}$ (the algorithm for window size $n$ ) may grow with $n$. One might argue that these bits should also enter the definition of the space used by the algorithm. The reason why we do not take these bits into account is the same as why we do not consider the space for internal calculations; see Remark 2.7. Assume for instance that we need to implement a randomized branching with probabilities $p$ and $1-p$ and let $m$ be the number of bits of $p$. Let us moreover assume that we have a randomized machine model that apart from deterministic commands can only toss fair coins. It is not difficult to see that one can implement a biased coin with probabilities $p$ and $1-p$ using $m$ many fair coins. For this, one also needs some additional control structure for which $O(\\log m)$ bits are needed (basically to store the program counter).\n\nBut this is internal space that we do not take into account in our definition of space (as justified in Remark 2.7). ${ }^{5}$\n\nClearly we have $\\mathrm{F}_{L}^{r}(n) \\leqslant \\mathrm{F}_{L}(n)$. Furthermore, we prove that randomness can reduce the space complexity at most exponentially:\n\nLEMMA 4.2. For any language $L$ we have $\\mathrm{F}_{L}(n)=2^{O\\left(F_{L}^{r}(n)\\right)}$.\nPROOF. Rabin proved that any probabilistic finite automaton with a so-called isolated cutpoint can be made deterministic with an exponential size increase [81]. Let $\\mathcal{P}=(Q, \\Sigma, \\iota, \\rho, F)$ be a probabilistic finite automaton with $m$ states. Suppose that $\\lambda \\in[0,1]$ is an isolated cutpoint with radius $\\delta>0$, i.e., $\\mid \\operatorname{Pr}\\left[\\mathcal{P}\\right.$ accepts $\\left.w\\right]-\\lambda \\mid \\geqslant \\delta$ for all $w \\in \\Sigma^{*}$. Then, $L=\\left\\{w \\in \\Sigma^{*}\\right.$ $\\operatorname{Pr}\\left[\\mathcal{P}\\right.$ accepts $\\left.w\\right] \\geqslant \\lambda\\}$ is recognized by a DFA $\\mathcal{A}$ with at most $(1+m / \\delta)^{m-1}=2^{O(m \\log m)}$ states [81, Theorem 3].\n\nNow, let $\\mathcal{P}_{n}$ be a minimal probabilistic finite automaton for $\\mathrm{SW}_{n}(L)$ with $m$ states and error probability $\\leqslant 1 / 3$. Since $\\mathcal{P}_{n}$ has $1 / 2$ as an isolated cutpoint with radius $1 / 2-1 / 3=1 / 6$, there exists an equivalent DFA $Q_{n}$ with $\\left|Q_{n}\\right| \\leqslant 2^{O(m \\log m)}$ states. The statement follows from $\\mathrm{F}_{L}(n) \\leqslant \\log \\left|Q_{n}\\right|=O(m \\log m)=O\\left(2^{\\mathrm{F}_{L}^{r}(n)} \\cdot \\mathrm{F}_{L}^{r}(n)\\right)$, which is bounded by $2^{O\\left(\\mathrm{~F}_{L}^{r}(n)\\right)}$.\n\nIn this section, we will prove Theorem 1.4, which is a tetrachotomy for the randomized space complexity of regular languages in the fixed-size sliding window model. Let us rephrase Theorem 1.4 and split it into three upper bounds and three lower bounds.\n\nTHEOREM 4.3. Let $L \\subseteq \\Sigma^{*}$ be a regular language.\n(1) If $L \\in\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$ then $\\mathrm{F}_{L}^{r}(n)=O(1)$.\n(2) If $L \\notin\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$ then $\\mathrm{F}_{L}^{r}(n)=\\Omega^{\\infty}(\\log \\log n)$.\n(3) If $L \\in\\langle\\mathbf{S T}, \\mathbf{S F}, \\mathbf{L e n}\\rangle$ then $\\mathrm{F}_{L}^{r}(n)=O(\\log \\log n)$.\n(4) If $L \\notin\\langle\\mathbf{S T}, \\mathbf{S F}, \\mathbf{L e n}\\rangle$ then $\\mathrm{F}_{L}^{r}(n)=\\Omega^{\\infty}(\\log n)$.\n(5) If $L \\in\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$ then $\\mathrm{F}_{L}^{r}(n)=O(\\log n)$.\n(6) If $L \\notin\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$ then $\\mathrm{F}_{L}^{r}(n)=\\Omega^{\\infty}(n)$.\n\nPoints (1) and (5) already hold in the deterministic setting, see Theorem 3.3. In the next sections we prove points (2), (3), (4), and (6).\n\nWe first transfer Lemma 2.6 to the fixed-size model in the randomized setting:\nLEMMA 4.4. Let $\\Sigma$ be a finite alphabet. For any function $s(n)$, the class $\\left\\{L \\subseteq \\Sigma^{*} \\mid \\mathrm{F}_{L}^{r}(n)=\\right.$ $O(s(n))\\}$ forms a Boolean algebra.\n\nPROOF. Let $L \\subseteq \\Sigma^{*}$ be a language and $n \\in \\mathbb{N}$ a window size. If $\\mathcal{P}_{n}$ is a randomized SW-algorithm for $L$ and window size $n$ then $\\overline{\\mathcal{P}}_{n}$ is a randomized SW-algorithm for $\\Sigma^{*} \\backslash L$ and window size\n\n[^0]\n[^0]:    5 The reader may view this control structure as additional $\\varepsilon$-transitions in a probabilistic automaton that are taken with probability $1 / 2$.\n\n$n$, where $\\widetilde{\\mathcal{P}}_{n}$ simulates $\\mathcal{P}_{n}$ and returns the negated output. Let $\\mathcal{P}_{n}$ and $Q_{n}$ be randomized SWalgorithms for $K$ and $L$, respectively, and window size $n$. By Lemma 4.1 we can reduce their error probabilities to $1 / 6$ with a constant space increase. Then, the algorithm which simulates $\\mathcal{P}_{n}$ and $Q_{n}$ in parallel and returns the disjunction of the outputs is a randomized SW-algorithm for $K \\cup L$ and window size $n$. Its error probability is at most $1 / 3$ by the union bound.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 31,
      "text": "# 4.3 The Bernoulli counter \n\nThe crucial algorithmic tool for the proof of Theorem 4.3(3) is a simple probabilistic counter. It is inspired by the approximate counter by Morris [36, 76], which uses $\\mathcal{O}(\\log \\log n)$ bits. For our purposes, it suffices to detect whether the counter has exceeded a certain threshold, which can be accomplished using only $\\mathcal{O}(1)$ bits.\n\nFormally, a probabilistic counter is a probabilistic automaton\n\n$$\n\\mathfrak{Z}=(C,\\{\\operatorname{inc}\\}, \\iota, \\rho, F)\n$$\n\nover the unary alphabet $\\{$ inc $\\}$. States in $F$ are called high and states in $C \\backslash F$ are called low. We make the restriction that there is a low state $c_{0} \\in C$ such that $\\iota\\left(c_{0}\\right)=1$ (and hence $\\iota(c)=0$ for all $c \\in C \\backslash\\left\\{c_{0}\\right\\}$ ); thus $\\mathfrak{Z}$ has a unique initial state $c_{0}$ (which must be low) and we write $\\mathfrak{Z}=\\left(C,\\{\\right.$ inc $\\left.\\}, c_{0}, \\rho, F\\right)$. This restriction is not really important (and can in fact be achieved for every probabilistic automaton by adding a new state), but it will simplify our constructions.\n\nIn the following we write $\\mathfrak{Z}(k, c)$ for $\\mathfrak{Z}\\left(\\right.$ inc $\\left.^{k}, c\\right)(k \\geqslant 0, c \\in C)$, which is the probability that $\\mathfrak{Z}$ arrives in state $c$ after $k$ increments. Moreover, $\\mathfrak{Z}^{\\text {hi }}(k)$ is the probability that $\\mathfrak{Z}$ is in a high state after $k$ increments (this is the same as $\\operatorname{Pr}\\left[\\mathfrak{Z}\\right.$ accepts inc $\\left.^{k}\\right]$ ). Given numbers $0 \\leqslant \\ell<h$ we say that $\\mathfrak{Z}$ is an $(h, \\ell)$-counter with error probability $\\lambda<\\frac{1}{2}$ if for all $k \\in \\mathbb{N}$ we have:\n\u2014 If $k \\leqslant \\ell$, then $\\mathfrak{Z}^{\\text {hi }}(k) \\leqslant \\lambda$.\n\n- If $k \\geqslant h$, then $\\mathfrak{Z}^{\\text {hi }}(k) \\geqslant 1-\\lambda$.\n\nIn other words, a probabilistic counter can distinguish with high probability between values below $\\ell$ and values above $h$ but does not give any guarantees for counter values strictly between $\\ell$ and $h$. A Bernoulli counter is a probabilistic counter $\\mathfrak{Z}_{p}$ that is parameterized by a probability $0<p<1$ and that has the state set $\\{0,1\\}$, where 0 is a low state and 1 is a high state. Initially the counter is in the state $x=0$. On every increment we set $x=1$ with probability $p$; the state remains unchanged with probability $1-p$. We have\n\n$$\n\\mathfrak{Z}_{p}^{\\mathrm{hi}}(k)=\\mathfrak{Z}_{p}(k, 1)=1-(1-p)^{k}\n$$\n\nLet us first show the following claim.\nLEMMA 4.5. For all $h>0,0<\\xi<1$ and $0<\\ell \\leqslant(1-\\xi) h$ there exists $0<p<1$ such that $\\mathfrak{Z}_{p}$ is an $(h, \\ell)$-counter with error probability $1 / 2-\\xi / 8$.\n\nPROOF. We need to choose $0<p<1$ such that\n(i) $1-(1-p)^{(1-\\xi) h} \\leqslant 1 / 2-\\xi / 8$, or equivalently, $1 / 2+\\xi / 8 \\leqslant(1-p)^{(1-\\xi) h}$, and\n(ii) $(1-p)^{h} \\leqslant 1 / 2-\\xi / 8$, or equivalently, $(1-p)^{(1-\\xi) h} \\leqslant(1 / 2-\\xi / 8)^{1-\\xi}$.\n\nIt suffices to show\n\n$$\n\\frac{1}{2}+\\frac{\\xi}{8} \\leqslant\\left(\\frac{1}{2}-\\frac{\\xi}{8}\\right)^{1-\\xi}\n$$\n\nThen one can take for instance $p=1-(1 / 2-\\xi / 8)^{1 / h} \\in(0,1)$, which satisfies (ii). Moreover, (i) is satisfied due to (6).\n\nTaking logarithms shows that (6) is equivalent to\n\n$$\n\\ln (4+\\xi)-\\ln 8 \\leqslant(1-\\xi) \\cdot(\\ln (4-\\xi)-\\ln 8)\n$$\n\nwhich can be rearranged to $\\ln (4+\\xi) \\leqslant \\ln (4-\\xi)+\\xi(\\ln 8-\\ln (4-\\xi))$. Since $\\ln 8-\\ln (4-\\xi) \\geqslant$ $\\ln 8-\\ln 4=\\ln 2$, it suffices to prove\n\n$$\n\\ln (4+\\xi) \\leqslant \\ln (4-\\xi)+\\xi \\ln 2\n$$\n\nOne can verify $3 \\ln 2 \\approx 2.0794 \\geqslant 2$. We have\n\n$$\n\\begin{aligned}\n4+\\xi & \\leqslant 4+(3 \\ln 2-1) \\xi \\\\\n& =4+(4 \\ln 2-1) \\xi-\\xi \\ln 2 \\\\\n& \\leqslant 4+(4 \\ln 2-1) \\xi-\\xi^{2} \\ln 2 \\\\\n& =(4-\\xi)(\\xi \\ln 2+1)\n\\end{aligned}\n$$\n\nBy taking logarithms and plugging in $\\ln x \\leqslant x-1$ for all $x>0$, we obtain\n\n$$\n\\ln (4+\\xi) \\leqslant \\ln (4-\\xi)+\\ln (\\xi \\ln 2+1) \\leqslant \\ln (4-\\xi)+\\xi \\ln 2\n$$\n\nThis proves (7) and hence (6), and thus the lemma.\nPROPOSITION 4.6. For all $h>0,0<\\xi<1,0<\\ell \\leqslant(1-\\xi) h$ and $0<\\lambda^{\\prime}<1 / 2$ there exists an $(h, \\ell)$-counter $\\mathcal{Z}$ with error probability $\\lambda^{\\prime}$ which uses $O\\left(\\log \\log \\left(1 / \\lambda^{\\prime}\\right)+\\log (1 / \\xi)\\right)$ bits.\n\nPROOF. Take the $(h, \\ell)$-counter $\\mathcal{Z}_{p}$ from Lemma 4.5, whose error probability is $\\lambda:=1 / 2-\\xi / 8$. To $\\mathcal{Z}_{p}$ we apply Lemma 4.1, which states that we need to run $k=O\\left(\\log \\left(\\frac{1}{\\lambda^{\\prime}}\\right) \\cdot \\frac{1}{\\xi^{\\prime}}\\right)$ independent copies to reduce the error probability to $\\lambda^{\\prime}$. The states of $\\mathcal{Z}_{p}^{(k)}$ are multisets over $\\{0,1\\}$ of size $k$, which can be encoded with $O(\\log k)=O\\left(\\log \\log \\frac{1}{\\lambda^{\\prime}}+\\log \\frac{1}{\\xi}\\right)$ bits by specifying the number of 1-bits in the multiset. Note that the unique initial state of $\\mathcal{Z}_{p}^{(k)}$ is the multiset with $k$ occurrences of 0 .",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 32,
      "text": "# 4.4 Suffix-free languages \n\nIn this section, we prove Theorem 4.3(3). Since languages in ST $\\cup$ Len have constant space (deterministic) SW-algorithms it suffices by Lemma 4.4 to show:\n\nTHEOREM 4.7. If $L$ is regular and suffix-free then $F_{L}^{r}(n)=\\mathcal{O}(\\log \\log n)$.\nFix a regular suffix-free language $L \\subseteq \\Sigma^{*}$ and let $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ be an rDFA for $L$ where all states are reachable. Excluding the trivial case $L=\\emptyset$, we assume that $\\mathcal{B}$ contains at least one final state. Furthermore, since $L$ is suffix-free, any run in $\\mathcal{B}$ contains at most one final state. Therefore, we can assume that $F$ contains exactly one final state $q_{F}$, and all outgoing transitions from $q_{F}$ lead to a sink state. For a stream $w \\in \\Sigma^{*}$ define the function $\\ell_{w}: Q \\rightarrow \\mathbb{N} \\cup\\{\\infty\\}$ by\n\n$$\n\\ell_{w}(q)=\\inf \\left\\{k \\in \\mathbb{N} \\mid \\operatorname{last}_{k}(w) \\cdot q=q_{F}\\right\\}\n$$\n\nwhere we set $\\inf (\\emptyset)=\\infty$ (note that $\\left\\{k \\in \\mathbb{N} \\mid \\operatorname{last}_{k}(w) \\cdot q=q_{F}\\right\\}$ is either empty or a singleton set). Notice that last $_{n}(w) \\in L$ if and only if $\\ell_{w}\\left(q_{0}\\right)=n$. Also, it holds $\\ell_{w}\\left(q_{F}\\right)=0$ for every $w \\in \\Sigma^{*}$. A deterministic streaming algorithm can maintain the function $\\ell_{w}$ where $w \\in \\Sigma^{*}$ is the stream prefix read so far: If a symbol $a \\in \\Sigma$ is read, we can determine\n\n$$\n\\ell_{w a}(q)= \\begin{cases}0, & \\text { if } q=q_{F} \\\\ 1+\\ell_{w}(a \\cdot q), & \\text { otherwise }\\end{cases}\n$$\n\nwhere $1+\\infty=\\infty$. Storing $\\ell_{w}(q)$ may require up to $\\log |w|$ bits. Therefore, if an SW-algorithm for window size $n$ wants to store all $\\ell_{w}(q)$ for $q \\in Q$ ( $w$ is the input stream and not just the sliding window), then the space is not bounded in the window size. The solution is to use probabilistic counters with suitable threshold values $\\ell$ and $h$.\n\nLet $n \\in \\mathbb{N}$ be a window size. The randomized sliding window algorithm $\\mathcal{P}_{n}$ for $L$ consists of two parts: a constant-space threshold algorithm $\\mathcal{T}_{n}$, which rejects with high probability whenever $\\ell_{w}\\left(q_{0}\\right) \\geqslant 2 n$, and a modulo counting algorithm $\\mathcal{M}_{n}$, which maintains $\\ell_{w}$ modulo a random prime number with $\\mathcal{O}(\\log \\log n)$ bits.\n\nLEMMA 4.8 (threshold counting). There exists a randomized streaming algorithm $\\mathcal{T}_{n}$ with $O(1)$ bits such that for all $w \\in \\Sigma^{*}$ we have:\n\u2014 $\\operatorname{Pr}\\left[\\mathcal{T}_{n}\\right.$ accepts $\\left.w\\right] \\geqslant 2 / 3$, if $\\ell_{w}\\left(q_{0}\\right) \\leqslant n$, and\n$-\\operatorname{Pr}\\left[\\mathcal{T}_{n}\\right.$ rejects $\\left.w\\right] \\geqslant 2 / 3$, if $\\ell_{w}\\left(q_{0}\\right) \\geqslant 2 n$.\n\nPROOF. By Proposition 4.6 there is a $(2 n, n)$-counter $\\mathcal{Z}=\\left(C,\\{\\mathrm{inc}\\}, c_{0}, \\rho, F\\right)$ with error probability $1 / 3$ which uses $\\mathcal{O}(1)$ space. Let $c_{\\infty} \\in F$ be an arbitrary high state. The algorithm $\\mathcal{T}_{n}$ maintains for every $q \\in Q$ an instance $\\mathcal{Z}_{q}$ of the $(2 n, n)$-counter $\\mathcal{Z}$. The input alphabet of $\\mathcal{Z}_{q}$ is $\\Sigma$ (instead of $\\{$ inc $\\}$ ) and the probability $\\mathcal{Z}_{q}(w, c)$ of reaching $c \\in C$ after reading the word\n\n$w \\in \\Sigma^{*}$ will satisfy\n\n$$\n\\underline{Z}_{q}(w, c)=\\underline{Z}\\left(\\ell_{w}(q), c\\right)\n$$\n\nwhere we set $\\underline{Z}\\left(\\infty, c_{\\infty}\\right)=1$ (and $\\underline{Z}(\\infty, c)=0$ for all states $c \\neq c_{\\infty}$ ) We initialize $\\underline{Z}_{q}$ in order to get (10) for $w=\\varepsilon$. To this end, we distinguish whether state $q$ has finite or infinite value $\\ell_{\\varepsilon}(q)$. Notice that $\\ell_{\\varepsilon}(q)$ is finite if and only if the final state $q_{F}$ can be reached from state $q$ by only reading the padding symbol $\\square$. If $\\ell_{\\varepsilon}(q)<\\infty$, then we initialize $\\underline{Z}_{q}$ in its initial state $c_{0}$ and then execute $\\ell_{\\varepsilon}(q)$ increments. If $\\ell_{\\varepsilon}(q)=\\infty$, we set $\\underline{Z}_{q}$ to state $c_{\\infty}$ (with probability one). Given an input symbol $a \\in \\Sigma$, we compute the new states of the counters $\\underline{Z}_{q}$ as follows: Assume that $c_{q}$ is the current state of $\\underline{Z}_{q}$. First we set $\\underline{Z}_{q_{F}}$ to the initial state $c_{0}$. This ensures (10) for $q_{F}$ since $\\ell_{w a}\\left(q_{F}\\right)=0$ and $\\underline{Z}\\left(0, c_{0}\\right)=1$. For $q \\in Q \\backslash\\left\\{q_{F}\\right\\}$ we set the new state of $\\underline{Z}_{q}$ with probability $\\rho\\left(c_{a \\cdot q}\\right.$, inc, $\\left.c\\right)$ to $c$. This ensures again (10):\n\n$$\n\\begin{aligned}\n\\underline{Z}_{q}(w a, c) & =\\sum_{c^{\\prime} \\in C} \\underline{Z}_{a \\cdot q}\\left(w, c^{\\prime}\\right) \\cdot \\rho\\left(c^{\\prime}, \\text { inc, } c\\right) \\\\\n& =\\sum_{c^{\\prime} \\in C} \\underline{Z}\\left(\\ell_{w}(a \\cdot q), c^{\\prime}\\right) \\cdot \\rho\\left(c^{\\prime}, \\text { inc, } c\\right) \\\\\n& =\\underline{Z}\\left(\\ell_{w}(a \\cdot q)+1, c\\right)=\\underline{Z}\\left(\\ell_{w a}(q), c\\right)\n\\end{aligned}\n$$\n\nThe algorithm $\\mathcal{F}_{n}$ accepts the word $w$ if and only if $\\underline{Z}_{q_{0}}$ is in a low state after reading $w$. Note that this happens with probability $1-\\underline{Z}_{q_{0}}^{\\mathrm{hi}}(w)=1-\\underline{Z}^{\\mathrm{hi}}\\left(\\ell_{w}\\left(q_{0}\\right)\\right)\\left(\\underline{Z}^{\\mathrm{hi}}(k)\\right.$ is the probability that $\\underline{Z}$ is in a high state after $k$ increments). Correctness follows from the fact that $\\underline{Z}$ is a $(2 n, n)$-counter with error probability $1 / 3$ :\n\n$$\n\\operatorname{Pr}\\left[\\mathcal{F}_{n} \\text { accepts } w\\right]=1-\\underline{Z}^{\\mathrm{hi}}\\left(\\ell_{w}\\left(q_{0}\\right)\\right)\\left\\{\\begin{array}{l}\n\\geqslant 2 / 3 \\text { if } \\ell_{w}\\left(q_{0}\\right) \\leqslant n \\\\\n\\leqslant 1 / 3 \\text { if } \\ell_{w}\\left(q_{0}\\right) \\geqslant 2 n\n\\end{array}\\right.\n$$\n\nThis proves the lemma.\nAlso note that the randomized SW-algorithm from the previous proof uses several probabilistic counters $\\underline{Z}_{q}$ (one for each state $q \\in Q$ ) and they all have the same parameters $\\ell=n$ and $h=2 n$. For each new input symbol, a subset of these counters have to be incremented. These increments are not needed to be independent. Hence, in each step, only the random bits for incrementing a single $(2 n, n)$-counter are needed. These random bits can be used for all $\\underline{Z}_{q}$ that have to be incremented.\n\nWe now come to the modulo counting algorithm, for which we use the following simple fact on prime numbers.\n\nLEMMA 4.9. There is a constant $c$ such that for every large enough $m \\in \\mathbb{N}$ and all $0 \\leqslant a, b \\leqslant m$ with $a \\neq b$ the following holds: If the prime number $p$ is picked uniformly at random among all prime numbers that are no greater than $c \\log m \\log \\log m$, then $\\operatorname{Pr}[a \\equiv b(\\bmod p)] \\leqslant 1 / 3$.\n\nPROOF. Let $p_{i}$ be the $i$-th prime number. It is known that $p_{i}<i \\cdot(\\ln i+\\ln \\ln i)$ for $i \\geqslant 6$ [83, page 3.13]. Fix an $m$ and let $k$ be the first natural number such that $\\prod_{i=1}^{k} p_{i} \\geqslant m$. Since $\\prod_{i=1}^{k} p_{i} \\geqslant$ $2^{k}$, we have $k \\leqslant \\log m$ and hence $p_{3 k} \\leqslant 3 \\log m \\cdot(\\ln (3 \\log m)+\\ln \\ln (3 \\log m)) \\leqslant c \\log m \\log \\log m$ for some constant $c$ and all large enough $m$.\n\nSince $-m \\leqslant a-b \\leqslant m$ and any product of at least $k+1$ pairwise distinct primes exceeds $m$, the integer $a-b \\neq 0$ has at most $k$ prime factors. Hence, for a randomly chosen prime $p \\in\\left\\{p_{1}, \\ldots, p_{3 k}\\right\\}$ we have $\\operatorname{Pr}[a \\equiv b(\\bmod p)] \\leqslant 1 / 3$.\n\nLEMMA 4.10 (modulo counting). There exists a randomized streaming algorithm $\\mathcal{M}_{n}$ with $O(\\log \\log n)$ bits such that for all $w \\in \\Sigma^{*}$ we have:\n\u2014 $\\operatorname{Pr}\\left[\\mathcal{M}_{n}\\right.$ accepts $\\left.w\\right]=1$, if $\\ell_{w}\\left(q_{0}\\right)=n$, and\n$-\\operatorname{Pr}\\left[\\mathcal{M}_{n}\\right.$ rejects $\\left.w\\right] \\geqslant 2 / 3$, if $\\ell_{w}\\left(q_{0}\\right)<2 n$ and $\\ell_{w}\\left(q_{0}\\right) \\neq n$.\n\nPROOF. Let $c$ be the constant from Lemma 4.9 which is applied with $m=2 n$. The algorithm $\\mathcal{M}_{n}$ initially picks a random prime $p \\leqslant c \\log (2 n) \\log \\log (2 n)$ which is stored throughout the run using $O(\\log \\log n)$ bits. Then, after reading $w \\in \\Sigma^{*}, \\mathcal{M}_{n}$ stores for every $q \\in Q$ a bit telling whether $\\ell_{w}(q)<\\infty$ and, if the latter holds, the value $\\ell_{w}(q) \\bmod p$ using in total $O(|Q| \\cdot \\log \\log n)$ bits. These numbers can be maintained according to (9). The algorithm accepts if and only if $\\ell_{w}\\left(q_{0}\\right) \\equiv n(\\bmod p)$.\n\nIf $\\ell_{w}\\left(q_{0}\\right)=n$ then the algorithm always accepts. Now, assume $\\ell_{w}\\left(q_{0}\\right)<2 n$ and $\\ell_{w}\\left(q_{0}\\right) \\neq n$. Then Lemma 4.9 with $a=\\ell_{w}\\left(q_{0}\\right)$ and $b=n$ yields $\\operatorname{Pr}\\left[\\ell_{w}\\left(q_{0}\\right) \\equiv n(\\bmod p)\\right] \\leqslant 1 / 3$. Therefore, $\\mathcal{M}_{n}$ rejects with probability at least $2 / 3$.\n\nIt is worth mentioning that in the above modulo counting algorithm the errors after reading different prefixes of an input stream $w$ are not independent. If for instance $w=u u$ with $|u|$ the window size, then the algorithm will make an error after reading $u$ if and only if it makes an error after reading $u u$. This is of course due to the fact that the only random choice is made at the very beginning. After this random choice, the algorithm proceeds deterministically.\n\nBy combining the algorithms from Lemma 4.8 and Lemma 4.10 we can prove Theorem 4.7. The algorithm $\\mathcal{P}_{n}$ is the conjunction of the threshold algorithm $\\mathcal{T}_{n}$ and the modulo counting algorithm $\\mathcal{M}_{n}$. Recall that last ${ }_{n}(w) \\in L$ if and only if $\\ell_{w}\\left(q_{0}\\right)=n$. If $\\ell_{w}\\left(q_{0}\\right)=n$ then $\\mathcal{T}_{n}$ accepts with probability at least $2 / 3$ and $\\mathcal{M}_{n}$ accepts with probability 1 ; hence $\\mathcal{P}_{n}$ accepts with probability at least $2 / 3$. If $\\ell_{w}\\left(q_{0}\\right) \\neq n$ then $\\mathcal{M}_{n}$ or $\\mathcal{T}_{n}$ rejects with probability at least $2 / 3$. Hence, $\\mathcal{P}_{n}$ rejects with probability at least $2 / 3$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 33,
      "text": "# 4.5 Lower bounds \n\nIn this section, we prove the lower bounds from Theorem 4.3. Point (2) from Theorem 4.3 follows easily from the relation $\\mathrm{F}_{L}(n)=2^{O\\left(\\mathrm{~F}_{L}^{\\prime}(n)\\right)}$ (Lemma 4.2). Since every language $L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$ satisfies $\\mathrm{F}_{L}(n)=\\Omega^{\\infty}(\\log n)$ (Theorem 3.2 and 3.3), it also satisfies $\\mathrm{F}_{L}^{\\prime}(n)=\\Omega^{\\infty}(\\log \\log n)$.\n\nFor (4) and (6) we apply known lower bounds from communication complexity by deriving a randomized communication protocol from a randomized SW-algorithm. This is in fact a standard technique for obtaining lower bounds for streaming algorithms; see e.g. [84].\n\nWe present the necessary background from communication complexity; see [71] for a detailed introduction. We only need the one-way setting where Alice sends a single message to Bob. Consider a function $f: X \\times Y \\rightarrow\\{0,1\\}$ for some finite sets $X$ and $Y$. A randomized one-way (communication) protocol $P=(a, b)$ consists of functions $a: X \\times R_{a} \\rightarrow\\{0,1\\}^{*}$ and $b:\\{0,1\\}^{*} \\times Y \\times R_{b} \\rightarrow\\{0,1\\}$, where $R_{a}$ and $R_{b}$ are finite sets of random choices of Alice and Bob, respectively. The cost of $P$ is the maximum number of bits transmitted by Alice, i.e.\n\n$$\n\\operatorname{cost}(P)=\\max _{x \\in X, r_{a} \\in R_{a}}\\left|a\\left(x, r_{a}\\right)\\right|\n$$\n\nMoreover, probability distributions are given on $R_{a}$ and $R_{b}$. Alice computes from her input $x \\in X$ and a random choice $r_{a} \\in R_{a}$ the value $a\\left(x, r_{a}\\right)$ and sends it to Bob. Using this value, his input $y \\in Y$ and a random choice $r_{b} \\in R_{b}$ he outputs $b\\left(a\\left(x, r_{a}\\right), y, r_{b}\\right)$. The random choices $r_{a} \\in R_{a}, r_{b} \\in R_{b}$ are chosen independently of each other. The protocol $P$ computes $f$ if for all $(x, y) \\in X \\times Y$ we have\n\n$$\n\\operatorname{Pr}_{r_{a} \\in R_{a}, r_{b} \\in R_{b}}[P(x, y) \\neq f(x, y)] \\leqslant \\frac{1}{3}\n$$\n\nwhere $P(x, y)$ is the random variable $b\\left(a\\left(x, r_{a}\\right), y, r_{b}\\right)$. The randomized one-way communication complexity of $f$ is the minimal cost among all one-way randomized protocols that compute $f$ (with an arbitrary number of random bits). The choice of the constant $1 / 3$ in (11) is arbitrary in the sense that changing the constant to any $\\lambda<1 / 2$ only changes the communication complexity by a constant (depending on $\\lambda$ ), see [71, p. 30]. We will use established lower bounds on the randomized one-way communication complexity of some functions.\n\nTHEOREM 4.11 ([70, Theorem 3.7 and 3.8]). Let $n \\in \\mathbb{N}$.\n\n- The index function\n\n$$\n\\operatorname{IDX}_{n}:\\{0,1\\}^{n} \\times\\{1, \\ldots, n\\} \\rightarrow\\{0,1\\}\n$$\n\nwith $\\operatorname{IDX}_{n}\\left(a_{1} \\cdots a_{n}, i\\right)=a_{i}$ has randomized one-way communication complexity $\\Theta(n)$.\n\n- The greater-than function\n\n$$\n\\mathrm{GT}_{n}:\\{1, \\ldots, n\\} \\times\\{1, \\ldots, n\\} \\rightarrow\\{0,1\\}\n$$\n\nwith $\\mathrm{GT}_{n}(i, j)=1$ if and only if $i>j$ has randomized one-way communication complexity $\\Theta(\\log n)$.\n\nThe upper bounds from these statements also hold for the deterministic one-way communication complexity as witnessed by the trivial deterministic protocols. We also define the equality function\n\n$$\n\\mathrm{EQ}_{n}:\\{1, \\ldots, n\\} \\times\\{1, \\ldots, n\\} \\rightarrow\\{0,1\\}\n$$\n\nby $\\operatorname{EQ}_{n}(i, j)=1$ if and only if $i=j$. Its randomized one-way communication complexity is $\\Theta(\\log \\log n)$ whereas its deterministic one-way communication complexity is $\\Theta(\\log n)$ [71].\n\nWe start with the proof of (6) from Theorem 4.3, which extends our linear space lower bound from the deterministic setting to the randomized setting.\n\nPROPOSITION 4.12. If $L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{L I}, \\operatorname{Len}\\rangle$ then $\\mathrm{F}_{L}^{r}(n)=\\Omega^{\\infty}(n)$.\nPROOF. By Theorem 3.3(ii) any rDFA for $L$ is not well-behaved and by Lemma 3.8 there exist words $u=u_{1} u_{2}, v=v_{1} v_{2}, z \\in \\Sigma^{*}$ such that $\\left|u_{1}\\right|=\\left|v_{1}\\right|,\\left|u_{2}\\right|=\\left|v_{2}\\right|$ and $L$ separates $u_{2}\\{u, v\\}^{*} z$ and $v_{2}\\{u, v\\}^{*} z$. Let $\\eta:\\{0,1\\}^{*} \\rightarrow\\{u, v\\}^{*}$ be the injective homomorphism defined by $\\eta(0)=u$ and $\\eta(1)=v$.\n\nNow, consider a randomized SW-algorithm $\\mathcal{P}_{n}$ for $L$ and window size $n=\\left|u_{2}\\right|+|u| \\cdot m+|z|$ for some $m \\geqslant 1$. We describe a randomized one-way communication protocol for IDX ${ }_{m}$.\n\nLet $\\alpha=\\alpha_{1} \\cdots \\alpha_{m} \\in\\{0,1\\}^{m}$ be Alice's input and $i \\in\\{1, \\ldots, m\\}$ be Bob's input. Alice reads $\\eta(\\alpha)$ into $\\mathcal{P}_{n}$ (using here random choices in order to select the outgoing transitions in $\\mathcal{P}_{n}$ ) and sends the memory state using $\\mathcal{O}\\left(s\\left(\\mathcal{P}_{n}\\right)\\right)$ bits to Bob. Continuing from the received state, Bob reads $u^{i} z$ into $\\mathcal{P}_{n}$. Then, the active window is\n\n$$\n\\operatorname{last}_{n}\\left(\\eta(\\alpha) u^{i} z\\right)=s \\eta\\left(\\alpha_{i+1} \\cdots \\alpha_{m}\\right) u^{i} z \\in\\left\\{u_{2}, v_{2}\\right\\}\\{u, v\\}^{*} z\n$$\n\nwhere $s=u_{2}$ if $\\alpha_{i}=0$ and $s=v_{2}$ if $\\alpha_{i}=1$. Hence, from the output of $\\mathcal{P}_{n}$ Bob can determine whether $\\alpha_{i}=1$. The cost of the protocol is bounded by $\\mathcal{O}\\left(s\\left(\\mathcal{P}_{n}\\right)\\right)$ and must be at least $\\Omega(m)=$ $\\Omega(n)$ by Theorem 4.11. We conclude that $s\\left(\\mathcal{P}_{n}\\right)=\\Omega(n)$ for infinitely many $n$ and therefore $\\mathrm{F}_{L}^{r}(n)=\\Omega^{\\infty}(n)$.\n\nNext, we prove point (4) from Theorem 4.3. For that, we need the following automaton property, where $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ is an rDFA.\n\nA pair $(p, q) \\in Q \\times Q$ of states is called synchronized if there exist words $x, y, z \\in \\Sigma^{*}$ with $|x|=|y|=|z| \\geqslant 1$ such that\n\n$$\nq \\stackrel{x}{\\leftarrow} q \\stackrel{y}{\\longleftarrow} p \\stackrel{z}{\\longleftarrow} p .\n$$\n\nA pair $(p, q) \\in Q \\times Q$ is called reachable if $p$ and $q$ are reachable from $q_{0}$ and $(p, q)$ is called $F$-consistent if either $\\{p, q\\} \\cap F=\\emptyset$ or $\\{p, q\\} \\subseteq F$. We remark that synchronized state pairs have no connection to the notion of synchronizing words.\n\nOur main technical result for synchronized pairs is the following:\nLEMMA 4.13. Assume that every reachable synchronized pair in $\\mathcal{B}$ is $F$-consistent. Then, $\\mathrm{L}(\\mathcal{B})$ belongs to $\\langle\\mathbf{S T}, \\mathbf{S F}, \\mathbf{L e n}\\rangle$.\n\nFor the proof of Lemma 4.13 we need two lemmas.\nLEMMA 4.14. A state pair $(p, q)$ is synchronized if and only if $p$ and $q$ are nontransient and there exists a nonempty run from $p$ to $q$ whose length is a multiple of $|Q|!$.\n\nPROOF. First assume that $(p, q)$ is synchronized. Let $x, y, z \\in \\Sigma^{*}$ with $|x|=|y|=|z|=k$ such that $q \\stackrel{x}{\\leftarrow} q \\stackrel{y}{\\leftarrow} p \\stackrel{z}{\\leftarrow} p$. Then, $p$ and $q$ are nontransient and we have\n\n$$\nq \\stackrel{x^{|Q|-1} y}{\\longleftarrow} p\n$$\n\nwhere $x^{|Q|-1} y$ has length $(|Q|!-1) \\cdot k+k=|Q|!\\cdot k$.\nConversely, assume that $p$ and $q$ are nontransient and there exists a nonempty run $q \\stackrel{y}{\\leftarrow} p$ whose length is divided by $|Q|$ !. Since the states $p$ and $q$ are nontransient, there are words $x$ and $z$ of length at most $|Q|$ with $q \\stackrel{x}{\\leftarrow} q$ and $p \\stackrel{z}{\\leftarrow} p$. These words can be pumped up to have length $|y|$.\n\nLet $Q=T \\cup N$ be the partition of the state set into the set $T$ of transient states and the set $N$ of nontransient states. A function $\\beta: \\mathbb{N} \\rightarrow\\{0,1\\}$ is $k$-periodic if $\\beta(i)=\\beta(i+k)$ for all $i \\in \\mathbb{N}$.\n\nLEMMA 4.15. Assume that every reachable synchronized pair in $\\mathcal{B}$ is $F$-consistent. Then, for every word $v \\in \\Sigma^{*}$ of length at least $|Q|!\\cdot(|T|+1)$ there exists a $|Q|!$-periodic function $\\beta_{v}: \\mathbb{N} \\rightarrow\\{0,1\\}$ such that the following holds: If $w \\in \\Sigma^{*} v$ and $w \\cdot q_{0} \\in N$, then we have $w \\in \\mathrm{~L}(\\mathcal{B})$ if and only if $\\beta(|w|)=1$.\n\nPROOF. Let $v=a_{k} \\cdots a_{2} a_{1}$ with $k \\geqslant|Q|!\\cdot(|T|+1)$, and consider the run\n\n$$\nq_{k} \\stackrel{a_{k}}{\\longleftarrow} \\cdots \\stackrel{a_{2}}{\\longleftarrow} q_{1} \\stackrel{a_{1}}{\\longleftarrow} q_{0}\n$$\n\nof $\\mathcal{B}$ on $v$. Clearly, each transient state can occur at most once in the run. First notice that for each $0 \\leqslant i \\leqslant|Q|!-1$ at least one of the states in\n\n$$\nQ_{i}=\\left\\{q_{i+j|Q|!}|0 \\leqslant j \\leqslant|T|\\right\\}\n$$\n\nis nontransient because otherwise the set would contain $|T|+1$ pairwise distinct transient states. Furthermore, we claim that the nontransient states in $Q_{i}$ are either all final or all nonfinal: Take two nontransient states $q_{i+j_{1}|Q|!}$ and $q_{i+j_{2}|Q|!}$ with $j_{1}<j_{2}$. Since we have a run of length $\\left(j_{2}-j_{1}\\right)|Q|$ ! from $q_{i+j_{1}|Q|!}$ to $q_{i+j_{2}|Q|!}$, these two states form a synchronized pair by Lemma 4.14, which by assumption must be $F$-consistent.\n\nNow, define $\\beta_{v}: \\mathbb{N} \\rightarrow\\{0,1\\}$ by\n\n$$\n\\beta_{v}(m)= \\begin{cases}1, & \\text { if the states in } Q_{m \\bmod |Q|!} \\cap N \\text { are final, } \\\\ 0, & \\text { if the states in } Q_{m \\bmod |Q|!} \\cap N \\text { are nonfinal, }\\end{cases}\n$$\n\nwhich is well-defined by the remarks above. Clearly $\\beta_{v}$ is $|Q|!$-periodic.\nLet $w=a_{m} \\cdots a_{2} a_{1} \\in \\Sigma^{*} v$ be a word of length $m \\geqslant k$. The run of $\\mathcal{B}$ on $w$ starting from the initial state prolongs the run in (12):\n\n$$\nq_{m} \\stackrel{a_{m}}{\\longleftarrow} \\cdots \\stackrel{a_{k+2}}{\\longleftarrow} q_{k+1} \\stackrel{a_{k+1}}{\\longleftarrow} q_{k} \\stackrel{a_{k}}{\\longleftarrow} \\cdots \\stackrel{a_{2}}{\\longleftarrow} q_{1} \\stackrel{a_{1}}{\\longleftarrow} q_{0}\n$$\n\nAssume that $q_{m} \\in N$. As argued above, there is a position $0 \\leqslant i<k$ such that $i \\equiv m(\\bmod |Q|!)$ and $q_{i} \\in N$. Therefore, there exists a nonempty run from $q_{i}$ to $q_{m}$ whose length is a multiple of $|Q|$ !. Hence, $\\left(q_{i}, q_{m}\\right)$ is a synchronized pair by Lemma 4.14, which is $F$-consistent by assumption. Therefore, $w \\in L$ if and only if $q_{m} \\in F$ if and only if $q_{i} \\in F$ if and only if $\\beta_{v}(|w|)=1$.\n\nWe can now prove Lemma 4.13.\nPROOF OF LEMMA 4.13. Given a subset $P \\subseteq Q$ let $\\mathrm{L}(\\mathcal{B}, P):=\\mathrm{L}\\left(Q, \\Sigma, P, \\delta, q_{0}\\right)$. Let $F_{N}=N \\cap F$ and $F_{T}=T \\cap F$. We disjointly decompose $L$ into\n\n$$\nL=\\mathrm{L}\\left(\\mathcal{B}, F_{N}\\right) \\cup \\bigcup_{q \\in F_{T}} \\mathrm{~L}(\\mathcal{B},\\{q\\})\n$$\n\nFirst observe that $\\mathrm{L}(\\mathcal{B},\\{q\\}) \\in \\mathbf{S F}$ for all $q \\in F_{T}$ because a transient state $q$ can occur at most once in a run of $\\mathcal{B}$.\n\nIt remains to show that $\\mathrm{L}\\left(\\mathcal{B}, F_{N}\\right)$ belongs to $\\langle\\mathbf{S T}, \\mathbf{S F}, \\mathbf{L e n}\\rangle$. Using the threshold $k=|Q|$ ! ( $|T|+1)$, we distinguish between words of length at most $k-1$ and words of length at least $k$, and group the latter set by their suffixes of length $k$ :\n\n$$\n\\mathrm{L}\\left(\\mathcal{B}, F_{N}\\right)=\\left(\\mathrm{L}\\left(\\mathcal{B}, F_{N}\\right) \\cap \\Sigma^{<k-1}\\right) \\cup \\bigcup_{v \\in \\Sigma^{k}}\\left(\\mathrm{~L}\\left(\\mathcal{B}, F_{N}\\right) \\cap \\Sigma^{*} v\\right)\n$$\n\nThe first part $\\mathrm{L}\\left(\\mathcal{B}, F_{N}\\right) \\cap \\Sigma^{<k-1}$ is finite and thus suffix testable. To finish the proof, we will show that $\\mathrm{L}\\left(\\mathcal{B}, F_{N}\\right) \\cap \\Sigma^{*} v \\in\\langle\\mathbf{S T}, \\mathbf{S F}, \\mathbf{L e n}\\rangle$ for each $v \\in \\Sigma^{k}$. Let $v \\in \\Sigma^{k}$ and let $\\beta_{v}: \\mathbb{N} \\rightarrow\\{0,1\\}$ be the $|Q|$ !-periodic function from Lemma 4.15. The lemma implies that\n\n$$\n\\mathrm{L}\\left(\\mathcal{B}, F_{N}\\right) \\cap \\Sigma^{*} v=\\left(\\Sigma^{*} v \\cap\\left\\{w \\in \\Sigma^{*} \\mid \\beta(|w|)=1\\right\\}\\right) \\backslash \\mathrm{L}(\\mathcal{B}, T)\n$$\n\nThe language $\\left\\{w \\in \\Sigma^{*} \\mid \\beta(|w|)=1\\right\\}$ is a regular length language, $\\Sigma^{*} v$ is suffix testable and $\\mathrm{L}(\\mathcal{B}, T)$ is a finite union of regular suffix-free languages.\n\nThe following lemma is an immediate consequence of Lemma 4.13.\nLEMMA 4.16. If $L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{S T}, \\mathbf{S F}, \\mathbf{L e n}\\rangle$ then there exist $u, x, y, z \\in \\Sigma^{*}$ with $|x|=|y|=|z| \\geqslant 1$ such that $L$ separates $x^{*} y z^{*} u$ and $z^{*} u$.\n\nNow, we can finally prove point (4) from Theorem 4.3.\nPROPOSITION 4.17. If $L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{S T}, \\mathbf{S F}, \\mathbf{L e n}\\rangle$ then $\\mathrm{F}_{L}^{\\prime}(n)=\\Omega^{\\infty}(\\log n)$.\nPROOF. Consider the words $u, x, y, z \\in \\Sigma^{*}$ described in Lemma 4.16. Let $n=|z| \\cdot m+|u|$ for some $m \\geqslant 1$ and let $\\mathcal{P}_{n}$ be a randomized SW-algorithm for $L$. We describe a randomized one-way protocol for $\\mathrm{GT}_{m}$ : Let $1 \\leqslant i \\leqslant m$ be the input of Alice and $1 \\leqslant j \\leqslant m$ be the input of Bob. Alice starts with reading $x^{m} y z^{m-i}$ into $\\mathcal{P}_{n}$. Then she sends the reached state to Bob using $O\\left(s\\left(\\mathcal{P}_{n}\\right)\\right)$\n\nbits. Bob then continues the run of $\\mathcal{P}_{n}$ from the transmitted state with the word $z^{j} u$. Hence, $\\mathcal{P}_{n}$ is simulated on the word $w:=x^{m} y z^{m-i} z^{j} u=x^{m} y z^{m-i+j} u$. We have\n\n$$\n\\operatorname{last}_{n}(w)= \\begin{cases}x^{i-1-j} y z^{m-i+j} u, & \\text { if } i>j \\\\ z^{m} u, & \\text { if } i \\leqslant j\\end{cases}\n$$\n\nBy Lemma 4.16, last $_{n}(w)$ belongs to $L$ in exactly one of the two cases $i>j$ and $i \\leqslant j$. Hence, Bob can distinguish these two cases with probability at least $2 / 3$. It follows that the protocol computes $\\mathrm{GT}_{m}$ and its cost is bounded by $s\\left(\\mathcal{P}_{n}\\right)$. By Theorem 4.11 we can conclude that $s\\left(\\mathcal{P}_{n}\\right)=$ $\\Omega(\\log m)=\\Omega(\\log n)$, and therefore $\\mathrm{F}_{L}^{r}(n)=\\Omega^{\\infty}(\\log n)$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 34,
      "text": "# 4.6 Sliding window algorithms with one-sided error \n\nSo far, we have only considered randomized SW-algorithms with two-sided error (analogously to the complexity class BPP). Randomized SW-algorithms with one-sided error (analogously to the classes RP and coRP) can be motivated by applications where all \"yes\"-outputs or all \"no\"outputs, respectively, have to be correct. We distinguish between true-biased and false-biased algorithms. A true-biased (randomized) streaming algorithm $\\mathcal{P}$ for a language $L$ satisfies the following properties:\n\u2014 If $w \\in L$ then $\\operatorname{Pr}[\\mathcal{P}$ accepts $w] \\geqslant 2 / 3$.\n\n- If $w \\notin L$ then $\\operatorname{Pr}[\\mathcal{P}$ rejects $w]=1$.\n\nA false-biased (randomized) streaming algorithm $\\mathcal{P}$ for a language $L$ satisfies the following properties:\n\u2014 If $w \\in L$ then $\\operatorname{Pr}[\\mathcal{P}$ accepts $w]=1$.\n\u2014 If $w \\notin L$ then $\\operatorname{Pr}[\\mathcal{P}$ rejects $w] \\geqslant 2 / 3$.\nLet $F_{L}^{0}(n)$ (resp., $F_{L}^{1}(n)$ ) be the minimal space complexity $s\\left(\\mathcal{P}_{n}\\right)$ of any true-biased (resp., falsebiased) SW-algorithm $\\mathcal{P}_{n}$ for $L$ and window size $n$. We have the relations $F_{L}^{r}(n) \\leqslant F_{L}^{i}(n) \\leqslant F_{L}(n)$ for $i \\in\\{0,1\\}$, and $F_{L}^{0}(n)=F_{\\Sigma^{\\wedge} \\backslash L}^{1}(n)$.\n\nFor $F_{L}^{0}(n)$ and $F_{L}^{1}(n)$ a statement analogous to Lemma 4.4 does not hold, i.e., the classes $\\left\\{L \\subseteq \\Sigma^{*} \\mid F_{L}^{i}(n)=O(s(n))\\right\\}$ for $\\mathrm{i} \\in\\{0,1\\}$ and a function $s(n)$ do not form a Boolean algebra. To see this, consider the language $L=\\left\\{\\$ w \\# w: w \\in\\{0,1\\}^{*}\\right\\}$. It is easy to see that $F_{L}^{1}(n)=$ $O(\\log n)$. On the other hand, every true-biased randomized (in fact, every nondeterministic) communication protocol for $\\mathrm{EQ}_{n}$ (over the domain $\\{1, \\ldots, n\\}$ ) has cost $\\Omega(\\log n)$ [84, Chapter 5]. This implies $F_{\\Sigma^{\\wedge} \\backslash L}^{1}(n)=F_{L}^{0}(n)=\\Omega^{\\infty}(n)$, where $\\Sigma=\\{0,1, \\$, \\#\\}$.\n\nWe show that for all regular languages SW-algorithms with one-sided error have no advantage over their deterministic counterparts:\n\nTHEOREM 4.18 (one-sided error). Let $L$ be regular.\n(i) If $L \\in\\langle\\mathbf{S T}$, Len $\\rangle$ then $F_{L}^{0}(n)$ and $F_{L}^{1}(n)$ are $O(1)$.\n\n(ii) If $L \\notin\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$ then $F_{L}^{0}(n)$ and $F_{L}^{1}(n)$ are $\\Omega^{\\infty}(\\log n)$.\n(iii) If $L \\in\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$ then $F_{L}^{0}(n)$ and $F_{L}^{1}(n)$ are $O(\\log n)$.\n(iv) If $L \\notin\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$ then $F_{L}^{0}(n)$ and $F_{L}^{1}(n)$ are $\\Omega^{\\infty}(n)$.\n\nThe upper bounds in (i) and (iii) already hold for deterministic SW-algorithms (Theorem 1.3). Moreover, the lower bound in (iv) already holds for SW-algorithms with two-sided error (Theorem 4.3(6)). It remains to prove point (ii) of the theorem. ${ }^{6}$ In fact we show that any nondeterministic SW-algorithm for a regular language $L \\notin\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$ requires space $\\Omega^{\\infty}(\\log n)$ (this generalizes the lower bound in the second equivalence of Theorem 1.3). A nondeterministic SW-algorithm for a language $L$ and window size $n$ is an NFA $\\mathcal{P}_{n}$ with $\\mathrm{L}\\left(\\mathcal{P}_{n}\\right)=\\operatorname{SW}_{n}(L)$, and its space complexity is $s\\left(\\mathcal{P}_{n}\\right)=\\log \\left|\\mathcal{P}_{n}\\right|$. If we have a true-biased randomized SW-algorithm for $L$ we can turn it into a nondeterministic SW-algorithm by keeping only those transitions with nonzero probabilities and making all states $q$ initial which have a positive initial probability $\\iota(q)>0$. Therefore, it suffices to show the following statement:\n\nPROPOSITION 4.19. Let $L \\in \\operatorname{Reg}\\backslash\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$. Then, for infinitely many $n$ every nondeterministic SW-algorithm $\\mathcal{P}_{n}$ for $L$ has $\\Omega(\\sqrt{n})$ many states.\n\nFor the proof of Proposition 4.19 we need the following lemma.\nLEMMA 4.20. Let $L \\subseteq a^{*}$ and $n \\in \\mathbb{N}$ such that $L$ separates $\\left\\{a^{n}\\right\\}$ and $\\left\\{a^{k} \\mid k>n\\right\\}$. Then, every NFA for $L$ has at least $\\sqrt{n}$ many states.\n\nPROOF. The easy case is $a^{n} \\in L$ and $a^{k} \\notin L$ for all $k>n$. If an NFA for $L$ has at most $n$ states then any successful run on $a^{n}$ must have a state repetition. By pumping one can construct a successful run on $a^{k}$ for some $k>n$, which is a contradiction.\n\nNow, assume $a^{n} \\notin L$ and $a^{k} \\in L$ for all $k>n$. The proof is essentially the same as for [64, Lemma 6], where the statement of the lemma is shown for $L=a^{*} \\backslash\\left\\{a^{n}\\right\\}$. Let us give the proof for completeness. It is known that every unary NFA has an equivalent NFA in so-called Chrobak normal form. A unary NFA in Chrobak normal form consists of a simple path (called the initial path in the following) whose starting state is the unique initial state of the NFA. From the last state of the initial path, edges go to a collection of disjoint cycles. In [50] it is shown that an $m$-state unary NFA has an equivalent NFA in Chrobak normal form whose initial path consists of $m^{2}-m$ states. Now, assume that $L$ is accepted by an NFA with $m$ states and let $\\mathcal{A}$ be the equivalent NFA in Chrobak normal form, whose initial path consists of $m^{2}-m$ states. If $n \\geqslant m^{2}-m$ then all states that are reached in $\\mathcal{A}$ from the initial state via $a^{n}$ belong to a cycle and every cycle contains such a state. Since $a^{n} \\notin L$, all these states are rejecting. Hence,\n\n[^0]\n[^0]:    6 Note that Theorem 4.18(iii)) generalizes the lower bound $F_{L}(n)=\\Omega^{\\infty}(\\log n)$ for languages $L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$; see Theorem 1.3.\n\n$a^{n+x \\cdot d} \\notin L$ for all $x \\geqslant 0$, where $d$ is the product of all cycle lengths. This contradicts the fact that $a^{k} \\in L$ for all $k>n$. Hence, we must have $n<m^{2}-m$ and therefore $m>\\sqrt{n}$.\n\nPROOF OF PROPOSITION 4.19. Let $L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{S T}$, Len $\\rangle$. By Lemma 3.13 and the results from Section 3.7 there are words $x, y, z \\in \\Sigma^{*}$ such that $|x|=|y|$ and $L$ separates $x y^{*} z$ and $y^{*} z$. Note that we must have $x \\neq y$.\n\nFix $m \\geqslant 0$ and consider the window size $n=|x|+m|y|+|z|$. Let $\\mathcal{P}_{n}=(Q, \\Sigma, I, \\Delta, F)$ be a nondeterministic SW-algorithm for $L$ and window size $n$, i.e., it is an NFA for $\\operatorname{SW}_{n}(L)$. Notice that $\\mathcal{P}_{n}$ separates $\\left\\{x y^{m} z\\right\\}$ and $\\left\\{x y^{k} z \\mid k>m\\right\\}$. We define an NFA $\\mathcal{A}$ over the unary alphabet $\\{a\\}$ as follows:\n\n- The state set of $\\mathcal{A}$ is $Q$.\n- The set of initial states of $\\mathcal{A}$ is $\\left\\{q \\in Q \\mid \\exists p \\in I: p \\xrightarrow{z} q\\right.$ in $\\left.\\mathcal{P}_{n}\\right\\}$.\n- The set of final states of $\\mathcal{A}$ is $\\left\\{p \\in Q \\mid \\exists q \\in F: p \\xrightarrow{z} q\\right.$ in $\\left.\\mathcal{P}_{n}\\right\\}$.\n- The set of transitions of $\\mathcal{A}$ is $\\left\\{(p, a, q) \\mid p \\xrightarrow{y} q\\right.$ in $\\left.\\mathcal{P}_{n}\\right\\}$.\n\nIt recognizes the language $\\mathrm{L}(\\mathcal{A})=\\left\\{a^{k} \\mid x y^{k} z \\in \\mathrm{SW}_{n}(L)\\right\\}$, and therefore $\\mathrm{L}(\\mathcal{A})$ separates $\\left\\{a^{m}\\right\\}$ and $\\left\\{a^{k} \\mid k>m\\right\\}$. By Lemma 4.20, $\\mathcal{A}$ has at least $\\sqrt{m}=\\Omega(\\sqrt{n})$ states. Hence, also the number of states of $\\mathcal{P}_{n}$ is in $\\Omega(\\sqrt{n})$.\n\nProposition 4.19 implies $F_{L}^{0}(n) \\geqslant 1 / 2 \\log n-O(1)$ on infinitely many $n$ for all $L \\in \\operatorname{Reg} \\backslash$ $\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$. Since Reg $\\backslash\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$ is closed under complement, this implies $F_{L}^{1}(n)=F_{\\Sigma^{\\prime} \\backslash L}^{0}(n) \\geqslant$ $1 / 2 \\log n-O(1)$ on infinitely many $n$ for all $L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{S T}, \\mathbf{L e n}\\rangle$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 35,
      "text": "# 4.7 Randomized variable-size model \n\nIn this section, we briefly look at randomized algorithms in the variable-size model. First we transfer the definitions from Section 2.5 in a straightforward way. A randomized variable-size sliding window algorithm $\\mathcal{P}$ for $L \\subseteq \\Sigma^{*}$ is a randomized streaming algorithm for $\\operatorname{SW}(L)$ (defined in (2) on page 14). Its space complexity is $v(\\mathcal{P}, n)=\\log \\left|M_{\\leqslant n}\\right| \\in \\mathbb{N} \\cup\\{\\infty\\}$ where $M_{\\leqslant n}$ contains all memory states in $\\mathcal{P}$ which are reachable with nonzero probability in $\\mathcal{P}$ on inputs $w \\in \\Sigma_{L}^{*}$ with $\\operatorname{mwl}(w) \\leqslant n$. Since the variable-size sliding window model subsumes the fixed-size model, we have $F_{L}^{\\prime}(n) \\leqslant v(\\mathcal{P}, n)$ for every randomized variable-size sliding window algorithm $\\mathcal{P}$ for $L$.\n\nAgain we raise the question if randomness can improve the space complexity in the variable-size model. We claim that, in contrast to the fixed-size model, randomness does not allow more space efficient algorithms in the variable-size setting. Clearly, all upper bounds for the deterministic variable-size setting transfer to the randomized variable-size setting, i.e., languages in $\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$ have $\\mathcal{O}(\\log n)$ space complexity, and empty and universal languages have $\\mathcal{O}(1)$ space complexity. For every regular language $L$ which is not contained in $\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$ we proved a linear lower bound on $F_{L}^{\\prime}(n)$ (Proposition 4.12), which is also a lower bound on the space complexity of any randomized variable-size sliding window algorithm for $L$. It remains\n\nto look at languages $\\emptyset \\subsetneq L \\subsetneq \\Sigma^{*}$, for which we have proved a logarithmic lower bound in the deterministic setting (Lemma 2.5).\n\nLEMMA 4.21. If $\\mathcal{P}$ is a randomized variable-size SW-algorithm for a language $\\emptyset \\subsetneq L \\subsetneq \\Sigma^{*}$ then $v(\\mathcal{P}, n)=\\Omega(\\log n)$.\n\nPROOF. Let $\\emptyset \\subsetneq L \\subsetneq \\Sigma^{*}$ be a language. There must be a length-minimal nonempty word $a_{1} \\cdots a_{k} \\in \\Sigma^{+}$such that $\\left|\\left\\{e, a_{1} \\cdots a_{k}\\right\\} \\cap L\\right|=1$ and we fix such a word $a_{1} \\cdots a_{k}$. By minimality we also have $\\left|\\left\\{a_{1} \\cdots a_{k}, a_{2} \\cdots a_{k}\\right\\} \\cap L\\right|=1$. Let $\\mathcal{P}$ be a randomized variable-size SW-algorithm for L. By Lemma 4.1 we can assume that the error probability of $\\mathcal{P}$ is at most $1 / 6$, which increases its space complexity $v(\\mathcal{P}, n)$ by a constant factor.\n\nFor every $n \\in \\mathbb{N}$ we construct a protocol for $\\mathrm{GT}_{n}$ with $\\operatorname{cost} \\mathcal{O}(v(\\mathcal{P}, n))$. With Theorem 4.11 this implies that $v(\\mathcal{P}, n)=\\Omega(\\log n)$. Let $1 \\leqslant i \\leqslant n$ be the input of Alice and $1 \\leqslant j \\leqslant n$ be the input of Bob. Alice starts two instances of $\\mathcal{P}$ (using independent random bits) and reads $a_{1}^{i}$ into both of them. She sends the memory states to Bob using $\\mathcal{O}(v(\\mathcal{P}, i)) \\leqslant \\mathcal{O}(v(\\mathcal{P}, n))$ bits. Bob then continues from both states, and reads $\\downarrow^{j} a_{2} \\cdots a_{k}$ into the first instance and $\\downarrow^{j+1} a_{1} a_{2} \\cdots a_{k}$ into the second instance. Let $y_{1}, y_{2} \\in\\{0,1\\}$ be the outputs of the two instances of $\\mathcal{P}$. With high probability, namely $(1-1 / 6)^{2} \\geqslant 2 / 3$, both answers are correct, i.e.\n\n$$\ny_{1}=1 \\Longleftrightarrow \\operatorname{wnd}\\left(a_{1}^{i} \\downarrow^{j} a_{2} \\cdots a_{k}\\right) \\in L\n$$\n\nand\n\n$$\ny_{2}=1 \\Longleftrightarrow \\operatorname{wnd}\\left(a_{1}^{i} \\downarrow^{j+1} a_{1} a_{2} \\cdots a_{k}\\right) \\in L\n$$\n\nBob returns true, i.e., he claims $i>j$, if and only if $y_{1}=y_{2}$.\nLet us prove the correctness. If $i>j$ then\n\n$$\n\\operatorname{wnd}\\left(a_{1}^{i} \\downarrow^{j} a_{2} \\cdots a_{k}\\right)=a_{1}^{i-j} a_{2} \\cdots a_{k}=\\operatorname{wnd}\\left(a_{1}^{i} \\downarrow^{j+1} a_{1} a_{2} \\cdots a_{k}\\right)\n$$\n\nand hence Bob returns true with probability at least $2 / 3$. If $i \\leqslant j$ then\n\n$$\n\\operatorname{wnd}\\left(a_{1}^{i} \\downarrow^{j} a_{2} \\cdots a_{k}\\right)=a_{2} \\cdots a_{k}\n$$\n\nand\n\n$$\n\\operatorname{wnd}\\left(a_{1}^{i} \\downarrow^{j+1} a_{1} a_{2} \\cdots a_{k}\\right)=a_{1} a_{2} \\cdots a_{k}\n$$\n\nBy assumption, exactly one of the words $a_{1} \\cdots a_{k}, a_{2} \\cdots a_{k}$ belongs to $L$, and therefore Bob returns false with probability at least $2 / 3$.\n\nThe lower bound from Lemma 4.21 also holds for variable-size SW-algorithms with onesided error since they are more restricted than algorithms with two-sided error. In fact, Lemma 4.21 also holds for nondeterministic and co-nondeterministic SW-algorithms since the (co-)nondeterministic communication complexity of $\\mathrm{GT}_{n}$ is $\\Theta(\\log n)$ [84, Chapter 5].",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 36,
      "text": "# 5. Property testing in the sliding window model \n\nIn all settings discussed so far, there are some regular languages for which testing membership in the sliding window model requires linear space. To be more specific, for any language $L \\in \\operatorname{Reg} \\backslash\\langle\\mathbf{L I}, \\mathbf{L e n}\\rangle$ it requires linear space to test membership even for randomized sliding window algorithms with two-sided error. In order to achieve space-efficient sliding window algorithms for all regular languages, we have to allow randomized sliding window algorithms that are allowed to err with unbounded probability on some specific inputs. We formalize this in the context of the property testing framework. More precisely, we introduce in this section sliding window (property) testers, which must accept if the active window belongs to a language $L$ and reject if it has large Hamming distance from $L$.\n\nFor words that are not in $L$ but that have small Hamming distance from $L$ the algorithm is allowed to give any answer. We consider deterministic sliding window property testers and randomized sliding window property testers.\n\nWhile at first sight the only connection between property testers and sliding window property testers is that we must accept the input if it satisfies a property $P$ and reject if it is far from satisfying $P$, there is, in fact, a deeper link. In particular, the property tester for regular languages due to Alon et al. [2] combined with an optimal sampling algorithm for sliding windows [18] immediately yields $O(\\log n)$-space, two-sided error sliding window property testers with Hamming gap $\\gamma(n)=\\epsilon n$ for all regular languages. We will improve on this observation.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 37,
      "text": "### 5.1 Sliding window testers\n\nThe Hamming distance between two words $u=a_{1} \\cdots a_{n}$ and $v=b_{1} \\cdots b_{n}$ of equal length is the number of positions where $u$ and $v$ differ, i.e., $\\operatorname{dist}(u, v)=\\left|\\left\\{i \\mid a_{i} \\neq b_{i}\\right\\}\\right|$. If $|u| \\neq|v|$ we set $\\operatorname{dist}(u, v)=\\infty$. The distance of a word $u$ to a language $L$ is defined as\n\n$$\n\\operatorname{dist}(u, L)=\\inf \\{\\operatorname{dist}(u, v) \\mid v \\in L\\} \\in \\mathbb{N} \\cup\\{\\infty\\}\n$$\n\nAdditionally, we define the prefix distance between equal-length words $u=a_{1} \\cdots a_{n}$ and $v=$ $b_{1} \\cdots b_{n}$ by $\\operatorname{pdist}(u, v)=\\min \\left\\{i \\in\\{0, \\ldots, n\\} \\mid a_{i+1} \\cdots a_{n}=b_{i+1} \\cdots b_{n}\\right\\}$. For instance, we have $\\operatorname{pdist}(a b b a c a, a b c a c a)=3$ and $\\operatorname{pdist}(a b c c c a, a b c a c a)=4$ (whereas the Hamming distance in both cases is 1). Clearly, we have $\\operatorname{dist}(u, v) \\leqslant \\operatorname{pdist}(u, v)$. The algorithms presented in this section satisfy the stronger property that windows whose prefix distance to the language $L$ is large are rejected by the algorithm.\n\nIn this section, $\\gamma$ is always a function $\\gamma: \\mathbb{N} \\rightarrow \\mathbb{R}_{\\geqslant 0}$ such that $\\gamma(n)<n$ for all $n$. A deterministic sliding window (property) tester with Hamming gap $\\gamma(n)$ for a language $L \\subseteq \\Sigma^{*}$ and window size $n$ is a deterministic streaming algorithm $\\mathcal{P}_{n}$ over the alphabet $\\Sigma$ with the following properties:\n\u2014 If last $_{n}(w) \\in L$, then $w \\in \\mathrm{~L}\\left(\\mathcal{P}_{n}\\right)$.\n\n- If $\\operatorname{dist}\\left(\\operatorname{last}_{n}(w), L\\right)>\\gamma(n)$, then $w \\notin \\mathrm{~L}\\left(\\mathcal{P}_{n}\\right)$.\n\nIf neither of the two cases hold, the behavior of $\\mathcal{P}_{n}$ can be arbitrary. Recall that $s\\left(\\mathcal{P}_{n}\\right)$ is the space used by $\\mathcal{P}_{n}$ (see Section 2.3). A randomized sliding window tester with Hamming gap $\\gamma(n)$ for a language $L \\subseteq \\Sigma^{*}$ and window size $n$ is a randomized streaming algorithm $\\mathcal{P}_{n}$ over the alphabet $\\Sigma$ with the following properties. It has two-sided error if for all $w \\in \\Sigma^{*}$ we have:\n\n- If last ${ }_{n}(w) \\in L$, then $\\operatorname{Pr}\\left[\\mathcal{P}_{n}\\right.$ accepts $\\left.w\\right] \\geqslant 2 / 3$.\n- If $\\operatorname{dist}\\left(\\operatorname{last}_{n}(w), L\\right)>\\gamma(n)$, then $\\operatorname{Pr}\\left[\\mathcal{P}_{n}\\right.$ rejects $\\left.w\\right] \\geqslant 2 / 3$.\n\nIt is true-biased if for all $w \\in \\Sigma^{*}$ we have:\n\n- If last ${ }_{n}(w) \\in L$, then $\\operatorname{Pr}\\left[\\mathcal{P}_{n}\\right.$ accepts $\\left.w\\right] \\geqslant 2 / 3$.\n- If $\\operatorname{dist}\\left(\\operatorname{last}_{n}(w), L\\right)>\\gamma(n)$, then $\\operatorname{Pr}\\left[\\mathcal{P}_{n}\\right.$ rejects $\\left.w\\right]=1$.\n\nIt is false-biased if for all $w \\in \\Sigma^{*}$ we have:\n\n- If last ${ }_{n}(w) \\in L$, then $\\operatorname{Pr}\\left[\\mathcal{P}_{n}\\right.$ accepts $\\left.w\\right]=1$.\n- If $\\operatorname{dist}\\left(\\operatorname{last}_{n}(w), L\\right)>\\gamma(n)$, then $\\operatorname{Pr}\\left[\\mathcal{P}_{n}\\right.$ rejects $\\left.w\\right] \\geqslant 2 / 3$.\n\nTrue-biased and false-biased algorithms are algorithms with one-sided error. Again, the success probability $2 / 3$ is an arbitrary choice in light of Lemma 4.1.\n\nIntuitively, the Hamming gap function $\\gamma$ should be a small function. Typical choices for $\\gamma(n)$ are $\\epsilon n$ for some constant $\\epsilon(0<\\epsilon<1)$ or $\\gamma(n)=c$ for a constant $c$. We will also consider Hamming gap functions that are between these two cases. The case $\\gamma(n)=0$ for all $n$ corresponds to exact membership testing to $L$, which was studied in the previous sections.\n\nLet us also remark that we only consider the fixed-size sliding window model in this section. One might also consider variable-size sliding window testers, where the size of the window can grow and shrink. We leave this for future work. Moreover, we only consider the Hamming distance in this paper. One might also consider other distances on words, like for instance edit distance. We believe that Hamming distance is the most basic distance measure on strings. The upper bounds stated below also apply to edit distance (since the edit distance is always bounded by the Hamming distance). Whether our lower bounds can be extended to edit distance remains open.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 38,
      "text": "# 5.2 Main results of this section \n\nLet us now state and discuss the main results of this section. We start with our upper bounds:\nTHEOREM 5.1. For every regular language $L$ and window size $n$ there exists a deterministic sliding window tester $\\mathcal{P}_{n}$ with Hamming gap $O(1)$ and $s\\left(\\mathcal{P}_{n}\\right)=O(\\log n)$.\n\nWe will later see that allowing a larger (but not too large) Hamming gap in Theorem 5.1 does not allow a better space bound. This changes if we allow randomized sliding window testers with a two-sided error:\n\nTHEOREM 5.2. For every regular language $L$ there is a constant $c$ such that the following holds: If the function $\\gamma(n)$ and the window size $n$ satisfy $\\gamma(n) \\geqslant c$ then there is a randomized sliding window tester $\\mathcal{P}_{n}$ for $L$ and window size $n$ with a two-sided error, Hamming gap $\\gamma(n)$, and $s\\left(\\mathcal{P}_{n}\\right)=O(\\log (n / \\gamma(n)))$.\n\nFrom Theorem 5.2 we will easily obtain the following corollary:\nCOROLLARY 5.3. For every regular language $L$, every window size $n$ and every $0<\\epsilon<1$ there exists a randomized sliding window tester $\\mathcal{P}_{n}$ with two-sided error, Hamming gap en and $s\\left(\\mathcal{P}_{n}\\right)=O(1 / \\epsilon)$.\n\nThe upper bounds in Theorem 5.1 and Theorem 5.2 hold for all regular languages. We will also identify subclasses for which these upper bounds can be improved. Recall the definition of suffix-free languages from Section 1.2. Another important language class in the context of sliding-window testers is the class of trivial languages. A language $L \\subseteq \\Sigma^{*}$ is $\\gamma(n)$-trivial (for a function $\\gamma(n)<n$ ) if for all $n \\in \\mathbb{N}$ with $L \\cap \\Sigma^{n} \\neq \\emptyset$ and all $w \\in \\Sigma^{n}$ we have $\\operatorname{dist}(w, L) \\leqslant \\gamma(n)$. If $L$ is $O(1)$-trivial we say that $L$ is trivial. Examples of trivial languages include all length languages, all suffix (resp., prefix) testable languages (in particular, $L=a\\{a, b\\}^{*}$ for which $\\mathrm{F}_{L}(n)=\\Theta(n)$ holds), and also the set of all words over $\\{a, b\\}$ which contain an even number of $a$ 's. Note that Alon et al. [2] call a language $L$ trivial if $L$ is $o(n)$-trivial according to our definition, i.e., $\\gamma(n)$ trivial for some function $\\gamma(n)=o(n)$. In fact, we will prove that both definitions coincide for regular languages (Theorem 5.24). With Triv we denote the set of all regular trivial languages.\n\nWe can achieve a Hamming gap of $\\gamma(n)$ simply with a deterministic sliding window tester that accepts or rejects all input words depending on the input length. Moreover, the tester has only one state and hence uses space $\\log (1)=0$. It turns out that for finite unions of regular trivial languages and regular suffix-free languages, we can obtain a doubly logarithmic space bound if we allow false-biased randomized sliding window testers. Let us write $\\cup$ (Triv, SF) for the class of all finite unions of regular trivial languages and regular suffix-free languages.\n\nTHEOREM 5.4. For every $L \\in \\bigcup$ (Triv, SF) and window size $n$ there exists a false-biased randomized sliding window tester $\\mathcal{P}_{n}$ with Hamming gap $O(1)$ and $s\\left(\\mathcal{P}_{n}\\right)=O(\\log \\log n)$.\n\nLet us now discuss our lower bounds. It turns out that the above upper bounds are sharp in most cases. First of all, the logarithmic space bound in Theorem 5.1 cannot be improved whenever $L$ is a regular nontrivial language. This holds even for randomized true-biased algorithms and a Hamming gap en (assuming $\\epsilon<1$ is not too big). Similarly, the doubly logarithmic space bound in Theorem 5.4 cannot be improved.\n\nTHEOREM 5.5. For every language $L \\in \\operatorname{Reg} \\backslash$ Triv there exist $\\epsilon>0$ and infinitely many window sizes $n \\in \\mathbb{N}$ for which every true-biased (resp., false-biased) randomized sliding window tester for $L$ with Hamming gap en uses space at least $\\log n-O(1)$ (resp. $\\log \\log n-O(1))$.\n\n![img-4.jpeg](img-4.jpeg)\n\nFigure 5. The space complexity of regular languages with respect to deterministic, true-biased and false-biased sliding window testers. As in Figure 1, only upper bounds are shown, and they hold for every Hamming gap function $\\gamma(n)$ provided that $\\gamma(n) \\geqslant c$ for a constant $c$ that depends on the language. All upper bounds can be matched with lower bounds that hold for every $\\gamma(n) \\leqslant \\epsilon n$ for a constant $\\epsilon$ that depends on the language.\n\nMoreover, also for false-biased randomized sliding window testers the logarithmic space bound from Theorem 5.1 cannot be improved whenever $L \\in \\operatorname{Reg} \\backslash \\cup$ (Triv, SF):\n\nTHEOREM 5.6. If $L \\in \\operatorname{Reg} \\backslash \\cup$ (Triv, SF) then there exist $\\epsilon>0$ and infinitely many window sizes $n \\in \\mathbb{N}$ for which every false-biased randomized sliding window tester for $L$ with Hamming gap en uses at least $\\log n-O(1)$ space.\n\nThe above results provide matching upper and lower space bounds for deterministic, true-biased and false-biased sliding window testers; see also Figure 5. Moreover, the upper bounds hold for a constant Hamming gap (Theorems 5.1 and 5.4) whereas the lower bounds hold for Hamming gap en as long as $\\epsilon$ is larger than a language-dependent constant (Theorems 5.5 and 5.6). Thus, in the deterministic, true-biased and false-biased settings, the space complexity is quite insensitive to the choice of the Hamming gap function $\\gamma(n)$.\n\nFor randomized sliding window testers with a two-sided error, the situation is different. We have already discussed Theorem 5.2, where the Hamming gap $\\gamma(n)$ is reflected in the space bound. It turns out that the upper bound in Theorem 5.2 is tight whenever $L$ is not a finite union of regular trivial languages and regular suffix-free languages:\n\nTHEOREM 5.7. If $L \\in \\operatorname{Reg} \\backslash \\cup$ (Triv, SF) then there exist $\\epsilon>0$ and infinitely many window sizes $n \\in \\mathbb{N}$ for which every randomized sliding window tester with two-sided error for $L$ and Hamming gap $\\gamma(n) \\leqslant \\epsilon n$ needs space $\\Omega(\\log (n / \\gamma(n)))$.\n\nIf $L \\in \\bigcup$ (Triv, SF) then the lower bound from Theorem 5.7 does not hold in general, since we have an upper bound of $O(\\log \\log n)$ from Theorem 5.4. ${ }^{7}$ We do not know whether there is\n\n[^0]\n[^0]:    7 Note that if $\\gamma(n)=O(n / \\log n)$ then the lower bound $\\Omega^{\\infty}(\\log (n / \\gamma(n)))$ becomes $\\Omega^{\\infty}(\\log \\log n)$.\n\na matching lower bound of $\\Omega^{\\infty}(\\log \\log n)$ for nontrivial languages. Currently, we can only show a slightly weaker lower bound in this case:\n\nTHEOREM 5.8. If $L \\in \\operatorname{Reg} \\backslash$ Triv then there exist $\\epsilon>0$ and infinitely many window sizes $n \\in \\mathbb{N}$ for which every randomized sliding window tester with two-sided error for $L$ and Hamming gap $\\gamma(n) \\leqslant \\epsilon n$ needs space $\\Omega(\\log \\log (n / \\gamma(n)))$.\n\nNote that whenever $\\gamma(n)=\\mathcal{O}\\left(n^{c}\\right)$ for some $c<1$ then the lower bound $\\Omega^{\\infty}(\\log \\log (n / \\gamma(n)))$ from Theorem 5.8 becomes $\\Omega^{\\infty}(\\log \\log n)$, which matches the upper bound from Theorem 5.4. It is left open to classify the space complexity for languages in $\\bigcup$ (Triv, SF) $\\backslash$ Triv, e.g. $L=a b^{*}$, for sublinear Hamming gaps $\\gamma(n)$ which are $\\Omega\\left(n^{c}\\right)$ for all $c<1$, e.g. $\\gamma(n)=n / \\log n$.\n\nLet us also remark that Lemma 4.2 does not generalize to sliding window testers (with the obvious generalization of the space complexities $\\mathrm{F}_{L}(n)$ and $\\mathrm{F}_{L}^{r}(n)$ to sliding window testers). In the proof of Lemma 4.2 we used the fact that a randomized sliding window algorithm for a language $L$ and a window size $n$ is a probabilistic finite automaton with the isolated cut-point $1 / 2$. This is not necessarily true for randomized sliding window testers. If $w$ is a word such that neither last $_{n}(w) \\in L$ nor $\\operatorname{dist}\\left(\\operatorname{last}_{n}(w), L\\right)>\\gamma(n)$ holds then $\\operatorname{Pr}\\left[\\mathcal{P}_{n}\\right.$ accepts $\\left.w\\right]=1 / 2$ is possible. Indeed, the generalization of Lemma 4.2 to sliding window testers would contradict Corollary 5.3 together with Theorem 5.5.",
      "tables": {},
      "images": {
        "img-4.jpeg": "data:image/jpeg;base64,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ySvFtwz5IGCcZ6nn2r1sgdcVwvxD+HcXjmOxnjv307UrBi1vcKm8c4JDDgnkDBB454oA8qsPDPxvsNOghtLq4jhgjVYoftkJKKBwuCewxxXb/Bfx5rXiqPU9N1797eacUxPsCswYkENjjIK/jn2JrUk0b4oT2/2V/FGiwIy7TcxWTeb+RO3Na3gTwJp/gTTpbe1nkuru6cPdXcgw0pGcfQDJOMnqeeaAOvooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigApNo9BS0UAFFFFABRiiigAxRRRQAUUUUAFJgegpaKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooATAHYUuOc0UUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVzUWoXbfEu500zMbNNIhnWLt5hmkUtn6KK6WuRh/wCSvXn/AGAYP/SiWgDrqKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKx/Fl3PYeDdcvLWQxXFvp9xLFIoyVZY2II+hFbFYPjf/AJEDxH/2C7n/ANFNQBo6RNJcaNYzSuXkkt42Zj/ESoJNXaoaH/yANN/69Yv/AEEVfoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK5KH/AJK9ef8AYBg/9Hy11tclD/yV68/7AMH/AKPloA62iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsHxx/wAiB4j/AOwXc/8Aopq3qwfHH/IgeI/+wXc/+imoAv6H/wAi/pv/AF6xf+gir9UND/5F/Tf+vWL/ANBFX6ACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACuSh/5K9ef9gGD/0fLXW1yUP/ACV68/7AMH/o+WgDraKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKwfHH/IgeI/+wXc/wDopq3qwfHH/IgeI/8AsF3P/opqAL+h/wDIv6b/ANesX/oIq/VDQ/8AkX9N/wCvWL/0EVfoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK5KH/kr15/2AYP/AEfLXW1yUP8AyV68/wCwDB/6PloA62iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsTxlDLceB/EEEEbyyyabcIkaAlmYxsAAB1JNbdFAGfoqvHolgjqyutvGrKwwVIUZGK0KMD0ooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACisLxJ4v0PwparcaxqEVtv4jjOWeQ/7Krlj9QCBXF3Wr/EvVLRtV8Px6aLcHdHY3lnJBLIvoC7Ddx3+SgD1GiuE+G3xDHjmwuUu7X7Fq1k4S6tuQAefmGeQMggg8gjqeK7K7vILGzmurmZIYIUMkkkjYVVHUk9hQBZorA0zU9T1bSZtTgt4olni36fb3BKkjB2tKwB27sg7QCVHqTgc14U8fazq3xC1LwlrOkWtncWNsZ3kgnLg8x7cZA4IkzQB6JRRRQAU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H+Gfjbx9rq3D3egQ2VqZI7RPNmD+WWyC/wAh+bGM44r22gDAwKAOb8GWXiLTtAhsfEb6dJPbKsMT2Jcho1UAF9wHzcduK8/+Jnwl1bxV4tg1/QL2ytZzCqz+e7qS6n5XG1Wz8uB2+6K9kwPSjAoAyvD2kReH/Dun6RCBstIFiyP4iBy34nJ/GuD02LxLZfHS8t212a/0ia0e5ktS5K2yscIm08KcjgjkjOeteoHjJqhpmjado0cqafZxW/nSGSUoPmkc9WZjyx9zQAzXtGt/EGhXukXTMsN3C0TMp+ZcjgjPcV5f4U8G/EbwBFcado11oepaXJJvjF28iMjYwSABxnAyMn1HOa9jooA828NfDq+i8ZzeM/Fd9b3mtOMRRWiEQW4wFBG7k4XgZHcnk81k/E34f+NfH91FCk+g2+nWkjtbAyzCVt2Pv/IRnjtXr+B6UYHpQBw3w90bxf4c0610bW20STTrSAxxSWTytMWzkBtygYwT+ldwQOuBS8VS1KC6ubGSC0vDaSuMGYIGZF7lcnG7HQnIB7GgDiLLTT4i+Mdz4gIzYaFa/wBnwP2e5bJkx/uhyp9/oa9Eqjpem2uj6fBY2cXlwRDCgtkkk5JJPJJJySepNXqACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAwPSiiigAooooAKKKKADFFFFABRRRQAYooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK5KH/kr15/2AYP/R8tdbXJQ/8AJXrz/sAwf+j5aAOtooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKADFFFFABRRRQAYooooAKKKKACiikJCqSSABySaAFopoPTmnUAFFFFABRRRQAUUUUAFFFFABiiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK5KH/AJK9ef8AYBg/9Hy11tclD/yV68/7AMH/AKPloA62iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACsHxv/wAiB4j/AOwXc/8Aopq3qwfHH/IgeI/+wXc/+imoAvaGP+JBpv8A16xf+gitCqGh/wDIv6b/ANesX/oIq/QAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVyUP/JXrz/sAwf8Ao+Wutrkof+SvXn/YBg/9Hy0AdbRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABWD44/5EDxH/wBgu5/9FNW9WD44/wCRA8R/9gu5/wDRTUAX9D/5F/Tf+vWL/wBBFX6oaH/yL+m/9esX/oIq/QAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVyUP/ACV68/7AMH/o+Wutrkof+SvXn/YBg/8AR8tAHW0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAVg+OP+RA8R/wDYLuf/AEU1b1YPjj/kQPEf/YLuf/RTUAX9D/5F/Tf+vWL/ANBFX6oaH/yL+m/9esX/AKCKv0AFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAB6VjJo23xdNr32nJlsY7PydnQLIz7s5778Yx2rZowB2oAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKy/EthNqvhXWNOttvn3dlNBHvOBudCoz7ZNalFAFTTIHtNLs7aXG+KFI2CnIyFwat0UUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRUNxcw2sDz3EqxQxqWkeRgoVR1JJ4ArzuTx3ceM7iXTvBiak0UL7bjVYYolhU/wB1Wl4PXOApPII4oA9KorxLxNffEH4YT2+sza23iHQXkWO4jnhVHQn6cr6A5xnAI6Z9h03UbfVtLtdRs5A9tcxLLE/qrDIzQBcorm9V12Z9dg8OaU6/2hLEZ7mYruFpD03EdC5JAUdOrHgYOzNc2+nWZlurtYYIkG+aeQKAMdWY8UAW6K84svi3p+qfEDT/AA1pljNcW94shXUHYojbFc5RSMuuUZd3HIPUV313DJcWzxRXMlvIcbZI8EqeoOD1+negCzRWB4f199SuL3Tb5Eg1bTpBFcxITtYEZSVM/wADDkdxyDnGa36ACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooPSuP1n4neEPD+rT6XqusC2vYNvmRG3lbbuUMOQhHQjvQB2FFcD/wuj4f4z/wkK/jazf/ABFX9F+J3hDxDq8GlaXrIuL2fd5cYglXdhSx5ZAOACevagDr6KKQ5wcdaAForznxR8XtM8LeM7fw5caddzu/l+ZNHgBN/TA6t1FeiAnjn8aAHUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUVVvb+0021a6vbuG1tkI3zTyBEXJwMseOpAoAtUVg/8Jt4U/6GjRf/AAPi/wDiqP8AhNvCn/Q0aL/4Hxf/ABVAG9RVayvbXUbVLuyuobm2kzslhcOjYODgjg8jFWe1ABRWfrGrWeg6Rc6pqExjtLZDJI+CSB7AdetZfhHxvo3jeymutHllZYJBHKksexlPUcdMH2zQB0lFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFB6HPSig9KAPEPinrF74u8cab8N9JnaKKV1fUJE+m7B9lT5sdyR6V69o2kWGg6TbaXp0Cw2lumxFHf1JPcnqT6mvE/DgGnftPaxHqPyS3Al+zF/wCLcqsuCf8AYB/HivfD0J9utAHnvxsvYLP4VaskuN1w0UUYPdjIp/QKT+FaHwrgls/hdoCXAwxtvMOeyszMP0Irzjxvcz/Ff4h2XhHRnMmjaZJ5t/dJ9wN0Y59hlV9Sx7c17eLOOLTfsNuoihSHyo1UYCKBgAD6UAebfBq7bX08UeKZmJl1LU9gB/hijQGMfgHx+Feg63oOmeI7D7Bq1nHd228SeW+cBh0OR9T+dec/s/I0HgbULSVds1tqssciHqCETP8An2r1nFAHimsW0Fn+0t4Ut7aFIYI9NKxxoAqqoScAAdgK9r7V4x4gI/4ag8M8/wDMPOf++Lj/AOtXs56UAeWeMbz/AIR34zeDtTR9qatFJpk6j+Ndylc/8DkX8q9TryL4qwvffEj4b2kAzIt+8zAdQqvCxP5K35V65jFAC0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAIehrktI8FR6f4+13xTPJFNLqSxJCvl4MIVQrck87tqn8K66igD5bXA/abI4A/tc/yr3HXfBpu/G+keLbAwJd6ZBOjQsuDc7oyqKWHTBY8+hrw9f+Tnf+4wf5V9R4oA8V/4Xtdad4pl0XXvDRs3hZ0k8i58594UlVUBQG3HaBz3qxo3xg1y48eWnhvWfCrae11IEC+aTLGGGQxyMMPXpjn6VwepxpP+0+qSDcv9qwNg+qqhH6ivpP8Asyw/tL+0vsVt9u2eX9p8pfN2/wB3djOOTxnvQB4vr/xTu9I8aWmn6/4F04anG0YhuGuVkZFY8MjbOnXjIwa634i/ELWfAbJcr4cS80uRljW7F3sIcgnay7SR04PSvKvjXx8ZtNP/AExtv/RjV7t478OL4q8E6npG0GaWEtB7Sr8yc9uQB9CaAMfwX411/wAYeHLjWU0C2t4Wjc2QN9u86RSRtb5RsGR1qt4L8f8AiDxV4hvbCbwzFaWmn3D297ci98zy5BkbVG0b/mAGR0BzXnHwa8dJoHg3xRZ3jfPp0TX9vG38RPylfb59nH+2a9Y+FWhvongCwFwD9tvs31yzdWeTnn3C7R+FAHa0UUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABXJfEnw7feKvAmoaNp3lfabkxbfNbCgLIrHn6LXW0YoA8N+MHg3w/4b+FsR03SLGC4inhi+0pCvmsMHOXxk5xzzS/CLwX4f8S/CuQ6hpFlNdTTTxi6aBfNToBh8ZGM8VvftAf8AJMX/AOvyH/2anfAH/kmEX/X3N/SgCnpviCb4O+ANI0zX9IvrjyvM33NiqvDGzyuwQsSOcGpL/wCPXh+DRrW+tLDULt5lLywqFBtl3lR5jAkAsRwPTBOOKv8Ax2/5JVf/APXaD/0YKxPgfoOnap8J721vbdZYdQu5VuFyVLKAoAyOR07dM0Aat98T9D1bwCNXm8OanqGj3PmQXkSxIwg27Qd/zdDuGCP0xR8N/Evhd/C2r3PhDw1fW8No4aW2UK0s7kcbSXOenQmtfxjo+naD8JNe07S7SO2tYrCXbFH0Hy9euSfc1w37Nf8AyA9e/wCviP8A9BNAG1Z/HXS9Q1ddItPDmuS6gWaMWyxx79y5yPv8Ywc10Hi/4kQeC/sr3+h6tLBcqu2eJEKh2B/dn5uHAU8dK8g+J1tL4B+Mun+KLWMi2uZEvML0Zgdsyf8AAhyf9+vSPE8kfi/4meFNBgdZtPso/wC27oryrAcQ/r29HoA77RtRk1bSre+ksrqxaUEm3ulCyJgkfMASBnGfxrRowM5xRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFB6UUUAch4u+H2k+Lp7e8mkuLLVLUj7Pf2bhZUwcj6gHn19Ko3HgrxHqVp9g1Tx5fyWTDbIlpZxW8si9MGQZPP05rvaMCgDF8N+GNH8KacLDRrJLeHOWI5aRsdWbqT9fwrZPSlwM5ooA4PTNPTwd491EH5NN8RyCeFs4WO8AO9D6FwdwPfaR6V12o2kl/YSWsd/c2TvjFxbFRImCDxuUjnGOnepr6xtdRs5bS8gSeCQYZHHB7j6EHkHqDzT4YxDGkYZyFAXLsSTj1J5J96APOrn4N6bd66mtz+JvEz6nHjy7n7XFvXHYERcDk8e9d3pdlJptgltJqF3fshJ+0XZUyMCc8lVUcfSr/QVVvbOHULOS1uAxhlG1lVyu4emR2PQjuOKAON0iwTxH8QpfFrfNY2EB0/TT2lbJ82ZfbJKA/wAQB9s95UUMUdvDHDCiRxRgKiKMBVAwABUtABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAHpVLU21BdOnOli2a9A/ci6ZhGWz/FtycfSrtGB6UAeAr8I/H6+Ov+Et+3eHDqH2r7VsMs3l7s/dx5ecY969riOsnQT9oWxXV/JbhC/wBn83B28/e25xnvWnRQB4DJ8JviFL46Hi5r/wAOf2iLlbnYZJvLyMYXHl5xgAda9u0k6odMh/tkWg1Ag+aLNmMXU427uemM5rQxRgUAeBeLPhP4/wDFviYa7d3/AIdhuUCCNYZZtqKv3esZzzk9a9p0L+2v7KiGvfYf7R5En2EuYjzwRvAOcda1MD0ooA8K1X4HaleeP7vUbW9sotAvblZLi3MjiVoy6vIm0Lt+8OOfT0r3NQAAAAMdAO1OwPSjAoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoPQ96KKAPKvi/pfizxTpR8P6N4ba5tfMjmN8b2JAxAPyhGYHv1pfhDpnizwtpK+H9Z8Nm2thJJKL4XsLjJxhdiknt1r1SigDzD4v6d4q8R6GNA0LQPtlvP5cs1215HHsKsTsCMQT0B3ZxVb4Rab4v8K6evh/WfDBgs2mkm+3C+hYJlQQpRSSeV6j16V6xgZzijA9KAOI+JieIr/wAK3Gj+H9E/tJ9QieKWX7VHEIFOMHDkbsgnp0xXE/Bzw7408FXlzYap4b22F86u90t7CfJKhudqsSwOQOOle24HpRQB538YPBVz408JRpp1uJdUtJhLAhZU3g/K6bmIA4w3UfcFVfhD4Q1rw/a3194kh8rVJxDaxqZEk2W8SBUAKkjnHP8AuivTcD0paACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKMD0oooAKMUUUAGBnOKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//Z"
      }
    },
    {
      "section_id": 39,
      "text": "# 5.3 Upper bounds \n\nIn this section we prove Theorems 5.1, 5.2 and 5.4.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 40,
      "text": "### 5.3.1 Deterministic sliding window testers\n\nIn this section, we prove Theorem 5.1: every regular language has a deterministic sliding window tester with constant Hamming gap which uses $\\mathcal{O}(\\log n)$ space. It is based on the path summary algorithm from Section 3.3. In the following, we fix a regular language $L$ and an rDFA $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ for $L$. By Lemma 3.19 we can assume that every nontransient SCC of $\\mathcal{B}$ has the same period $g \\geqslant 1$.\n\nFor a state $q \\in Q$ we define $\\operatorname{Acc}(q)=\\left\\{n \\in \\mathbb{N} \\mid \\exists w \\in \\Sigma^{n}: w \\cdot q \\in F\\right\\}$. The following lemma is the main tool to prove correctness of our sliding window testers. It states that if a word of length $n$ is accepted from state $p$ and $\\rho$ is any internal run (see Section 3.3 and page 20) of length at most $n$ starting from state $p$, then after removing a bounded length run at the end of $\\rho, \\rho$ can be extended to an accepting run of length $n$. Formally, a run $\\pi t$-simulates a run $\\rho$ if one can factorize $\\rho=\\rho_{1} \\rho_{2}$ and $\\pi=\\pi^{\\prime} \\rho_{2}$ where $\\left|\\rho_{1}\\right| \\leqslant t$ for runs $\\rho_{1}, \\rho_{2}$, and $\\pi^{\\prime}$; see also Figure 6. Note that this implies that $\\rho$ and $\\pi$ start in the same state. Also note that runs go from right to left (we work with an rDFA), so $\\rho_{1}$ (resp., $\\pi^{\\prime}$ ) is the final part of $\\rho$ (resp., $\\pi$ ).\n\n![img-5.jpeg](img-5.jpeg)\n\nFigure 6. The run $\\pi=\\pi^{\\prime} \\rho_{2} t$-simulates the run $\\rho=\\rho_{1} \\rho_{2}$. We have $\\left|\\rho_{1}\\right| \\leqslant t$.\n\nLEMMA 5.9. There exists a number $t \\in \\mathbb{N}$ (which only depends on $\\mathcal{B}$ ) such that for every internal run $\\rho$ starting from a state $p$ and every $n \\in \\operatorname{Acc}(p)$ with $n \\geqslant|\\rho|$, there exists an accepting run $\\pi$ of length $n$ which $t$-simulates $\\rho$.\n\nNote that the run $\\pi$ in this lemma is not necessarily internal.\nBased on Lemma 5.9 we can prove Theorem 5.1. Afterwards we prove Lemma 5.9.\nPROOF OF THEOREM 5.1. Let $t$ be the constant from Lemma 5.9. We present a deterministic sliding window tester with constant Hamming gap $t$ which uses $O(\\log n)$ space. Let $n \\in \\mathbb{N}$ be the window size. By Lemma 3.5 we can maintain the set of all path summaries $\\mathrm{PS}_{\\mathcal{B}}(w)=\\left\\{\\mathrm{ps}\\left(\\pi_{w, q}\\right) \\mid\\right.$ $q \\in Q\\}$ for the active window $w \\in \\Sigma^{n}$, using $O(\\log n)$ bits. In fact, the path summary algorithm works for variable-size windows but we do not need this here.\n\nIt remains to define the acceptance condition. Consider the SCC-factorization of $\\pi_{w, q_{0}}$, say\n\n$$\n\\pi_{w, q_{0}}=\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{1} \\pi_{1}\n$$\n\nand its path summary $\\left(\\ell_{m}, q_{m}\\right) \\cdots\\left(\\ell_{1}, q_{1}\\right)$. The algorithm accepts if and only if this path summary is accepting, i.e., $\\ell_{m}=\\left|\\pi_{m}\\right| \\in \\operatorname{Acc}\\left(q_{m}\\right)$. If $w \\in L$ then clearly $\\left|\\pi_{m}\\right| \\in \\operatorname{Acc}\\left(q_{m}\\right)$. On the other hand, if $\\left|\\pi_{m}\\right| \\in \\operatorname{Acc}\\left(q_{m}\\right)$ then the internal run $\\pi_{m}$ can be $t$-simulated by an accepting run $\\pi_{m}^{\\prime}$ of equal length by Lemma 5.9. The run $\\pi_{m}^{\\prime} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{1} \\pi_{1}$ is accepting and witnesses that $\\operatorname{pdist}(w, L) \\leqslant t$. We get $\\operatorname{dist}(w, L) \\leqslant \\operatorname{pdist}(w, L) \\leqslant t$.\n\nTo prove Lemma 5.9 we need to analyze the sets $\\operatorname{Acc}(q)$ first. For $a \\in \\mathbb{N}$ and $X \\subseteq \\mathbb{N}$ we use the standard notation $X+a=\\{a+x \\mid x \\in X\\}$. A set $X \\subseteq \\mathbb{N}$ is eventually d-periodic, where $d \\geqslant 1$ is an integer, if there exists a threshold $t \\in \\mathbb{N}$ such that for all $x \\geqslant t$ we have $x \\in X$ if and only if $x+d \\in X$. If $X$ is eventually $d$-periodic for some $d \\geqslant 1$, then $X$ is eventually periodic.\n\nLEMMA 5.10. For every $q \\in Q$ the set $\\operatorname{Acc}(q)$ is eventually $g$-periodic.\nPROOF. It suffices to show that for all $0 \\leqslant r \\leqslant g-1$ the set $S_{r}=\\{i \\in \\mathbb{N} \\mid r+i \\cdot g \\in \\operatorname{Acc}(q)\\}$ is either finite or co-finite. Consider a remainder $0 \\leqslant r \\leqslant g-1$ where $S_{r}$ is infinite. We need to show that $S_{r}$ is indeed co-finite. Let $i \\in S_{r}$ with $i \\geqslant|Q|$, i.e., there exists an accepting run $\\pi$ from $q$ of length $r+i \\cdot g$. Since $\\pi$ has length at least $|Q|$, it must traverse a state $p$ in a nontransient SCC $C$. Choose $j_{0}$ such that $j_{0} \\cdot g \\geqslant m(C)$ where $m(C)$ is the reachability constant from Lemma 3.18. By Lemma 3.18 for all $j \\geqslant j_{0}$ there exists a cycle from $p$ to $p$ of length $j \\cdot g$. Therefore, we can\n\nextend $\\pi$ to a longer accepting run by $j \\cdot g$ symbols for any $j \\geqslant j_{0}$. This proves that $x \\in S_{r}$ for every $x \\geqslant i+j_{0}$ and that $S_{r}$ is co-finite.\n\nTwo sets $X, Y \\subseteq \\mathbb{N}$ are equal up to a threshold $t \\in \\mathbb{N}$, in symbol $X={ }_{t} Y$, if for all $x \\geqslant t: x \\in X$ if and only if $x \\in Y$. Two sets $X, Y \\subseteq \\mathbb{N}$ are almost equal if they are equal up to some threshold $t \\in \\mathbb{N}$.\n\nLEMMA 5.11. A set $X \\subseteq \\mathbb{N}$ is eventually d-periodic if and only if $X$ and $X+d$ are almost equal.\nPROOF. Let $t \\in \\mathbb{N}$ be such that for all $x \\geqslant t$ we have $x \\in X$ if and only if $x+d \\in X$. Then, $X$ and $X+d$ are equal up to threshold $t+d$. Conversely, if $X={ }_{t} X+d$, then for all $x \\geqslant t$ we have $x+d \\in X$ if and only if $x+d \\in X+d$, which is true if and only if $x \\in X$.\n\nIf the graph $G=(V, E)$ is strongly connected with $E \\neq \\emptyset$ and finite period $g$, and $V_{0}, \\ldots, V_{g-1}$ satisfy the properties from Lemma 3.18, then we define the shift from $u \\in V_{i}$ to $v \\in V_{j}$ by\n\n$$\n\\operatorname{shift}(u, v)=(j-i) \\bmod g \\in\\{0, \\ldots, g-1\\}\n$$\n\nNotice that $\\operatorname{shift}(u, v)$ could be defined without referring to the partition $\\bigcup_{i=0}^{g-1} V_{i}$ since the length of any path from $u$ to $v$ is congruent to $\\operatorname{shift}(u, v)$ modulo $g$ by Lemma 3.18. Also, note that $\\operatorname{shift}(u, v)+\\operatorname{shift}(v, u) \\equiv 0(\\bmod g)$.\n\nLEMMA 5.12. Let $C$ be a nontransient SCC in $\\mathcal{B}, p, q \\in C$ and $s=\\operatorname{shift}(p, q)$. Then, $\\operatorname{Acc}(p)$ and $\\operatorname{Acc}(q)+s$ are almost equal.\n\nPROOF. Let $k \\in \\mathbb{N}$ such that $k \\cdot g \\geqslant m(C)$ where $m(C)$ is the constant from Lemma 3.18. By Lemma 3.18 there exists a run from $p$ to $q$ of length $s+k \\cdot g$, and a run from $q$ to $p$ of length $(k+1) \\cdot g-s$ (the latter number is congruent to $\\operatorname{shift}(q, p)$ modulo $g$ ). By prolonging accepting runs we obtain\n\n$$\n\\operatorname{Acc}(q)+s+k \\cdot g \\subseteq \\operatorname{Acc}(p) \\text { and } \\operatorname{Acc}(p)+(k+1) \\cdot g-s \\subseteq \\operatorname{Acc}(q)\n$$\n\nAdding $s+k \\cdot g$ to both sides of the last inclusion yields\n\n$$\n\\operatorname{Acc}(p)+(2 k+1) \\cdot g \\subseteq \\operatorname{Acc}(q)+s+k \\cdot g \\subseteq \\operatorname{Acc}(p)\n$$\n\nBy Lemma 5.10 and Lemma 5.11 the three sets above are almost equal. Also, $\\operatorname{Acc}(q)+s+k \\cdot g$ is almost equal to $\\operatorname{Acc}(q)+s$ by Lemma 5.10 and Lemma 5.11. Since almost equality is a transitive relation, this proves the statement.\n\nCOROLLARY 5.13. There exists a threshold $t \\in \\mathbb{N}$ such that\n(i) $\\operatorname{Acc}(q)=_{t} \\operatorname{Acc}(q)+g$ for all $q \\in Q$, and\n(ii) $\\operatorname{Acc}(p)=_{t} \\operatorname{Acc}(q)+\\operatorname{shift}(p, q)$ for all nontransient SCCs $C$ and all $p, q \\in C$.\n\nLet us fix the threshold $t$ from Corollary 5.13 in the following. We can now prove Lemma 5.9.\nPROOF OF LEMMA 5.9. Let $\\rho$ be an internal run starting from $p$ with $|\\rho| \\leqslant n \\in \\operatorname{Acc}(p)$. We have to find an accepting run $\\pi$ of length $n$ starting from $p$ and factorizations $\\rho=\\rho_{1} \\rho_{2}$ and $\\pi=\\pi^{\\prime} \\rho_{2}$ with $\\left|\\rho_{1}\\right| \\leqslant t$.\n\nIf $|\\rho| \\leqslant t$, then we can choose for $\\pi$ any accepting run from $p$ of length $n \\in \\operatorname{Acc}(p)$. Otherwise, if $|\\rho|>t$, then the internal run $\\rho$ is nonempty, which implies that the SCC $C$ containing $p$ is nontransient. Moreover, writing $\\rho=\\rho_{1} \\rho_{2}$ where $\\left|\\rho_{1}\\right|=t$, it is the case that $\\rho_{2}$ leads from $p$ to some state $q$ of the same SCC. Set $s:=\\operatorname{shift}(q, p)$, which satisfies $s+\\left|\\rho_{2}\\right| \\equiv 0$ $(\\bmod g)$ by the properties in Lemma 3.18 (see also the discussion before Lemma 5.12). Since $\\operatorname{Acc}(q)={ }_{t} \\operatorname{Acc}(p)+s$ by Corollary 5.13(ii), $n>t$ and $n \\in \\operatorname{Acc}(p)$, we have $n+s \\in \\operatorname{Acc}(q)$. Finally, since $n+s \\equiv n-\\left|\\rho_{2}\\right|(\\bmod g)$ and $n-\\left|\\rho_{2}\\right|=n-|\\rho|+t \\geqslant t$, we know $n-\\left|\\rho_{2}\\right| \\in \\operatorname{Acc}(q)$ by Corollary 5.13(i). This yields an accepting run $\\pi^{\\prime}$ from $q$ of length $n-\\left|\\rho_{2}\\right|$. Then, $\\rho$ is $t$-simulated by $\\pi=\\pi^{\\prime} \\rho_{2}$.",
      "tables": {},
      "images": {
        "img-5.jpeg": "data:image/jpeg;base64,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PcAjjPY47CvD5/h74wtr5rOTwzqnm7tmY7ZnTPs4BUj3zivon4OfDy58FaNdXOp4TUr8qXiVg3koudq7hwTySccdPSgD02iiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACkY4xQ36Vx/iTU7vV9UHhPRbh4bl0Emo3sY/wCPOAnGAf8Ano/IUdhubsKALOo+ONOtdQk06wt77WNQiOJbbTofM8o+kjkhEPsSD7VB/b/jGc/6P4KWIHobzVY0x7kRq9b+jaRYaFpsWn6bax29rEPlRB1Pck9ST3J5NaFAHFTeHvEviVDB4l1K1tdMb/W6dpW/Mw/uvO2G29iFC59a6+1toLSBILaNIoY1CpGgwqgDAAHYYqaigAowKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACjA9OlFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFIax/E/iOz8LaO2o3gdxvWKKGPG+aRjhUUHqT/IGqviXxTHoccdpbR/btaueLPT42G+Q9Nzf3UHUscAAUAaGra/pWgwCfVtRtrKNvumaQLu9lBOSfoKwx8RNImwbCz1rUAejWulXDKf+BFAKn8PeEYtPnOq6s66l4gl5mvZFz5f+xED9xBnAA69+emtrmuad4d0x9Q1O5EFuhC5wWZmPRVABJJ9BQBzsuueKtbTydF0CXSkfg3+rsgKDuVhQszH03ED1rc8O+HrXw7YvBA8k88zmW5upzuluJT1dj+mOgArJt/H9hJqtnp9/p2q6TLfHbaPqFuESZuPlBDHDYPRsHnpXVg4HPHOOtAD6KQUtABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABSMcUtNbt296APH/iH8cYvC+ry6PotlFe3kB2zzTORFG3dQByxHfkYql4M/aAi1XUEsvElglm0mRHcWoZkLdgU5bnoMZyTXhXi+zvNP8YatbXwYXKXcu8tn5ssTu985zn3rP0yzutR1S2s7JGe6nlWOILnO4nAoA9i8Yr8RPiL4jt7/AEnw/qNrp1g4bT1nAhO4EHzDvIBJIB9AABzyT6v8OtNvrC2nOp+Fn0vUXVTNfTXyXcl23cs4JYeuDwM8V3K9ME5I707AoAb0/CvM/FhOu/GPwnoDfPa6fFJqs6A8FhkRk+4ZR/30a9NavINH0n/hL/i34v1RNRv7H+zTDYW89lKEYEKfMU5BUjcucEelAGj8XD9ruvBuj2/zX1xrkU8YA5CRg7246AbgT9Kd8Q21yz1LQLr+2pI7ObXrO2jtLZDHuRiS/mtuy+cYwMLjsc102leC7PT9cbW7y9vdV1Ux+Ul1espMSf3UVVVVz3wOefU1znxPuZLn+wLW007VbuW01u1vLj7Np80qLEm4sQwUqeo4BJ9qAPSVpags7mO8tUuIllVHGQJomjb8VYBh9CKnoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKQilooA4/xd8NfDXjWRZ9UtGW7UbRdW77JMeh4Ib8Qcdqh8JfC3wv4NuvtWm20kt7tIFzcuHkUHrt4AXjjIArtqKAGrjnH5elOoooAQ1VsdLsNNa4ays4LdrmUzTGKMKZJD1ZsdSfU1booAKMCiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/2Q=="
      }
    },
    {
      "section_id": 41,
      "text": "# 5.3.2 Sliding window testers with two-sided error \n\nIn this section, we will prove Theorem 5.2. We will construct for every regular language a randomized sliding window tester with two-sided error and Hamming gap $\\gamma(n)$ that uses $\\mathcal{O}(\\log (n / \\gamma(n)))$ bits assuming the window size $n$ satisfies $\\gamma(n) \\geqslant c$ for a suitably chosen constant. We still assume that the regular language $L$ is recognized by an rDFA $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ whose nontransient SCCs have uniform period $g \\geqslant 1$. Furthermore, we again use the constant $t$ from Corollary 5.13.\n\nWe will set the constant $c$ from Theorem 5.2 to $c=4(t+1)$. Let us fix a window size $n$ such that $\\gamma(n) \\geqslant 4(t+1)$. We define the parameters $h=n-t$ and $\\ell=n-\\gamma(n)+t+1$, which satisfy\n\n$$\n\\begin{aligned}\n\\frac{\\ell}{h} & =\\frac{n-\\gamma(n)+t+1}{n-t} \\leqslant \\frac{n-\\gamma(n)+\\frac{1}{4} \\gamma(n)}{n-\\frac{1}{4} \\gamma(n)} \\\\\n& =\\frac{n-\\frac{1}{4} \\gamma(n)-\\frac{1}{2} \\gamma(n)}{n-\\frac{1}{4} \\gamma(n)} \\leqslant 1-\\frac{\\gamma(n)}{2 n}\n\\end{aligned}\n$$\n\nLet $\\mathcal{Z}=\\left(C,\\{\\mathrm{inc}\\}, c_{0}, \\rho, F\\right)$ be the $(h, \\ell)$-counter with error probability $1 /(3|Q|)$ from Proposition 4.6, which uses $\\mathcal{O}(\\log \\log |Q|+\\log (n / \\gamma(n)))=\\mathcal{O}(\\log (n / \\gamma(n)))$ space by (14) (as usual, we consider $|Q|$ as a constant). The counter $\\mathcal{Z}$ is used to define so-called compact summaries of runs.\n\nA compact summary $\\kappa=\\left(q_{m}, r_{m}, c_{m}\\right) \\cdots\\left(q_{2}, r_{2}, c_{2}\\right)\\left(q_{1}, r_{1}, c_{1}\\right)$ is a sequence of triples, where each triple $\\left(q_{i}, r_{i}, c_{i}\\right)$ consists of a state $q_{i} \\in Q$, a remainder $0 \\leqslant r_{i} \\leqslant g-1$, and a state $c_{i} \\in C$ of the counter $\\mathcal{Z}$. The state $c_{1}$ of the counter is always its initial state $c_{0}$ (and hence low) and $r_{1}=0$. We say that $\\kappa$ represents a run $\\pi$ if the SCC-factorization of $\\pi$ has the form $\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{1} \\pi_{1}$, and the following properties hold for all $1 \\leqslant i \\leqslant m$ :\n(C1) $\\pi_{i}$ starts in $q_{i}$;\n\n![img-6.jpeg](img-6.jpeg)\n\nFigure 7. A compact summary of a run $\\pi$.\n(C2) $r_{i}=\\left|\\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}\\right| \\bmod g$;\n(C3) if $\\left|\\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}\\right| \\leqslant n-\\gamma(n)+t+1$ then $c_{i}$ is a low state;\n(C4) if $\\left|\\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}\\right| \\geqslant n-t$ then $c_{i}$ is a high state.\nNote that $\\kappa$ does not restrict $\\pi_{m}$ except that the latter must be an internal run starting in $q_{m}$.\nThe idea of a compact summary is visualized in Figure 7. If $m>|Q|$ then the above compact summary cannot represent a run. Therefore, we can assume that $m \\leqslant|Q|$. For every triple $\\left(q_{i}, r_{i}, c_{i}\\right)$, the entries $q_{i}$ and $r_{i}$ only depend on the rDFA $\\mathcal{B}$, and hence can be stored with $O(1)$ bits. Each state $c_{i}$ of the probabilistic counter $\\mathcal{Z}$ needs $O(\\log (n / \\gamma(n)))$ bits. Hence, a compact summary can be stored in $O(\\log (n / \\gamma(n)))$ bits. In contrast to the deterministic sliding window tester, we maintain a set of compact summaries which represent all runs of $\\mathcal{B}$ on the complete stream read so far (not only on the active window) with high probability. ${ }^{8}$\n\nPROPOSITION 5.14. For a given input stream $w \\in \\Sigma^{*}$, we can maintain a set of compact summaries $S=\\left\\{\\kappa_{w}(q) \\mid q \\in Q\\right\\}$ such that for all $q \\in Q$,\n\n- $\\kappa_{w}(q)$ starts in $q$, and\n- $\\operatorname{Pr}\\left[\\operatorname{run} \\pi_{w, q}\\right.$ is represented by $\\left.\\kappa_{w}(q)\\right] \\geqslant 2 / 3$.\n\nPROOF. We maintain for the input word $w \\in \\Sigma^{*}$ a set of random compact summaries $S=$ $\\left\\{\\kappa_{w}(q) \\mid q \\in Q\\right\\}$ as follows.\n\nFor $w=\\varepsilon$, we initialize $S=\\left\\{\\kappa_{\\varepsilon}(q) \\mid q \\in Q\\right\\}$ where $\\kappa_{\\varepsilon}(q)=\\left(q, 0, c_{0}\\right)$ for $q \\in Q$. If $a \\in \\Sigma$ is the next input symbol in the stream, then $S$ is updated to the new set $S^{\\prime}$ of compact summaries by iterating over all transitions $q \\stackrel{a}{\\leftarrow} p$ in $\\mathcal{B}$ and prolonging the compact summary starting in $q$ by that transition. To prolong a compact summary\n\n$$\n\\kappa_{w}(q)=\\left(q_{m}, r_{m}, c_{m}\\right) \\cdots\\left(q_{1}, r_{1}, c_{1}\\right)\n$$\n\nwe proceed similarly to Algorithm 1.\nIf $p$ and $q=q_{1}$ are not in the same SCC then the new compact summary $\\kappa_{w a}(p)$ is\n\n$$\n\\left(q_{m},\\left(r_{m}+1\\right) \\bmod g, c_{m}^{\\prime}\\right) \\cdots\\left(q_{1},\\left(r_{1}+1\\right) \\bmod g, c_{1}^{\\prime}\\right)\\left(p, 0, c_{0}\\right)\n$$\n\nwhere every counter state $c_{i}^{\\prime}$ is chosen with probability $\\rho\\left(c_{i}\\right.$, inc, $\\left.c_{i}^{\\prime}\\right)$.\n\nIf $p$ and $q=q_{1}$ belong to the same SCC, then $\\kappa_{w a}(p)$ is\n\n$$\n\\left(q_{m},\\left(r_{m}+1\\right) \\bmod g, c_{m}^{\\prime}\\right) \\cdots\\left(q_{2},\\left(r_{2}+1\\right) \\bmod g, c_{2}^{\\prime}\\right)\\left(p, r_{1}, c_{1}\\right)\n$$\n\nwhere every counter state $c_{i}^{\\prime}$ with $2 \\leqslant i \\leqslant m$ is chosen with probability $\\rho\\left(c_{i}\\right.$, inc, $\\left.c_{i}^{\\prime}\\right)$.\nNote that the right-most triple of $\\kappa_{w}(q)$ will be $\\left(q, 0, c_{0}\\right)$ with probability 1.\nFinally we claim that for every $q \\in Q$, the compact summary $\\kappa_{w}(q)$ from (15) computed by the algorithm represents $\\pi_{w, q}$ with probability $2 / 3$. Properties (C1) and (C2) are satisfied by construction. Furthermore, since the length of $\\kappa_{w}(q)$ is bounded by $|Q|$ and each instance of $\\mathcal{Z}$ has error probability $1 /(3|Q|)$ the probability that property (C3) or (C4) is violated for some $i$ is at most $1 / 3$ by the union bound.\n\nFor the randomized algorithm from the proof of Proposition 5.14 the same comment applies that was made after the proof of Lemma 4.8: the increments of the probabilistic counters do not have to be independent. Hence, in each step, only the random bits for incrementing a single $(\\ell, h)$-counter (with the above parameters $\\ell$ and $h$ ) are needed. These random bits can be used for all counters that have to be incremented.\n\nIt remains to define an acceptance condition on compact summaries. For every $q \\in Q$ we define\n\n$$\n\\operatorname{Acc}_{\\bmod }(q)=\\{\\ell \\bmod g \\mid \\ell \\in \\operatorname{Acc}(q) \\text { and } \\ell \\geqslant t\\}\n$$\n\nLet $\\kappa=\\left(q_{m}, r_{m}, c_{m}\\right) \\cdots\\left(q_{1}, r_{1}, c_{1}\\right)$ be a compact summary. Since $c_{1}$ is the low initial state of the probabilistic counter, there exists a maximal index $i \\in\\{1, \\ldots, m\\}$ such that $c_{i}$ is low. We say that $\\kappa$ is accepting if $\\left(n-r_{i}\\right) \\bmod g \\in \\operatorname{Acc}_{\\bmod }\\left(q_{i}\\right)$.\n\nPROPOSITION 5.15. Let $w \\in \\Sigma^{\\times}$with $|w| \\geqslant n$ and let $\\kappa$ be a compact summary which represents $\\pi_{w, q_{0}}$.\n(i) If last ${ }_{n}(w) \\in L$, then $\\kappa$ is accepting.\n(ii) If $\\kappa$ is accepting, then $\\operatorname{pdist}\\left(\\operatorname{last}_{n}(w), L\\right) \\leqslant \\gamma(n)$.\n\nPROOF. Consider the SCC-factorization of $\\pi=\\pi_{w, q_{0}}=\\pi_{m} \\tau_{m-1} \\cdots \\tau_{1} \\pi_{1}$ and a compact summary $\\kappa=\\left(q_{m}, r_{m}, c_{m}\\right) \\cdots\\left(q_{1}, r_{1}, c_{1}\\right)$ representing $\\pi$. Thus, $q_{1}=q_{0}$ and $c_{1}=c_{0}$. Consider the maximal index $1 \\leqslant i \\leqslant m$ where $c_{i}$ is low, which means that $\\left|\\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}\\right|<n-t$ by (C4). The run of $\\mathcal{B}$ on last $_{n}(w)$ has the form $\\pi_{k}^{\\prime} \\tau_{k-1} \\pi_{k-1} \\cdots \\tau_{1} \\pi_{1}$ for some suffix $\\pi_{k}^{\\prime}$ of $\\pi_{k}$ and $k \\geqslant i$. We have $\\left|\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}\\right|=n-\\left|\\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}\\right|>t$. By (C2) we know that\n\n$$\nr_{i}=\\left|\\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}\\right| \\bmod g=n-\\left|\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}\\right| \\bmod g\n$$\n\nFor (i) assume that last ${ }_{n}(w) \\in L$. Thus, $\\pi_{k}^{\\prime} \\tau_{k-1} \\pi_{k-1} \\cdots \\tau_{1} \\pi_{1}$ is an accepting run starting in $q_{0}$. By (C1) the run $\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}$ starts in $q_{i}$. Hence, $\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}$ is an accepting run from $q_{i}$ of length at\n\nleast $t$. By definition of $\\operatorname{Acc}_{\\bmod }\\left(q_{i}\\right)$ we have\n\n$$\nn-r_{i} \\bmod g=\\left|\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}\\right| \\bmod g \\in \\operatorname{Acc}_{\\bmod }\\left(q_{i}\\right)\n$$\n\nand therefore $\\kappa$ is accepting.\nFor (ii) assume that $\\kappa$ is accepting, i.e.\n\n$$\n\\left(n-r_{i}\\right) \\bmod g=\\left|\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}\\right| \\bmod g \\in \\operatorname{Acc}_{\\bmod }\\left(q_{i}\\right)\n$$\n\nRecall that $\\left|\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}\\right|>t$. By definition of $\\operatorname{Acc}_{\\bmod }\\left(q_{i}\\right)$ there exists an accepting run from $q_{i}$ whose length is congruent to $\\left|\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}\\right| \\bmod g$ and at least $t$. By point (i) from Corollary 5.13 we derive that $\\left|\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}\\right| \\in \\operatorname{Acc}\\left(q_{i}\\right)$. We show that $\\left|\\pi_{i} \\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}\\right| \\geqslant n-\\gamma(n)+t$ by a case distinction. If $i=m$, then clearly $\\left|\\pi_{i} \\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}\\right|=|w| \\geqslant n \\geqslant n-\\gamma(n)+t$. The latter inequality follows from our assumption $t+1 \\leqslant \\gamma(n) / 4$. If $i<m$, then $c_{i+1}$ is high by maximality of $i$, which implies $\\left|\\tau_{i} \\pi_{i} \\cdots \\tau_{1} \\pi_{1}\\right|>n-\\gamma(n)+t+1$ by (C3). Since $\\tau_{i}$ has length one, we have $\\left|\\pi_{i} \\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}\\right|>n-\\gamma(n)+t$.\n\nSince $\\left|\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}\\right| \\in \\operatorname{Acc}\\left(q_{i}\\right)$, we can apply Lemma 5.9 and obtain an accepting run $\\rho$ of length $\\left|\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}\\right| \\in \\operatorname{Acc}\\left(q_{i}\\right)$ starting in $q_{i}$ which $t$-simulates the internal run $\\pi_{i}$. The prefix distance between $\\rho$ and $\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i}$ (which we define as the prefix distance between the words read along the two runs) is at most\n\n$$\n\\left|\\pi_{k}^{\\prime} \\tau_{k-1} \\cdots \\pi_{i+1} \\tau_{i}\\right|+t=n-\\left|\\pi_{i} \\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}\\right|+t \\leqslant n-n+\\gamma(n)=\\gamma(n)\n$$\n\nHence, the prefix distance from the accepting run $\\rho \\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{1} \\pi_{1}$ to the run $\\pi_{k}^{\\prime} \\tau_{k-1} \\pi_{k-1} \\cdots \\tau_{1} \\pi_{1}$ is also at most $\\gamma(n)$. This implies $\\operatorname{pdist}\\left(\\operatorname{last}_{n}(w), L\\right) \\leqslant \\gamma(n)$.\n\nWe are now ready to prove Theorem 5.2.\nPROOF OF THEOREM 5.2. Assume that the window size is such that $\\gamma(n) \\geqslant 4(t+1)$ (recall that $4(t+1)$ is our constant $c$ from Theorem 5.2). We use the algorithm from Proposition 5.14, which is initialized by reading the initial window $\\square^{n}$. It maintains a compact summary which represents $\\pi_{\\alpha ; q_{0}}$ with probability at least $2 / 3$ for the read stream prefix $w$. The algorithm accepts if that compact summary is accepting. From Proposition 5.15 we get:\n\n- If last ${ }_{n}(w) \\in L$, then the algorithm accepts with probability at least $2 / 3$.\n- If $\\operatorname{pdist}\\left(\\operatorname{last}_{n}(w), L\\right)>\\gamma(n)$, then the algorithm rejects with probability at least $2 / 3$.\n\nThis concludes the proof of Theorem 5.2.\nFrom Theorem 5.2 we can easily deduce Corollary 5.3: Let $\\gamma(n)=\\epsilon n$ for some $0<\\epsilon<1$ and let $c$ be the constant from Theorem 5.2. Then the condition $\\gamma(n) \\geqslant c$ becomes $n \\geqslant c / \\epsilon$. Hence, for a window size $n \\geqslant c / \\epsilon$, Theorem 5.2 yields a randomized sliding window tester with two-sided error that uses space $O(\\log (n / \\gamma(n))=O(\\log (1 / \\epsilon))$. For $n<c / \\epsilon$ we can use a trivial sliding window tester that stores the window content explicitly using $O(1 / \\epsilon)$ bits.",
      "tables": {},
      "images": {
        "img-6.jpeg": "data:image/jpeg;base64,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uRiWFrmWRT1BwHY7ScnJGM9+gp2geD9D8MWk9ppFo8NtP/rIZLiSZD1zgOzAZyc46988UAZN7fWJ+Ds97vQ2b6GSDngqYcAfrj1zXmGu2dxafATwZLeI/l2uoQXFwGXpExkwTnth1/OvVP8AhWXhTIU6c5thJ5oszcy/Zg+c58nds69sY9q6O90uy1HTpdPvLaKazlTY8DrlCvpj/OKAOB+N13bL8JtSDOhNw8C2+DnefNVuMdflVj9K7jQcf8I/puDn/RYuf+Aiuet/hZ4PgtZ7b+y2khmj8orLcyvsTIJVCWJQZA6YPFdBo2iWPh/TksNNSWO1Q/Ikk7y7egwC5JA46ZwKAJ9SuILXS7q5upBFbQwvJLLn7iBSS34DmvH/AAfomtat8OV8L2F9pceiXJk/00Tbrw2ruWw0IyquwJHL8A4xkV2HxG1a+00aNH50tpol1cmPVL2GPc0MWMgZwdobkFu3415/4o8MfD2fSPJ8Cos/iQun2L+yrqSZlbcMsxBYKoGSScYoA9u02xt9J0y10+0TZbWsKQxr3CqAB+PArgbyKS4/aI09ovuW2gM8pHo0rgA/iRXdpK2naOkt9KZJIYF851UsXYDnAHJJPQdTnisrw1pEseoanr1/EYr7U2TERIJggQYjQ/7RBLNjjcxHbJAOkB7UtGKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigApCM0UUABXPegDHeiigBaKKKACiiigAooooAKKKKAG7aUDHeiigBaQjIoooAAMHrS0UUAFFFFABRRRQAUUUUAJj04pvljtgZ9BRRQAu33pQMGiigBaKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//2Q=="
      }
    },
    {
      "section_id": 42,
      "text": "# 5.3.3 Sliding window testers with one-sided error \n\nIn the following, we turn to sliding window testers with one-sided error and prove Theorem 5.4, i.e., we present a false-biased sliding window tester for languages in $\\cup$ (Triv, SF) with constant Hamming gap using $O(\\log \\log n)$ space. By the following lemma, it suffices to consider the cases $L \\in$ Triv and $L \\in \\mathbf{S F}$.\n\nLEMMA 5.16. Let $\\mathcal{P}_{1}$ and $\\mathcal{P}_{2}$ be randomized false-biased sliding window testers for $L_{1}$ and $L_{2}$, respectively, for window size $n$ with Hamming gap $\\gamma(n)$. Then, there exists a randomized false-biased sliding window tester for $L_{1} \\cup L_{2}$ for window size $n$ with Hamming gap $\\gamma(n)$ using space $O\\left(s\\left(\\mathcal{P}_{1}\\right)+s\\left(\\mathcal{P}_{2}\\right)\\right)$.\n\nPROOF. First we reduce the error probability of $\\mathcal{P}_{i}(i \\in\\{1,2\\})$ from $1 / 3$ to $1 / 9$ by running 2 independent and parallel copies of $\\mathcal{P}_{i}$ and reject if and only if one of the copies rejects. Then, we run both algorithms in parallel and accept if and only if one of them accepts. If the window belongs to $L_{1} \\cup L_{2}$ then either $\\mathcal{P}_{1}$ or $\\mathcal{P}_{2}$ accepts with probability 1 . If the window $w$ satisfies $\\operatorname{dist}\\left(w, L_{1} \\cup L_{2}\\right)=\\min \\left(\\operatorname{dist}\\left(w, L_{1}\\right), \\operatorname{dist}\\left(w, L_{2}\\right)\\right)>\\gamma(n)$ then $\\operatorname{dist}\\left(w, L_{i}\\right)>\\gamma(n)$ for both $i \\in\\{1,2\\}$. Hence, both algorithms falsely accept with probability at most $1 / 9$ and the combined algorithm falsely accepts with probability at most $1 / 9+1 / 9 \\leqslant 1 / 3$.\n\nThe case of a regular trivial language is covered by the following result:\nTHEOREM 5.17. Let $L$ be a language and $\\gamma(n)$ be a function. The following statements are equivalent:\n\n- $L$ is $(\\gamma(n)+c)$-trivial for some number $c \\in \\mathbb{N}$.\n- There is a deterministic sliding window tester with Hamming gap $\\gamma(n)+c^{\\prime}$ for $L$ which uses constant space for some number $c^{\\prime} \\in \\mathbb{N}$.\n\nPROOF. Assume first that $L$ is $(\\gamma(n)+c)$-trivial. Let $n \\in \\mathbb{N}$ be a window size. If $L \\cap \\Sigma^{n}=\\emptyset$, then the algorithm always rejects, which is obviously correct since any active window of size $n$ has infinite Hamming distance to $L$. On the other hand, if $L \\cap \\Sigma^{n} \\neq \\emptyset$ then the Hamming distance between an arbitrary active window of size $n$ and $L$ is at most $\\gamma(n)+c$. Hence, the algorithm that always accepts achieves a Hamming gap of $\\gamma(n)+c$.\n\nWe now show the converse statement. ${ }^{9}$ For each window size $n \\in \\mathbb{N}$ let $\\mathcal{P}_{n}$ be a deterministic sliding window tester for $L$ with Hamming gap $\\gamma(n)+c^{\\prime}$ such that the number of states of $\\mathcal{P}_{n}$ is constant. Assume that $\\mathcal{P}_{n}$ has at most $s$ states for every $n$. Let $N \\subseteq \\mathbb{N}$ be the set of all $n$ such that $L \\cap \\Sigma^{n} \\neq \\emptyset$. Note that every $\\mathcal{P}_{n}$ with $n \\in N$ accepts a nonempty language. Every $\\mathcal{P}_{n}$ is a DFA with a most $s$ states over the fixed alphabet $\\Sigma$. The number of pairwise nonisomorphic DFAs with at most $s$ states over the input alphabet $\\Sigma$ is bounded by a fixed\n\n[^0]\n[^0]:    9 The converse statement is not needed for the proof of Theorem 5.4 but we think it is of independent interest.\n\nconstant $d$. Hence, at most $d$ nonisomorphic DFAs can appear in the list $\\left(\\mathcal{P}_{n}\\right)_{n \\in N}$. We therefore can choose numbers $n_{1}<n_{2}<\\cdots<n_{e}$ from $N$ with $e \\leqslant d$ such that for every $n \\in N$ there exists a unique $i \\in\\{1,2, \\ldots, e\\}$ with $n_{i} \\leqslant n$ and $\\mathcal{P}_{n}=\\mathcal{P}_{n_{i}}$ (here and in the following we do not distinguish between isomorphic DFAs). Let us choose for every $1 \\leqslant i \\leqslant e$ some word $u_{i} \\in L$ of length $n_{i}$. Now, take any $n \\in N$ and assume that $\\mathcal{P}_{n}=\\mathcal{P}_{n_{i}}$ where $n_{i} \\leqslant n$. Consider any word $u \\in \\Sigma^{*} u_{i}$. Since last $_{n_{i}}(u)=u_{i} \\in L, \\mathcal{P}_{n_{i}}$ has to accept $u$. Hence, $\\mathcal{P}_{n}$ accepts all words from $\\Sigma^{*} u_{i}$. In particular, for every word $x$ of length $n-n_{i}, \\mathcal{P}_{n}$ accepts $x u_{i}$. This implies that $\\operatorname{dist}\\left(x u_{i}, L\\right) \\leqslant \\gamma(n)+c^{\\prime}$ for all $x \\in \\Sigma^{n-n_{i}}$. Recall that this holds for all $n \\in N$ and that $N$ is the set of all lengths realized by $L$. Hence, if we define $c^{\\prime \\prime}:=\\max \\left\\{n_{1}, \\ldots, n_{e}\\right\\}$, then every word $w$ of length $n \\in N$ has Hamming distance at most $\\gamma(n)+c^{\\prime}+c^{\\prime \\prime}$ from a word in $L$. Therefore, $L$ is $(\\gamma(n)+c)$-trivial with $c=c^{\\prime}+c^{\\prime \\prime}$.\n\nLet us now turn to the case of a regular suffix-free language $L$. We again consider an rDFA $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ for $L$ whose nontransient SCCs have uniform period $g \\geqslant 1$. Since $L$ is suffixfree, $\\mathcal{B}$ has the property that no final state can be reached from a final state by a nonempty run.\n\nWe adapt the definition of a path description from Section 3.8. In the following, a path description is a sequence\n\n$$\nP=\\left(q_{k}, a_{k}, p_{k-1}\\right), C_{k-1}, \\ldots,\\left(q_{2}, a_{2}, p_{1}\\right), C_{1},\\left(q_{1}, a_{1}, p_{0}\\right), C_{0}, q_{0}\n$$\n\nwhere $C_{k-1}, \\ldots, C_{0}$ is a chain (from right to left) in the SCC-ordering of $\\mathcal{B}, p_{i}, q_{i} \\in C_{i}, q_{i+1} \\stackrel{a_{i+1}}{\\longleftarrow} p_{i}$ is a transition in $\\mathcal{B}$ for all $0 \\leqslant i \\leqslant k-1$, and $q_{k} \\in F$. Each path description defines a partial $r D F A \\mathcal{B}_{P}=\\left(Q_{P}, \\Sigma,\\left\\{q_{k}\\right\\}, \\delta_{P}, q_{0}\\right)$ by restricting $\\mathcal{B}$ to the state set $Q_{P}=\\bigcup_{i=0}^{k-1} C_{i} \\cup\\left\\{q_{k}\\right\\}$, restricting the transitions of $\\mathcal{B}$ to internal transitions from the SCCs $C_{i}$ and the transitions $q_{i+1} \\stackrel{a_{i+1}}{\\longleftarrow} p_{i}$, and declaring $q_{k}$ to be the only final state. This rDFA is partial since for every state $p$ and every symbol $a \\in \\Sigma$ there exists at most one transition $q \\stackrel{a}{\\longleftarrow} p$ in $\\mathcal{B}_{P}$. Since the number of path descriptions $P$ is finite and $\\mathrm{L}(\\mathcal{B})=\\bigcup_{P} \\mathrm{~L}\\left(\\mathcal{B}_{P}\\right)$, we can fix a single path description $P$ and provide a sliding window tester for $\\mathrm{L}\\left(\\mathcal{B}_{P}\\right)$ (we again use Lemma 5.16 here).\n\nFrom now on, we fix a path description $P$ as in (16). The acceptance sets $\\operatorname{Acc}_{P}(q)$ are defined with respect to the restricted automaton $\\mathcal{B}_{P}$. If all $C_{i}$ are transient, then $\\mathrm{L}\\left(\\mathcal{B}_{P}\\right)$ is a singleton and we can use a trivial sliding window tester with space complexity $O(1)$. Now, assume the contrary and let $0 \\leqslant e \\leqslant k-1$ be maximal such that $C_{e}$ is nontransient.\n\nLEMMA 5.18. There exist numbers $r_{0}, \\ldots, r_{k-1}, s_{0}, \\ldots, s_{e} \\in \\mathbb{N}$ such that the following holds:\n(i) For all $e+1 \\leqslant i \\leqslant k$, the set $\\operatorname{Acc}_{P}\\left(q_{i}\\right)$ is a singleton.\n(ii) For all $0 \\leqslant i \\leqslant k-1$, every run from $q_{i}$ to $q_{i+1}$ has length $r_{i}(\\bmod g)$.\n(iii) For all $0 \\leqslant i \\leqslant e, \\operatorname{Acc}_{P}\\left(q_{i}\\right)={ }_{s_{i}} \\sum_{j=i}^{k-1} r_{j}+g \\mathbb{N}$.\n\nPROOF. Point (i) follows immediately from the definition of transient SCCs. Let us now show (ii) and (iii). Let $0 \\leqslant i \\leqslant k-1$ and let $N_{i}$ be the set of lengths of runs of the form $q_{i+1} \\stackrel{a_{(i+1}}{\\longleftarrow} p_{i} \\stackrel{w}{\\longleftarrow} q_{i}$ in $\\mathcal{B}_{P}$. If $C_{i}$ is transient, then $N_{i}=\\{1\\}$. Otherwise, by Lemma 3.18 there exist a number $r_{i} \\in \\mathbb{N}$ and a cofinite set $D_{i} \\subseteq \\mathbb{N}$ such that $N_{i}=r_{i}+g D_{i}$. We can summarize both cases by saying that there exist a number $r_{i} \\in \\mathbb{N}$ and a set $D_{i} \\subseteq \\mathbb{N}$ which is either cofinite or $D_{i}=\\{0\\}$ such that $N_{i}=r_{i}+g D_{i}$. This implies point (ii). Moreover, the acceptance sets in $\\mathcal{B}_{P}$ satisfy\n\n$$\n\\operatorname{Acc}_{P}\\left(q_{i}\\right)=\\sum_{j=i}^{k-1} N_{j}=\\sum_{j=i}^{k-1}\\left(r_{j}+g D_{j}\\right)=\\sum_{j=i}^{k-1} r_{j}+g \\sum_{j=i}^{k-1} D_{j}\n$$\n\nFor all $0 \\leqslant i \\leqslant e$ we get $\\operatorname{Acc}_{P}\\left(q_{i}\\right)={ }_{s_{i}} \\sum_{j=i}^{k-1} r_{j}+g \\mathbb{N}$ for some threshold $s_{i} \\in \\mathbb{N}$ (note that a nonempty sum of cofinite subsets of $\\mathbb{N}$ is again cofinite).\n\nLet us fix the numbers $r_{i}$ and $s_{i}$ from Lemma 5.18. Let $p$ be a random prime with $\\Theta(\\log \\log n)$ bits. By choosing the $\\Theta$-constant large enough and using Lemma 4.9 (where we set $m=n, a=\\ell$ and $b=n$ ) we obtain for every $0 \\leqslant \\ell<n$ the inequality $\\operatorname{Pr}[\\ell \\equiv n(\\bmod p)] \\leqslant 1 / 3$. Define the threshold\n\n$$\ns=\\max \\left\\{k, \\sum_{j=0}^{k-1} r_{j}, s_{0}, \\ldots, s_{e}\\right\\}\n$$\n\nand for a word $w \\in \\Sigma^{*}$ define the function $\\ell_{w}: Q \\rightarrow \\mathbb{N} \\cup\\{\\infty\\}$ where\n\n$$\n\\ell_{w}(q)=\\inf \\left\\{\\ell \\in \\mathbb{N} \\mid \\delta_{P}\\left(\\operatorname{last}_{\\ell}(w), q\\right)=q_{k}\\right\\}\n$$\n\n(we set $\\inf \\emptyset=\\infty$ ). We now define an acceptance condition on $\\ell_{w}(q)$. If $n \\notin \\operatorname{Acc}_{P}\\left(q_{0}\\right)$, we always reject. Otherwise, we accept $w$ if and only if $\\ell_{w}\\left(q_{0}\\right) \\equiv n(\\bmod p)$.\n\nLEMMA 5.19. Let $n \\in \\operatorname{Acc}_{P}\\left(q_{0}\\right)$ be a window size with $n \\geqslant s+\\left|Q_{P}\\right|$ and $w \\in \\Sigma^{*}$ with $|w| \\geqslant n$. There exists a constant $c>0$ such that:\n(i) if last ${ }_{n}(w) \\in \\mathrm{L}\\left(\\mathcal{B}_{P}\\right)$, then $w$ is accepted (in the above sense) with probability 1 , and\n(ii) if $\\operatorname{pdist}\\left(\\operatorname{last}_{n}(w), \\mathrm{L}\\left(\\mathcal{B}_{P}\\right)\\right)>c$, then $w$ is rejected with probability at least $2 / 3$.\n\nPROOF. Consider a word $w \\in \\Sigma^{*}$ with $|w| \\geqslant n$. We consider several cases.\nCase 1: last ${ }_{n}(w) \\in \\mathrm{L}\\left(\\mathcal{B}_{P}\\right)$. Since $\\mathrm{L}\\left(\\mathcal{B}_{P}\\right) \\subseteq L$ is suffix-free, we have $\\ell_{w}\\left(q_{0}\\right) \\equiv n(\\bmod p)$ and $w$ is accepted with probability 1 , which shows statement (i) from the lemma.\n\nCase 2: last ${ }_{n}(w) \\notin \\mathrm{L}\\left(\\mathcal{B}_{P}\\right)$. We then have $\\ell_{w}\\left(q_{0}\\right) \\neq n$, which yields the following two subcases.\nCase 2.1: $\\ell_{w}\\left(q_{0}\\right)<n$. Then, by the choice of $p$ we have $\\ell_{w}\\left(q_{0}\\right) \\not \\equiv n(\\bmod p)$ with probability at least $2 / 3$. Hence, $w$ is rejected with probability at least $2 / 3$.\n\nCase 2.2: $\\ell_{w}\\left(q_{0}\\right)>n$. We will show that this implies $\\operatorname{pdist}\\left(\\operatorname{last}_{n}(w), \\mathrm{L}\\left(\\mathcal{B}_{P}\\right)\\right) \\leqslant c$ for a constant c. For this $c$, statement (ii) from the lemma then holds: if $\\operatorname{pdist}\\left(\\operatorname{last}_{n}(w), \\mathrm{L}\\left(\\mathcal{B}_{P}\\right)\\right)>c$, we must have $\\ell_{w}\\left(q_{0}\\right)<n$, which by Case 2.1 implies that $w$ is rejected with probability at least $2 / 3$.\n\nLet $\\pi$ be the run of $\\mathcal{B}_{P}$ on last $_{n}(w)$ starting from the initial state, and let its SCC-factorization be $\\pi=\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{0} \\pi_{0}$. We have $|\\pi|=n$. Since $\\ell_{w}\\left(q_{0}\\right)>n$, the run $\\pi$ can be strictly extended to a run to $q_{k}$ and hence we must have $m<k$. For all $0 \\leqslant i \\leqslant m$, the run $\\pi_{i}$ is an internal run in the SCC $C_{i}$ from $q_{i}$ to $p_{i}$. For all $0 \\leqslant i \\leqslant m-1$ we have $\\tau_{i}=q_{i+1} a_{i+1} p_{i}$ and $\\left|\\tau_{i} \\pi_{i}\\right| \\equiv r_{i}(\\bmod g)$ by point (ii) from Lemma 5.18. We claim that there exists an index $0 \\leqslant i_{0} \\leqslant m$ such that the following three properties hold:\n\n1. $q_{i_{0}}$ is nontransient,\n2. $\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}} \\pi_{i_{0}}\\right| \\geqslant s$,\n3. $\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}+1} \\pi_{i_{0}+1}\\right| \\leqslant s+m$\n(note that $\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}+1} \\pi_{i_{0}+1}\\right|=0$ is possible).\nIndeed, let $0 \\leqslant i \\leqslant m$ be the smallest integer such that $q_{i}$ is nontransient (recall that $n \\geqslant\\left|Q_{P}\\right|$ and hence $\\pi$ must traverse a nontransient SCC). Then, the run $\\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{0} \\pi_{0}$ only passes transient states except for its last state $q_{i}$ and hence its length is bounded by $\\left|Q_{P}\\right|$. Therefore, we have\n\n$$\n\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i} \\pi_{i}\\right|=n-\\left|\\tau_{i-1} \\pi_{i-1} \\cdots \\tau_{0} \\pi_{0}\\right| \\geqslant n-\\left|Q_{P}\\right| \\geqslant s\n$$\n\nHence, there exists $i$ satisfying properties (1) and (2) (with $i_{0}$ replaced by $i$ ). Let $0 \\leqslant i_{0} \\leqslant m$ be the largest integer satisfying properties (1) and (2). We show that property (3) holds for $i_{0}$.\n\nIf the run $\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}+1} \\pi_{i_{0}+1}$ only passes transient states, then its length is bounded by $m-i_{0} \\leqslant s+m$, and we are done. Otherwise, let $i_{0}+1 \\leqslant j \\leqslant m$ be the smallest integer such that $q_{j}$ is nontransient. The run $\\tau_{j-1} \\pi_{j-1} \\cdots \\tau_{i_{0}+1} \\pi_{i_{0}+1}$ only passes transient states except for its last state $q_{j}$ and therefore it has length $j-i_{0}-1$. By maximality of $i_{0}$, we have $\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{j} \\pi_{j}\\right|<s$ and hence property (3) holds:\n\n$$\n\\begin{aligned}\n\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}+1} \\pi_{i_{0}+1}\\right| & =\\left|\\pi_{m} \\cdots \\tau_{j} \\pi_{j}\\right|+\\left|\\tau_{j-1} \\pi_{j-1} \\cdots \\tau_{i_{0}+1} \\pi_{i_{0}+1}\\right| \\\\\n& <s+j-i_{0} \\leqslant s+m\n\\end{aligned}\n$$\n\nIn the rest of the proof let $0 \\leqslant i_{0} \\leqslant m$ be the above index satisfying properties (1)-(3). Since $q_{i_{0}}$ is nontransient, we have $i_{0} \\leqslant e$ and therefore\n\n$$\n\\operatorname{Acc}_{P}\\left(q_{i_{0}}\\right)={ }_{s} \\sum_{j=i_{0}}^{k-1} r_{j}+g \\mathbb{N}\n$$\n\nby Lemma 5.18(iii) and $s \\geqslant s_{i_{0}}$. We claim that\n\n$$\n\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}} \\pi_{i_{0}}\\right| \\in \\operatorname{Acc}_{P}\\left(q_{i_{0}}\\right)\n$$\n\nSince $n \\geqslant s$ and $n \\in \\operatorname{Acc}_{P}\\left(q_{0}\\right)={ }_{s} \\sum_{j=0}^{k-1} r_{j}+g \\mathbb{N}$ we have $n \\in \\sum_{j=0}^{k-1} r_{j}+g \\mathbb{N}$. This implies\n\n$$\n\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}} \\pi_{i_{0}}\\right|=n-\\left|\\tau_{i_{0}-1} \\pi_{i_{0}-1} \\cdots \\tau_{0} \\pi_{0}\\right| \\equiv n-\\sum_{j=0}^{i_{0}-1} r_{j} \\equiv \\sum_{j=i_{0}}^{k-1} r_{j} \\quad(\\bmod g)\n$$\n\nIn addition, we have $\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}} \\pi_{i_{0}}\\right| \\geqslant s$ by property (2). Since $s \\geqslant \\sum_{j=i_{0}}^{k-1} r_{j}$, we get\n\n$$\n\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}} \\pi_{i_{0}}\\right| \\in \\sum_{j=i_{0}}^{k-1} r_{j}+g \\mathbb{N}\n$$\n\nFinally, we obtain (18) from (17).\nBy Lemma 5.9 and (18), there is an accepting run $\\pi^{\\prime}$ from $q_{i_{0}}$ which $t$-simulates the internal run $\\pi_{i_{0}}$ and has length $\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}} \\pi_{i_{0}}\\right|$. Here, $t$ is a constant only depending on $\\mathcal{B}$. The prefix distance between the runs $\\pi=\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{0} \\pi_{0}$ and $\\pi^{\\prime} \\tau_{i_{0}-1} \\pi_{i_{0}-1} \\cdots \\tau_{0} \\pi_{0}$ is at most $t$ in case $i_{0}=m$, and at most\n\n$$\n\\begin{aligned}\n\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}}\\right|+t & =\\left|\\pi_{m} \\tau_{m-1} \\pi_{m-1} \\cdots \\tau_{i_{0}+1} \\pi_{i_{0}+1}\\right|+1+t \\\\\n& \\leqslant 1+s+m+t=: c\n\\end{aligned}\n$$\n\nin case $i_{0}<m$ due to property (3): Hence, the prefix distance between last ${ }_{n}(w)$ and $\\mathrm{L}\\left(\\mathcal{B}_{P}\\right)$ is bounded by the constant $c$. As explained before, statement (ii) of the lemma then holds.\n\nPROOF OF THEOREM 5.4. Let $n \\in \\mathbb{N}$ be the window size. By the previous discussion, it suffices to give a randomized sliding window tester (with the properties stated in Theorem 5.4) for a fixed partial automaton $\\mathcal{B}_{P}$. Assume $n \\geqslant s+|Q|$, otherwise a trivial tester can be used. If $n \\notin \\operatorname{Acc}_{P}\\left(q_{0}\\right)$, the tester always rejects. Otherwise, the tester picks a random prime $p$ with $\\Theta(\\log \\log n)$ bits and maintains $\\ell_{w}(q) \\bmod p$ for all $q \\in Q_{P}$, where $w$ is the stream read so far, which requires $O(\\log \\log n)$ bits. When a symbol $a \\in \\Sigma$ is read, we can update $\\ell_{w a}$ using $\\ell_{w}$ : If $q=q_{k}$, then $\\ell_{w a}(q)=0$, otherwise $\\ell_{w a}(q)=1+\\ell_{w}\\left(\\delta_{P}(a, q)\\right) \\bmod p$ where $1+\\infty=\\infty$. The tester accepts if $\\ell_{w}\\left(q_{0}\\right) \\equiv n(\\bmod p)$. Lemma 5.19 guarantees that the tester is false-biased.\n\nNote that in contrast to the randomized sliding window algorithm from Section 4.4, the randomized sliding window tester from this section only uses the modulo counting technique; Bernoulli counters are not needed. As a consequence, the tester only has to make a random choice at the beginning (where the prime $p$ is chosen) before the first input symbol arrives. Then it continues deterministically.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 43,
      "text": "# 5.4 Lower bounds \n\nIn this section we prove our lower bounds. In Section 5.4.1 we will prove Theorem 5.5 and Theorem 5.8. Theorem 5.6 and Theorem 5.7 will be shown in Section 5.4.2.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 44,
      "text": "### 5.4.1 Regular nontrivial languages\n\nIn this section, we prove Theorem 5.5 and Theorem 5.8. For this, we first have to study regular trivial languages in more detail. We will also show a result of independent interest: every regular $o(n)$-trivial language $L$ is already trivial (i.e., $O(1)$-trivial); see Theorem 5.24.\n\nGiven $i, j \\geqslant 0$ and a word $w$ of length at least $i+j$ we define cut ${ }_{i, j}(w)=y$ such that $w=x y z$, $|x|=i$ and $|z|=j$. If $|w|<i+j$, then cut $i_{i, j}(w)$ is undefined. For a language $L$ we define the cut-language cut $i_{i, j}(L)=\\left\\{\\operatorname{cut}_{i, j}(w) \\mid w \\in L,|w| \\geqslant i+j\\right\\}$.\n\nLEMMA 5.20. If $L$ is regular, then there are finitely many languages $\\operatorname{cut}_{i, j}(L)$.\nPROOF. Let $\\mathcal{A}=\\left(Q, \\Sigma, q_{0}, \\delta, F\\right)$ be a DFA for $L$. Given $i, j \\geqslant 0$, let $I$ be the set of states reachable from $q_{0}$ via $i$ symbols and let $F^{\\prime}$ be the set of states from which $F$ can be reached via $j$ symbols. Then, the NFA $\\mathcal{A}_{i, j}=\\left(Q, \\Sigma, I, \\delta, F^{\\prime}\\right)$ recognizes $\\operatorname{cut}_{i, j}(L)$. Since there are at most $2^{2|Q|}$ such choices for $I$ and $F^{\\prime}$, the number of languages of the form $\\operatorname{cut}_{i, j}(L)$ must be finite.\n\nLEMMA 5.21. If $\\operatorname{cut}_{i, j}(L)$ is a length language for some $i, j \\geqslant 0$, then $L$ is trivial.\nPROOF. Assume that $\\operatorname{cut}_{i, j}(L)$ is a length language. Let $n \\in \\mathbb{N}$ such that $L \\cap \\Sigma^{n} \\neq \\emptyset$. We claim that $\\operatorname{dist}(w, L) \\leqslant i+j$ for all $w \\in \\Sigma^{n}$. If $n<i+j$ this is clear. So, assume that $n \\geqslant i+j$. Let $w \\in \\Sigma^{n}$ and $w^{\\prime} \\in L \\cap \\Sigma^{n}$. Then, cut $_{i, j}\\left(w^{\\prime}\\right) \\in \\operatorname{cut}_{i, j}(L)$ and hence also $\\operatorname{cut}_{i, j}(w) \\in \\operatorname{cut}_{i, j}(L)$. Therefore, there exist $x \\in \\Sigma^{i}$ and $z \\in \\Sigma^{j}$ such that $x \\operatorname{cut}_{i, j}(w) z \\in L$ satisfies $\\operatorname{dist}\\left(w, x \\operatorname{cut}_{i, j}(w) z\\right) \\leqslant i+j$.\n\nThe restriction of a language $L$ to a set of lengths $N \\subseteq \\mathbb{N}$ is $\\left.L\\right|_{N}=\\{w \\in L| | w \\mid \\in N\\}$. A language $L$ excludes a word $w$ as a factor if $w$ is not a factor of any word in $L$. A simple but important observation is that if $L$ excludes $w$ as a factor and $v$ contains $k$ disjoint occurrences of $w$, then $\\operatorname{dist}(v, L) \\geqslant k$ : If we change at most $k-1$ many symbols in $v$, then the resulting word $v^{\\prime}$ must still contain $w$ as a factor and hence $v^{\\prime} \\notin L$.\n\nLEMMA 5.22. Let $L$ be regular. If for all $i, j \\geqslant 0$, cut $_{i, j}(L)$ is not a length language, then there exists an arithmetic progression $N=d+e \\mathbb{N}$ such that the restriction $\\left.L\\right|_{N}$ is infinite and excludes a factor.\n\nPROOF. First notice that $\\operatorname{cut}_{i, j}(L)$ determines $\\operatorname{cut}_{i+1, j}(L)$ and $\\operatorname{cut}_{i, j+1}(L)$ : we have $\\operatorname{cut}_{i+1, j}(L)=$ $\\operatorname{cut}_{1,0}\\left(\\operatorname{cut}_{i, j}(L)\\right)$ and similarly for $\\operatorname{cut}_{i, j+1}(L)$. Since the number of cut-languages $\\operatorname{cut}_{i, j}(L)$ is finite by Lemma 5.20, there exist numbers $i \\geqslant 0$ and $d>0$ such that $\\operatorname{cut}_{i, 0}(L)=\\operatorname{cut}_{i+d, 0}(L)$. Hence, we have $\\operatorname{cut}_{i, j}(L)=\\operatorname{cut}_{i+d, j}(L)$ for all $j \\geqslant 0$. By the same argument, there exist numbers $j \\geqslant 0$ and $e>0$ such that $\\operatorname{cut}_{i, j}(L)=\\operatorname{cut}_{i, j+e}(L)=\\operatorname{cut}_{i+d, j}(L)=\\operatorname{cut}_{i+d, j+e}(L)$, which implies $\\operatorname{cut}_{i, j}(L)=\\operatorname{cut}_{i, j+h}(L)=\\operatorname{cut}_{i+h, j}(L)=\\operatorname{cut}_{i+h, j+h}(L)$ for some $h>0$ (we can take $h=e d$ ). This implies that $\\operatorname{cut}_{i, j}(L)$ is closed under removing prefixes and suffixes of length $h$.\n\nBy assumption cut ${ }_{i, j}(L)$ is not a length language, i.e., there exist words $y^{\\prime} \\in \\operatorname{cut}_{i, j}(L)$ and $y \\notin \\operatorname{cut}_{i, j}(L)$ of the same length $k$. Let $N=\\{k+i+j+h n \\mid n \\in \\mathbb{N}\\}$. For any $n \\in \\mathbb{N}$ the restriction $\\left.L\\right|_{N}$ contains a word of length $k+i+j+h n$ because $y^{\\prime} \\in \\operatorname{cut}_{i, j}(L)=\\operatorname{cut}_{i+h n, j}(L)$. This proves that $\\left.L\\right|_{N}$ is infinite.\n\nLet $u$ be an arbitrary word which contains for every remainder $0 \\leqslant r \\leqslant h-1$ an occurrence of $y$ as a factor starting at a position which is congruent to $r \\bmod h$ (these occurrences do not\n\nhave to be disjoint). We claim that $\\left.L\\right|_{N}$ excludes $a^{i} u a^{j}$ as a factor where $a$ is an arbitrary symbol. Assume that there exists a word $w \\in\\left.L\\right|_{N}$ which contains $a^{i} u a^{j}$ as a factor. Then, cut ${ }_{i, j}(w)$ contains $u$ as a factor, has length $k+h n$ for some $n \\geqslant 0$, and belongs to $\\operatorname{cut}_{i, j}(L)$. Therefore, $\\operatorname{cut}_{i, j}(w)$ also contains $h$ many occurrences of $y$, one per remainder $0 \\leqslant r \\leqslant h-1$. Consider the occurrence of $y$ in $\\operatorname{cut}_{i, j}(w)$ which starts at a position that is divisible by $h$, i.e., we can factorize $\\operatorname{cut}_{i, j}(w)=x y z$ such that $|x|$ is a multiple of $h$. Since $\\left|\\operatorname{cut}_{i, j}(w)\\right|=k+h n$ and $|y|=k$, then $|z|$ is also a multiple of $h$. Therefore, $y \\in \\operatorname{cut}_{(+|x|, j+|z|}(L)=\\operatorname{cut}_{i, j}(L)$, which is a contradiction.\n\nLEMMA 5.23. If $L \\in \\operatorname{Reg} \\backslash$ Triv then there are a restriction $\\left.L\\right|_{N}$ that excludes some factor $w_{f}$ and words $x, y, z$ such that $|y|>0$ and $x y^{*} z \\subseteq\\left.L\\right|_{N}$.\n\nPROOF. By Lemma 5.21, cut ${ }_{i, j}(L)$ is not a length language for all $i, j \\geqslant 0$. Let $N$ be the set of lengths from Lemma 5.22 such that $\\left.L\\right|_{N}$ is infinite and excludes some factor $w_{f}$. Since $N$ is an arithmetic progression, $\\left.L\\right|_{N}$ is regular. Let $\\mathcal{A}=\\left(Q, \\Sigma, q_{0}, \\delta, F\\right)$ be a DFA for $\\left.L\\right|_{N}$. Since $\\mathrm{L}(\\mathcal{A})$ is infinite, there must exist words $x, y, z$ such that $y \\neq \\varepsilon$ and for $\\delta\\left(q_{0}, x\\right)=q$ we have $\\delta(q, y)=q$ and $\\delta(q, z) \\in F$.\n\nBefore we prove Theorem 5.5 let us first show the following result of independent interest:\nTHEOREM 5.24. For every regular language $L$, the following statements are equivalent:\n(i) $L$ is trivial.\n(ii) $L$ is o(n)-trivial.\n(iii) $\\operatorname{cut}_{i, j}(L)$ is a length language for some $i, j \\geqslant 0$.\n\nPROOF. If cut ${ }_{i, j}(L)$ is a length language then $L$ is trivial by Lemma 5.21, and thus also $o(n)$ trivial. It remains to show the direction (ii) to (iii). Assume that $L$ is $o(n)$-trivial. If (iii) would not hold then some infinite restriction $\\left.L\\right|_{N}$ of $L$ excludes a factor $w_{f}$ by Lemma 5.22. Hence, if $n \\in N$ is a length with $\\left.L\\right|_{N} \\cap \\Sigma^{n} \\neq \\emptyset$, then any word $v$ of length $n$ which contains at least $\\left\\lfloor n /\\left|w_{f}\\right|\\right\\rfloor$ many disjoint occurrences of $w_{f}$, has distance $\\operatorname{dist}(v, L) \\geqslant\\left\\lfloor n /\\left|w_{f}\\right|\\right\\rfloor$ to $L$. Then, $L$ is not $o(n)$-trivial, which is a contradiction.\n\nPROOF OF THEOREM 5.5. We will prove the two lower bounds in Theorem 5.5 for the more general class of nondeterministic and co-nondeterministic sliding window testers. A nondeterministic sliding window tester for a language $L$ and window size $n \\in \\mathbb{N}$ with Hamming gap $y(n)$ is a nondeterministic finite automaton $\\mathcal{P}_{n}$ such that for all input words $w \\in \\Sigma^{*}$ we have the following (recall from Section 2.2 that a successful run is a run from an initial state to a final state):\n\n- If last $_{n}(w) \\in L$, then there is at least one successful run of $\\mathcal{P}_{n}$ on $w$.\n- If $\\operatorname{dist}\\left(\\operatorname{last}_{n}(w), L\\right)>\\gamma(n)$, then there is no successful run of $\\mathcal{P}_{n}$ on $w$.\n\nIn contrast, $\\mathcal{P}_{n}$ is co-nondeterministic if for all $w \\in \\Sigma^{*}$ we have:\n\n- If last $_{n}(w) \\in L$, then all runs of $\\mathcal{P}_{n}$ on $w$ that start in an initial state are successful.\n- If $\\operatorname{dist}\\left(\\operatorname{last}_{n}(w), L\\right)>y(n)$, then there is a nonsuccessful run of $\\mathcal{P}_{n}$ on $w$ that starts in an initial state.\n\nThe space complexity of $\\mathcal{P}_{n}$ is $\\log \\left|\\mathcal{P}_{n}\\right|$. Clearly, every true-biased (resp., false-biased) sliding window tester is a nondeterministic (resp., co-nondeterministic) one.\n\nAssume that $L \\in \\operatorname{Reg} \\backslash$ Triv. We will prove an $\\log n-O(1)$ lower bound for nondeterministic sliding window testers, and hence also for true-biased and deterministic sliding window testers. By the power set construction one can transform a co-nondeterministic sliding window tester with $m$ memory states into an equivalent nondeterministic (and in fact, even deterministic) sliding window tester with $2^{m}$ memory states. Hence, an $\\log n-O(1)$ lower bound for nondeterministic sliding window testers immediately yields an $\\log (\\log n-O(1)) \\geqslant \\log \\log n-O(1)$ lower bound for co-nondeterministic sliding window testers, and hence also for false-biased sliding window testers.\n\nBy Lemma 5.23 there are a restriction $\\left.L\\right|_{N}$ that excludes some factor $w_{f}$ and words $x, y, z$ such that $|y|>0$ and $x y^{*} z \\subseteq\\left.L\\right|_{N}$. Let $c=\\left|w_{f}\\right|>0$ and choose $0<e<1 / c$. Moreover, let $d=|x z|$ and $e=|y|>0$, which satisfy $d+e \\mathbb{N} \\subseteq N$. Recall that every word $v$ that contains $k$ disjoint occurrences of $w_{f}$ has Hamming distance at least $k$ from any word in $\\left.L\\right|_{N}$.\n\nFix a window size $n \\in N$ and consider a nondeterministic sliding window tester $\\mathcal{P}_{n}$ for $L$ and window size $n$ with Hamming gap en. Define for $k \\geqslant 0$ the input stream\n\n$$\nv_{k}=w_{f}^{n} x y^{k} z\n$$\n\nLet $\\alpha=c e<1$. If $0 \\leqslant k \\leqslant\\left\\lfloor\\frac{(1-\\alpha) n-c-d}{e}\\right\\rfloor$, then the suffix of $v_{k}$ of length $n$ contains at least\n\n$$\n\\left\\lfloor\\frac{n-d-e k}{c}\\right\\rfloor \\geqslant\\left\\lfloor\\frac{n-d-(1-\\alpha) n+c+d}{c}\\right\\rfloor=\\left\\lfloor\\frac{\\alpha n+c}{c}\\right\\rfloor=\\lfloor e n+1\\rfloor>e n\n$$\n\nmany disjoint occurrences of $w_{f}$. Hence, $\\mathcal{P}_{n}$ has no successful run on an input stream $v_{k}$ with $0 \\leqslant k \\leqslant\\left\\lfloor\\frac{(1-\\alpha) n-c-d}{e}\\right\\rfloor$.\n\nAssume now that the window size $n$ satisfies $n \\geqslant d$ and $n \\equiv d(\\bmod e)$. Write $n=d+l e$ for some $l \\geqslant 0$. We have $l=\\frac{n-d}{e}>\\left\\lfloor\\frac{(1-\\alpha) n-c-d}{e}\\right\\rfloor$. The suffix of $v_{l}=w_{f}^{n} x y^{l} z$ of length $n$ is $x y^{l} z \\in\\left.L\\right|_{N}$. Therefore, there exists a successful run $\\pi$ of $\\mathcal{P}_{n}$ on $v_{l}$. Let $m$ be the number of states of $\\mathcal{P}_{n}$. For $0 \\leqslant i \\leqslant l$ let $p_{i}$ be the state on the run $\\pi$ that is reached after the prefix $w_{f}^{n} x y^{i}$ of $v_{l}$.\n\nIn order to deduce a contradiction, let us assume that $m \\leqslant\\left\\lfloor\\frac{(1-\\alpha) n-c-d}{e}\\right\\rfloor$. Then, there must exist numbers $i$ and $j$ with $0 \\leqslant i<j \\leqslant\\left\\lfloor\\frac{(1-\\alpha) n-c-d}{e}\\right\\rfloor$ such that $p_{i}=p_{j}=: p$. By cutting off cycles at $p$ from the run $\\pi$ and repeating this, we finally obtain a run of $\\mathcal{P}_{n}$ on an input stream $v_{k}=w_{f}^{n} x y^{k} z$ with $k \\leqslant\\left\\lfloor\\frac{(1-\\alpha) n-c-d}{e}\\right\\rfloor$. This run is still successful. But this contradicts our previous observation that $\\mathcal{P}_{n}$ has no successful run on an input stream $v_{k}$ with $0 \\leqslant k \\leqslant\\left\\lfloor\\frac{(1-\\alpha) n-c-d}{e}\\right\\rfloor$. We\n\nconclude that $\\mathcal{P}_{n}$ must have more than $\\left\\lfloor\\frac{(1-\\alpha) n-c-d}{e}\\right\\rfloor$ states. This implies\n\n$$\ns\\left(\\mathcal{P}_{n}\\right) \\geqslant \\log \\left(\\frac{(1-\\alpha) n-c-d}{e}\\right) \\geqslant \\log n-\\mathcal{O}(1)\n$$\n\nwhich proves the theorem.\nFor the proof of Theorem 5.8 we need a promise variant of the communication problem $\\mathrm{EQ}_{m}$ (see Section 4.5). With $\\mathrm{EQ}_{m}^{2}$ we denote the following promise communication problem: Alice's (resp., Bob's) input is a number $i \\in\\{1, \\ldots, m\\}$ (resp., $j \\in\\{1, \\ldots, m\\}$ ) and the promise is that $i \\geqslant j$ (i.e., we do not care about the output of the protocol in case $i<j$ ). If $i=j$ then Bob's final output must be 1 and if $i>j$ then Bob's final output must be 0 . We claim that the randomized one-way communication complexity of $\\mathrm{EQ}_{m}^{2}$ is $\\Omega(\\log \\log m)$.\n\nSince the randomized one-way communication complexity of $\\mathrm{EQ}_{m}$ is $\\Omega(\\log \\log m)$ by Theorem 4.11, it suffices to show that a randomized one-way protocol for $\\mathrm{EQ}_{m}^{2}$ with cost $c(m)$ and error probability $\\lambda$ yields a randomized one-way protocol for $\\mathrm{EQ}_{m}$ with $\\operatorname{cost} 2 c(m)$ and error probability $2 \\lambda$. This is easy to see: Assume that $P_{m}$ is a randomized one-way protocol for $\\mathrm{EQ}_{m}^{2}$ with $\\operatorname{cost} c(m)$. To get a randomized one-way protocol for $\\mathrm{EQ}_{m}$, Alice and Bob run two copies of $P_{m}$, one on inputs $i, j$ and the other one on inputs $m-i, m-j$ in parallel and with independent random bits. If both copies of $P_{m}$ yield output 1 then Bob returns 1. In all other cases, Bob returns 0 . If $i=j$ then this combined protocol returns 1 with probability at least $1-2 \\lambda$. On the other hand if $i>j$ or $i<j$ then the protocol returns 0 with probability at least $1-\\lambda$.\n\nPROOF OF LEMMA 5.8. Let $L$ be a language in $L \\in \\operatorname{Reg} \\backslash$ Triv. By Lemma 5.23 there are a restriction $\\left.L\\right|_{N}$ that excludes some factor $w_{f}$ and words $x, y, z$ such that $|y|>0$ and $x y^{*} z \\subseteq\\left.L\\right|_{N}$.\n\nLet $b=\\lfloor y\\rfloor$ and $c=|x z|$. Note in the following that $b, c$, and $\\left|w_{f}\\right|$ are constants. Fix a window size $n \\in N$ such that that $n-c$ is a multiple of $b$. Since $x y^{*} z \\subseteq\\left.L\\right|_{N}$, we have $n \\in N$. Define the word $v=u w_{f}^{k}$ where $k=\\lfloor y(n)\\rfloor+1>y(n)$ and $u$ is a word of length at most $b-1$ such that $|v|$ is a multiple of $b$. Let $l \\in \\mathbb{N}$ be such that $|v|=b \\cdot l$. Since $b$ divides $n-c$ we can write $n-c=(m \\cdot l+r) \\cdot b$ for $m \\in \\mathbb{N}$ and $0 \\leqslant r \\leqslant l-1$. Choose the constant $\\epsilon$ from the theorem statement such that $0<\\epsilon<\\frac{1}{\\left|w_{f}\\right|}$ and hence $\\gamma(n) \\leqslant \\epsilon n$. Assuming $n$ is large enough, we obtain $k=\\lfloor y(n)\\rfloor+1 \\leqslant \\frac{1}{\\left|w_{f}\\right|}(n-b-c)$, i.e., $b \\cdot l=|v| \\leqslant b+k \\cdot\\left|w_{f}\\right| \\leqslant n-c$ and hence $m \\geqslant 1$. Moreover, we have $l=|v| / b=\\Theta(\\gamma(n))$ and therefore\n\n$$\nm=\\frac{n-c}{b \\cdot l}-\\frac{r}{l}=\\Theta(n / \\gamma(n))\n$$\n\nConsider now a randomized sliding window tester $\\mathcal{P}_{n}$ with two-sided error for $L$ and window size $n$ with Hamming gap $\\gamma(n)$. We show that from $\\mathcal{P}_{n}$ we can obtain a randomized one-way protocol for $\\mathrm{EQ}_{m}^{2}$.\n\nAlice produces from her input $i \\in\\{1, \\ldots, m\\}$ the word $v x y^{r+(m-i) l}$. She then runs $\\mathcal{P}_{n}$ on this word and sends the memory state to Bob. Bob continues the run of the randomized sliding window tester, starting from the transferred memory state, with the input stream $y^{j l} z$, where\n\n$j \\in\\{1, \\ldots, m\\}$ is his input. He obtains the memory state reached after the input $v x y^{r+(m-i+j) l} z$. Finally, Bob outputs the answer given by the randomized sliding window tester. If $i=j$, then last $_{n}\\left(v x y^{r+(m-i+j) l} z\\right)=x y^{m \\cdot l+r} z \\in L$ and Bob accepts with high probability. On the other hand, if $i>j$, then last $_{n}\\left(v x y^{r+(m-i+j) l} z\\right)$ contains $v$ (recall that $|v|=b \\cdot l$ and hence $\\left|x y^{r+(m-i+j) l} z\\right| \\leqslant n-|v|$ ). Since $v$ contains strictly more than $\\gamma(n)$ disjoint occurrences of $w_{f}$ (an excluded factor of $\\left.L\\right|_{N}$ ), we have $\\operatorname{dist}\\left(\\operatorname{last}_{n}(w), L\\right)>\\gamma(n)$ (here it is important that $n \\in N$ ). Thus, Bob rejects with high probability. We therefore have a correct protocol for $\\mathrm{EQ}_{m}^{\\geq}$.\n\nSince the randomized one-way communication complexity of $\\mathrm{EQ}_{m}^{\\geq}$is $\\Omega(\\log \\log m)$ we finally obtain $s\\left(\\mathcal{P}_{n}\\right)=\\Omega(\\log \\log m)=\\Omega(\\log \\log (n / \\gamma(n)))$.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 45,
      "text": "# 5.4.2 Regular languages that are not finite unions of suffix-free and trivial languages \n\nIn this section, we show the lower bounds from Theorem 5.6 and Theorem 5.7. We start with the following observation.\n\nLEMMA 5.25. Every suffix-free language excludes a factor.\nPROOF. Let $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ be an rDFA for $L$. Since $L$ is suffix-free, we can assume that there exists a unique sink state $q_{\\text {fail }} \\notin F$, i.e., $\\delta\\left(a, q_{\\text {fail }}\\right)=q_{\\text {fail }}$ for all $a \\in \\Sigma$, which is reachable from all states. We construct a word $w_{f} \\in \\Sigma^{*}$ such that $\\delta\\left(p, w_{f}\\right)=q_{\\text {fail }}$ for all $p \\in Q$. Let $p_{1}, \\ldots, p_{m}$ be an enumeration of all states in $Q \\backslash\\left\\{q_{\\text {fail }}\\right\\}$. We then construct inductively words $w_{0}, w_{1}, \\ldots, w_{m} \\in \\Sigma^{*}$ such that for all $0 \\leqslant i \\leqslant m$ and $1 \\leqslant j \\leqslant i$ : $\\delta\\left(w_{i}, p_{j}\\right)=q_{\\text {fail }}$. We start with $w_{0}=\\varepsilon$. Assume that $w_{i}$ has been constructed for some $i<m$. There is a word $x$ such that that $\\delta\\left(x, \\delta\\left(w_{i}, p_{i+1}\\right)\\right)=q_{\\text {fail }}$. We set $w_{i+1}=x w_{i}$. Then, $\\delta\\left(w_{i+1}, p_{i+1}\\right)=\\delta\\left(x w_{i}, p_{i+1}\\right)=q_{\\text {fail }}$ and $\\delta\\left(w_{i+1}, p_{j}\\right)=\\delta\\left(x w_{i}, p_{j}\\right)=\\delta\\left(x, q_{\\text {fail }}\\right)=q_{\\text {fail }}$ for $1 \\leqslant j \\leqslant i$. Finally, we define $w_{f}=w_{m}$.\n\nLEMMA 5.26. Every regular language $L$ satisfies one of the following properties: ${ }^{10}$\n\n- $L \\in \\bigcup(\\mathbf{T r i v}, \\mathbf{S F})$\n- $L$ has a restriction $\\left.L\\right|_{N}$ which excludes some factor and contains $y^{*} z$ for some $y, z \\in \\Sigma^{*}$, $|y|>0$.\n\nPROOF. Let $\\mathcal{B}=\\left(Q, \\Sigma, F, \\delta, q_{0}\\right)$ be an rDFA for $L$. Let $\\mathcal{B}_{r}=\\left(Q, \\Sigma, F_{r}, \\delta, q_{0}\\right)$ where $F_{r}$ is the set of nontransient final states and $\\mathcal{B}_{q}=\\left(Q, \\Sigma,\\{q\\}, \\delta, q_{0}\\right)$ for $q \\in Q$. We can decompose $L$ as a union of $L_{r}=\\mathrm{L}\\left(\\mathcal{B}_{r}\\right)$ and all languages $\\mathrm{L}\\left(\\mathcal{B}_{q}\\right)$ over all transient states $q \\in F$. Notice that $\\mathrm{L}\\left(\\mathcal{B}_{q}\\right)$ is suffix-free for all transient $q \\in F$ since any run to $q$ cannot be prolonged to another run to $q$. If $L_{r}$ is trivial, then $L$ satisfies the first property. If $L_{r}$ is nontrivial, then by Lemma 5.21 and Lemma 5.22 there exists an arithmetic progression $N=a+b \\mathbb{N}$ such that $\\left.L_{r}\\right|_{N}$ is infinite and excludes some word $w \\in \\Sigma^{*}$ as a factor. Let $z \\in L_{r} \\|_{N}$ be any word. Since some nontransient final state $p$ is reached in\n\n$\\mathcal{B}_{r}$ on input $z$, there exists a word $y$ which leads from $p$ back to $p$. We can ensure that $|y|$ is a multiple of $b$ by replacing $y$ by $y^{b}$. Then, $y^{*} z \\subseteq L_{r}\\left.\\right|_{N} \\subseteq L \\|_{N}$. Furthermore, since each language $\\mathrm{L}\\left(\\mathcal{B}_{q}\\right)$ excludes some factor $w_{q}$ by Lemma 5.25, the language $\\left.L\\right|_{N} \\subseteq L_{r}\\left.\\right|_{N} \\cup \\bigcup_{q} \\mathrm{~L}\\left(\\mathcal{B}_{q}\\right)$ excludes any concatenation of $w$ and all words $w_{q}$ as a factor.\n\nPROOF OF THEOREM 5.6. Let $L \\in \\operatorname{Reg} \\backslash \\bigcup$ (Triv, SF). By Lemma 5.26, $L$ has a restriction $\\left.L\\right|_{N}$ which excludes some factor $w_{f}$ and contains $y^{*} z$ for some $y, z \\in \\Sigma^{*},|y|>0$. Let $c=\\left|w_{f}\\right| \\geqslant 1$. We choose $0<e<1 / c$. Let $d=|z|$ and $e=|y|$. Fix a window size $n \\in N$ and define for $k \\geqslant 0$ the input stream $v_{k}=w_{f}^{n} y^{k} z$.\n\nWe show the lower bound of $\\log n-O(1)$ for co-nondeterministic sliding window testers. Consider a co-nondeterministic sliding window tester $\\mathcal{P}_{n}$ for $L$ and window size $n$ with Hamming gap $\\epsilon n$. Let $\\alpha=c \\epsilon<1$ and $r=\\left\\lfloor\\frac{(1-\\alpha) n-c-d}{e}\\right\\rfloor$. If $0 \\leqslant k \\leqslant r$, then the suffix of $v_{k}$ of length $n$ contains at least\n\n$$\n\\left\\lfloor\\frac{n-d-e k}{c}\\right\\rfloor \\geqslant\\left\\lfloor\\frac{n-d-(1-\\alpha) n+c+d}{c}\\right\\rfloor=\\left\\lfloor\\frac{\\alpha n+c}{c}\\right\\rfloor=\\lfloor\\epsilon n+1\\rfloor>\\epsilon n\n$$\n\nmany disjoint occurrences of $w_{f}$. Hence, $\\mathcal{P}_{n}$ must reject the input stream $v_{k}$ for $0 \\leqslant k \\leqslant r$, i.e., there is a run of $\\mathcal{P}_{n}$ on $v_{k}$ that starts in an initial state and ends in a nonfinal state. Consider such a run $\\pi$ for $v_{r}$. For $0 \\leqslant i \\leqslant r$ let $p_{i}$ be the state in $\\pi$ that is reached after the prefix $w_{f}^{n} y^{i}$ of $v_{r}$. Let now $m$ be the number of states of $\\mathcal{P}_{n}$ and assume $m \\leqslant r$. There must exist numbers $i$ and $j$ with $0 \\leqslant i<j \\leqslant r$ such that $p_{i}=p_{j}=: p$. It follows that there is a $\\mathcal{P}_{n}$-run on $y^{j-i}$ that starts and ends in state $p$. Using that cycle we can now prolong the run $\\pi$, i.e., for all $t \\geqslant 0$ there is a run of $\\mathcal{P}_{n}$ on $v_{r+(j-i) \\cdot t}=w_{f}^{n} y^{r+(j-i) \\cdot t} z$ that starts in an initial state and ends in a nonfinal state.\n\nAssume now that the window size satisfies $n \\geqslant d$ and $n \\equiv d(\\bmod e)$. Write $n=d+l e$ for some $l \\geqslant 0$. Each $n$ with this property satisfies $n \\in N$ since the word $y^{l} z$ belongs to $\\left.L\\right|_{N}$. We have $l=\\frac{n-d}{e}>\\left\\lfloor\\frac{(1-\\alpha) n-c-d}{e}\\right\\rfloor=r$. For every $k \\geqslant l$, the suffix of $v_{k}=w_{f}^{n} y^{k} z$ of length $n$ is $y^{l} z \\in L$. Therefore, $\\mathcal{P}_{n}$ accepts $v_{k}$, i.e., for all $k \\geqslant l$, every run of $\\mathcal{P}_{n}$ on $v_{k}$ that starts in an initial state has to end in a final state. This contradicts our observation that for all $t \\geqslant 0$ there is a run of $\\mathcal{P}_{n}$ on $v_{r+(j-i) \\cdot t}$ that goes from an initial state to a nonfinal state. We conclude that $\\mathcal{P}_{n}$ has at least $r+1 \\geqslant \\frac{(1-\\alpha) n-c-d}{e}$ states. It follows that\n\n$$\ns\\left(\\mathcal{P}_{n}\\right) \\geqslant \\log \\left(\\frac{(1-\\alpha) n-c-d}{e}\\right) \\geqslant \\log n-O(1)\n$$\n\nThis proves the theorem.\nFinally, we prove Theorem 5.7.\nPROOF OF LEMMA 5.7. Let $L$ be a language in $\\operatorname{Reg} \\backslash \\bigcup$ (Triv, SF). By Lemma 5.26, $L$ has a restriction $\\left.L\\right|_{N}$ which excludes some factor $w_{f}$ and contains $y^{*} z$ for some $y, z \\in \\Sigma^{*},|y|>0$. Let $b=|y|$ and $c=|z|$. Note in the following that $b, c$, and $\\left|w_{f}\\right|$ are constants. Choose a window size $n \\geqslant c$ such that $n-c$ is a multiple of $b$. Since $y^{*} z \\subseteq\\left.L\\right|_{N}$, we have $n \\in N$. Define the\n\nword $v=u w_{f}^{k}$ where $k=\\lfloor y(n)\\rfloor+1>y(n)$ and $u$ is any word of length at most $b-1$ such that $|v|$ is a multiple of $b$. Let $l \\in \\mathbb{N}$ be such that $|v|=b \\cdot l$. Since $b$ divides $n-c$ we can write $n-c=(m \\cdot l+r) \\cdot b$ for $m \\in \\mathbb{N}$ and $0 \\leqslant r \\leqslant l-1$. Choose the constant $\\epsilon$ from the theorem statement such that $0<\\epsilon<\\frac{1}{\\left|w_{f}\\right|}$ and hence $y(n) \\leqslant \\epsilon n$. Assuming $n$ is large enough, we obtain $k=\\lfloor y(n)\\rfloor+1 \\leqslant \\frac{1}{\\left|w_{f}\\right|}(n-b-c)$, i.e., $b \\cdot l=|v| \\leqslant b+k \\cdot\\left|w_{f}\\right| \\leqslant n-c$ and hence $m \\geqslant 1$. Moreover, $l=|v| / b=\\Theta(y(n))$ ( $b$ and $\\left|w_{f}\\right|$ are constants) and therefore\n\n$$\nm=\\frac{n-c}{b \\cdot l}-\\frac{r}{l}=\\Theta(n / y(n))\n$$\n\nConsider now a randomized sliding window tester $\\mathcal{P}_{n}$ with two-sided error for $L$ and window size $n$ with Hamming gap $\\gamma(n)$. We show that from $\\mathcal{P}_{n}$ we can obtain a randomized one-way protocol for $\\mathrm{GT}_{m}$ (the greater-than-function on the interval $\\{1, \\ldots, m\\}$ ). Recall that $m \\geqslant 1$.\n\nAlice produces from her input $i \\in\\{1, \\ldots, m\\}$ the word $v y^{r+(m-i) i}$. She then runs $\\mathcal{P}_{n}$ on this word and sends the memory state to Bob. Bob continues the run of the randomized sliding window tester, starting from the transferred memory state, with the input stream $y^{j i} z$, where $j \\in\\{1, \\ldots, m\\}$ is his input. He obtains the memory state reached after the input $v y^{r+(m-i+j) i} z$. Finally, Bob outputs the negated answer given by the randomized sliding window tester. If $i \\leqslant j$, then last $_{n}\\left(v y^{r+(m-i+j) i} z\\right)=y^{m \\cdot l+r} z \\in L$ and Bob rejects with high probability. On the other hand, if $i>j$, then last $_{n}\\left(v y^{r+(m-i+j) i} z\\right)$ contains $v$ (recall that $|v|=b \\cdot l$ and hence $\\left|y^{r+(m-i+j) i} z\\right| \\leqslant n-|v|$ ). Since $v$ contains strictly more than $\\gamma(n)$ disjoint occurrences of $w_{f}$ (an excluded factor of $\\left.L\\right|_{N}$ ), we have $\\operatorname{dist}\\left(\\operatorname{last}_{n}(w), L\\right)>y(n)$ (here it is important that $n \\in N$ ). Thus, Bob accepts with high probability. We therefore have a correct protocol for $\\mathrm{GT}_{m}$.\n\nSince the randomized one-way communication complexity of $\\mathrm{GT}_{m}$ is $\\Omega(\\log m)$ (Theorem 4.11) we finally obtain $s\\left(\\mathcal{P}_{n}\\right)=\\Omega(\\log m)=\\Omega(\\log (n / \\gamma(n)))$.\n\nFor example, if $y(n) \\leqslant n^{c}$ for some $0<c<1$ then the lower bound in Theorem 5.7 is $\\Omega(\\log n)$. Note that if $L \\in \\bigcup$ (Triv, SF) then the lower bound of Theorem 5.7 does not hold anymore; this follows from Theorem 5.4.\n\nNote the similarity between the proofs of Theorem 5.7 and Theorem 5.8. The difference is that the word $x$ in the proof of Theorem 5.8 is not present in the proof of Theorem 5.7. The possibly non-empty $x$ in the proof of Theorem 5.8 only allows a reduction from $\\mathrm{EQ}_{m}^{\\times}$, whereas the empty $x$ in the proof of Theorem 5.7 allows a reduction from $\\mathrm{GT}_{m}$, which yields a larger lower bound.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 46,
      "text": "# 6. Conclusion and future work \n\nIn this paper we precisely determined the space complexity of regular languages in the sliding window model in the following settings: deterministic, randomized, deterministic property\n\ntesting, and randomized property testing. Two important restrictions that made our results possible but that also limit their applicability are the following:\n\n- Our sliding window algorithms only answer Boolean queries (does the window content belong to a language or not?). In many applications one wants to compute a certain nonBoolean value, e.g. the number of 1's in the window. This leads to the question whether our automata theoretic framework for sliding window problems can be extended to non-Boolean queries. Weighted automata [29] or cost register automata [4] could be a suitable framework for such an endeavor. Another interesting problem in this context is to maintain the distance (e.g. the Hamming distance or edit distance) between the sliding window and a fixed language $L$.\n- The incoming data values in our model are from a fixed finite alphabet. In many practical situations the incoming data values are from an infinite domain (at least on an abstract level) like the natural numbers or real numbers. Again, the question arises, whether our automata theoretic approach can be extended to such a setting. A popular automata model for words over an infinite alphabet (which are known as data words in this context) are register automata, which are also known as finite memory automata [65, 77]. In the context of sliding window streaming, deterministic register automata (DRA for short) [37] might be a good starting point. Benedikt, Ley, and Puppis [14] proved a Myhill-Nerode-like theorem that characterizes the class of data languages recognized by DRA for the case that the underlying relational structure $\\mathcal{A}$ on the data values is either $(D,=)$ (where $=$ denotes the equality relation) or $(D,<)$ for a strict linear order $<$. As a byproduct of this characterization, they obtain a minimal DRA for any DRA-recognizable language. This DRA is minimal in a very strong sense: at the same time it has the minimal number of states and the minimal number of registers among all equivalent DRA. Using these minimal DRA, one can define space-optimal streaming algorithms for data languages analogously to the case of words over a finite alphabet. This yields a starting point for studying space complexity classes for streaming algorithms over infinite domains.",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 47,
      "text": "# Acknowledgement. \n\nWe thank the two referees for their helpful comments. The first and third author were partly supported by the DFG project LO 748/13-1/2 (Streaming Automata Theory).",
      "tables": {},
      "images": {}
    },
    {
      "section_id": 48,
      "text": "## References\n\n[1] Charu C. Aggarwal, editor. Data Streams - Models and Algorithms, volume 31 of Advances in Database Systems. Springer, 2007. (2)\n[2] Noga Alon, Michael Krivelevich, Ilan Newman, and Mario Szegedy. Regular languages are testable with a constant number of queries. SIAM J. Comput. 30(6):1842-1862, 2000. (6, 29, 48, 50)\n[3] Noga Alon, Yossi Matias, and Mario Szegedy. The space complexity of approximating the frequency moments. J. Comput. Syst. Sci. 58(1):137-147, 1999. (5, 31)\n[4] Rajeev Alur, Loris D'Antoni, Jyotirmoy V. Deshmukh, Mukund Raghothaman, and Yifei Yuan. Regular functions and cost register automata. Proceedings of the 28th Annual ACM/IEEE Symposium on Logic in Computer Science, LICS 2013, pages 13-22. IEEE Computer Society, 2013. (71)\n[5] Rajeev Alur and P. Madhusudan. Adding nesting structure to words. J. ACM, 56(3):16:1-16:43, 2009. (8)\n[6] Antoine Amarilli, Louis Jachiet, and Charles Paperman. Dynamic membership for regular languages. Proceedings of the 48th International Colloquium on Automata, Languages, and Programming, ICALP 2021, volume 198 of LIPIcs, 116:1-116:17. Schloss Dagstuhl Leibniz-Zentrum f\u00fcr Informatik, 2021. (10)\n[7] Arvind Arasu and Gurmeet Singh Manku. Approximate counts and quantiles over sliding windows. Proceedings of the 23rd ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, PODS 2004, pages 286-296. ACM, 2004. (2, 9)\n[8] Brian Babcock, Mayur Datar, and Rajeev Motwani. Sampling from a moving window over streaming data. Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 2002, pages 633-634. ACM/SIAM, 2002. (9)\n[9] Brian Babcock, Mayur Datar, Rajeev Motwani, and Liadan O'Callaghan. Maintaining variance and k -medians over data stream windows. Proceedings of the 22nd ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, PODS 2003, pages 234-243. ACM, 2003. (9)\n[10] Ajesh Babu, Nutan Limaye, Jaikumar Radhakrishnan, and Girish Varma. Streaming algorithms for language recognition problems. Theor. Comput. Sci. 494:13-23, 2013. (9)\n[11] Corentin Barloy, Filip Murlak, and Charles Paperman. Stackless processing of streamed trees. Proceedings of the 40th ACM SIGMOD-SIGACT-SIGAI Symposium on Principles of Database Systems, PODS'21, pages 109-125. ACM, 2021. (9)\n[12] Ran Ben Basat, Gil Einziger, and Roy Friedman. Give me some slack: efficient network measurements. Theor. Comput. Sci. 791:87-108, 2019. (9)\n[13] Ran Ben-Basat, Gil Einziger, Roy Friedman, and Yaron Kassner. Efficient summing over sliding windows. Proceedings of the 15th Scandinavian Symposium and Workshops on Algorithm Theory, SWAT 2016, volume 53 of LIPIcs, 11:1-11:14. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2016. (8, 9)\n[14] Michael Benedikt, Clemens Ley, and Gabriele Puppis. What you must remember when processing data words. Proceedings of the 4th Alberto Mendelzon International Workshop on Foundations of Data Management, volume 619 of CEUR Workshop Proceedings. CEUR-WS.org, 2010. (71)\n[15] Jean Berstel. Transductions and context-free languages, volume 38 of Teubner Studienb\u00fccher: Informatik. Teubner, 1979. (10, 27)\n[16] Vladimir Braverman, Elena Grigorescu, Harry Lang, David P. Woodruff, and Samson Zhou. Nearly optimal distinct elements and heavy hitters on sliding windows. Proceedings of the 21st International Conference on Approximation Algorithms for Combinatorial Optimization Problems, and the 22nd International Conference on Randomization and Computation, APPROX/RANDOM 2018, volume 116 of LIPIcs, 7:1-7:22. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2018. (9)\n[17] Vladimir Braverman and Rafail Ostrovsky. Smooth histograms for sliding windows. Proceedings of the 48th Annual IEEE Symposium on Foundations of Computer Science, FOCS 2007, pages 283-293. IEEE Computer Society, 2007. (9)\n[18] Vladimir Braverman, Rafail Ostrovsky, and Carlo Zaniolo. Optimal sampling from sliding windows. J. Comput. Syst. Sci. 78(1):260-272, 2012. (9, 48)\n[19] Dany Breslauer and Zvi Galil. Real-time streaming string-matching. ACM Trans. Algorithms, 10(4):22:1-22:12, 2014. (9)\n[20] Nicolaas G. de Bruijn. A combinatorial problem. English. Nederl. Akad. Wetensch. Proc. 49(7):758-764, 1946. (13)\n[21] Rapha\u00ebl Clifford, Aliys Fontaine, Ely Porat, Benjamin Sach, and Tatiana Starikovskaya. Dictionary matching in a stream. Proceedings of the 23rd Annual European Symposium, ESA 2015, volume 9294 of Lecture Notes in Computer Science, pages 361-372. Springer, 2015. (9)\n[22] Rapha\u00ebl Clifford, Aliys Fontaine, Ely Porat, Benjamin Sach, and Tatiana Starikovskaya. The k-mismatch problem revisited. Proceedings of the 27th Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 2016, pages 2039-2052. SIAM, 2016. (9)\n\n[23] Rapha\u00ebl Clifford, Tomasz Kociumaka, and Ely Porat. The streaming k-mismatch problem. Proceedings of the 30th Annual ACM-SIAM Symposium on Discrete Algorithms, SODA 2019, pages 1106-1125. SIAM, 2019. [9]\n[24] Rapha\u00ebl Clifford and Tatiana Starikovskaya. Approximate Hamming distance in a stream. Proceedings of the 43rd International Colloquium on Automata, Languages, and Programming, ICALP 2016, volume 55 of LIPIcs, 20:1-20:14. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2016. [9]\n[25] Edith Cohen and Martin J. Strauss. Maintaining time-decaying stream aggregates. J. Algorithms, 59(1):19-36, 2006. [9]\n[26] Gianpaolo Cugola and Alessandro Margara. Processing flows of information: from data stream to complex event processing. ACM Computing Surveys, 44(3), 2012. [2]\n[27] Mayur Datar, Aristides Gionis, Piotr Indyk, and Rajeev Motwani. Maintaining stream statistics over sliding windows. SIAM J. Comput. 31(6):1794-1813, 2002. 2002. (2, 8, 9, 31)\n[28] Mayur Datar and Shan Muthukrishnan. Estimating rarity and similarity over data stream windows. Proceedings of the 10th European Symposium on Algorithms, ESA 2002, volume 2461 of Lecture Notes in Computer Science, pages 323-334. Springer, 2002. [9]\n[29] Manfred Droste, Werner Kuich, and Heiko Vogler. Handbook of Weighted Automata. Springer, 2009. (71)\n[30] Samuel Eilenberg. Automata, languages, and machines, volume A of Pure and applied mathematics. Academic Press, 1974. (11)\n[31] Funda Erg\u00fcn, Elena Grigorescu, Erfan Sadeqi Azer, and Samson Zhou. Periodicity in data streams with wildcards. Proceedings of the 13th International Computer Science Symposium in Russia, CSR 2018, volume 10846 of Lecture Notes in Computer Science, pages 90-105. Springer, 2018. [9]\n[32] Funda Erg\u00fcn, Elena Grigorescu, Erfan Sadeqi Azer, and Samson Zhou. Streaming periodicity with mismatches. Proceedings of Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques, APPROX/RANDOM 2017, volume 81 of LIPIcs, 42:1-42:21. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2017. [9]\n[33] Funda Erg\u00fcn, Hossein Jowhari, and Mert Saglam. Periodicity in streams. Proceeding of the 14th International Workshop on Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques, APPROX-RANDOM 2010, volume 6302 of Lecture Notes in Computer Science, pages 545-559. Springer, 2010. [9]\n[34] Joan Feigenbaum, Sampath Kannan, Martin Strauss, and Mahesh Viswanathan. Testing and spot-checking of data streams. Algorithmica, 34(1):67-80, 2002. [6]\n[35] Joan Feigenbaum, Sampath Kannan, and Jian Zhang. Computing diameter in the streaming and sliding-window models. Algorithmica, 41(1):25-41, 2005. 2005. (9)\n[36] Philippe Flajolet. Approximate counting: A detailed analysis. BIT, 25(1):113-134, 1985. (35)\n[37] Nissim Francez and Michael Kaminski. An algebraic characterization of deterministic regular languages over infinite alphabets. Theor. Comput. Sci. 306(1-3):155-175, 2003. (71)\n[38] Nathana\u00ebl Fran\u00e7ois, Fr\u00e9d\u00e9ric Magniez, Michel de Rougemont, and Olivier Serre. Streaming property testing of visibly pushdown languages. Proceedings of the 24th Annual European Symposium on Algorithms, ESA 2016, volume 57 of LIPIcs, 43:1-43:17. Schloss Dagstuhl Leibniz-Zentrum f\u00fcr Informatik, 2016. 2016. (6, 9)\n[39] Gudmund Skovbjerg Frandsen, Thore Husfeldt, Peter Bro Miltersen, Theis Rauhe, and S\u00f8ren Skyum. Dynamic algorithms for the Dyck languages. Proceedings of the 4th International Workshop on Algorithms and Data Structures, WADS '95, volume 955 of Lecture Notes in Computer Science, pages 98-108. Springer, 1995. [10]\n[40] Gudmund Skovbjerg Frandsen, Peter Bro Miltersen, and Sven Skyum. Dynamic word problems. J. ACM, 44(2):257-271, 1997. (10)\n[41] Moses Ganardi. Language recognition in the sliding window model. PhD thesis, University of Siegen, Germany, 2019. 2019. (7)\n[42] Moses Ganardi. Visibly pushdown languages over sliding windows. Proceedings of the 36th International Symposium on Theoretical Aspects of Computer Science, STACS 2019, volume 126 of LIPIcs, 29:1-29:17. Schloss Dagstuhl Leibniz-Zentrum f\u00fcr Informatik, 2019. [8]\n[43] Moses Ganardi, Danny Hucke, Daniel K\u00f6nig, Markus Lohrey, and Konstantinos Mamouras. Automata theory on sliding windows. Proceedings of the 35th Symposium on Theoretical Aspects of Computer Science, STACS 2018, volume 96 of LIPIcs, 31:1-31:14. Schloss Dagstuhl Leibniz-Zentrum f\u00fcr Informatik, 2018. 2018. (6, 7)\n[44] Moses Ganardi, Danny Hucke, and Markus Lohrey. Derandomization for sliding window algorithms with strict correctness ${ }^{\\prime}$. Theory Comput. Syst. 65(3):1-18, 2021. 2021. (8)\n[45] Moses Ganardi, Danny Hucke, and Markus Lohrey. Querying regular languages over sliding windows. Proceedings of the 36th IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science, FSTTCS 2016, volume 65 of LIPIcs, 18:1-18:14. Schloss Dagstuhl Leibniz-Zentrum f\u00fcr Informatik, 2016. 2016. (6)\n[46] Moses Ganardi, Danny Hucke, and Markus Lohrey. Randomized sliding window algorithms for regular languages. Proceedings of the 45th International Colloquium on Automata, Languages, and Programming, ICALP 2018, volume 107 of LIPIcs, 127:1-127:13. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2018. 2018. (6)\n\n[47] Moses Ganardi, Danny Hucke, Markus Lohrey, and Tatiana Starikovskaya. Sliding window property testing for regular languages. Proceedings of the 30th International Symposium on Algorithms and Computation, ISAAC 2019, volume 149 of LIPIcs, 6:1-6:13. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2019. (6)\n[48] Moses Ganardi, Louis Jachiet, Markus Lohrey, and Thomas Schwentick. Low-latency sliding window algorithms for formal languages. Proceedings of the 42nd IARCS Annual Conference on Foundations of Software Technology and Theoretical Computer Science, FSTTCS 2022, volume 250 of LIPIcs, 38:1-38:23. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2022. (9)\n[49] Moses Ganardi, Artur Je\u017c, and Markus Lohrey. Sliding windows over context-free languages. Proceedings of the 43rd International Symposium on Mathematical Foundations of Computer Science, MFCS 2018, volume 117 of LIPIcs, 15:1-15:15. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2018. (8)\n[50] Pawel Gawrychowski. Chrobak normal form revisited, with applications. Proceedings of the 16th International Conference on Implementation and Application of Automata, CIAA 2011, volume 6807 of Lecture Notes in Computer Science, pages 142-153. Springer, 2011. (45)\n[51] Pawel Gawrychowski and Artur Je\u017c.\nHyper-minimisation made efficient. Proceedings of the 34th International Symposium on Mathematical Foundations of Computer Science 2009, MFCS 2009, volume 5734 of Lecture Notes in Computer Science, pages 356-368. Springer, 2009. (26, 27)\n[52] Pawel Gawrychowski, Oleg Merkurev, Arseny M. Shur, and Przemyslaw Uzna\u0144ski. Tight tradeoffs for real-time approximation of longest palindromes in streams. Algorithmica, 81(9):3630-3654, 2019. (9)\n[53] Pawel Gawrychowski, Jakub Radoszewski, and Tatiana Starikovskaya. Quasi-periodicity in streams. Proceedings of the 30th Annual Symposium on Combinatorial Pattern Matching, CPM 2019, volume 128 of LIPIcs, 22:1-22:14. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2019. (9)\n[54] Pawel Gawrychowski and Tatiana Starikovskaya. Streaming dictionary matching with mismatches. Algorithmica, 84(4):896-916, 2022. (9)\n[55] Phillip B. Gibbons and Srikanta Tirthapura. Distributed streams algorithms for sliding windows. Theory Comput. Syst. 37(3):457-478, 2004. (9)\n[56] Lukasz Golab, David DeHaan, Erik D. Demaine, Alejandro L\u00f3pez-Ortiz, and J. Ian Munro. Identifying frequent items in sliding windows over on-line packet streams. Proceedings of the 3rd ACM SIGCOMM Internet Measurement Conference, IMC 2003, pages 173-178. ACM, 2003. (9)\n[57] Shay Golan, Tomasz Kociumaka, Tsvi Kopelowitz, and Ely Porat. The streaming k-mismatch problem: tradeoffs between space and total time. Proceedings of the 31st Annual Symposium on Combinatorial Pattern Matching, CPM 2020, volume 161 of LIPIcs, 15:1-15:15. Schloss Dagstuhl Leibniz-Zentrum f\u00fcr Informatik, 2020. (9)\n[58] Shay Golan, Tsvi Kopelowitz, and Ely Porat. Streaming pattern matching with d wildcards. Algorithmica, 81(5):1988-2015, 2019. (9)\n[59] Shay Golan, Tsvi Kopelowitz, and Ely Porat. Towards optimal approximate streaming pattern matching by matching multiple patterns in multiple streams. Proceedings of the 45th International Colloquium on Automata, Languages, and Programming, ICALP 2018, volume 107 of LIPIcs, 65:1-65:16. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2018. (9)\n[60] Shay Golan and Ely Porat. Real-time streaming multi-pattern search for constant alphabet. Proceedings of the 25th Annual European Symposium on Algorithms, ESA 2017, volume 87 of LIPIcs, 41:1-41:15. Schloss Dagstuhl Leibniz-Zentrum f\u00fcr Informatik, 2017. (9)\n[61] Oded Goldreich, Shafi Goldwasser, and Dana Ron. Property testing and its connection to learning and approximation. J. ACM, 45(4):653-750, 1998. (6)\n[62] John E. Hopcroft and Jeffrey D. Ullman. Introduction to Automata Theory, Languages and Computation. Addison-Wesley, 1979. (10)\n[63] Rahul Jain and Ashwin Nayak. The space complexity of recognizing well-parenthesized expressions in the streaming model: the index function revisited. IEEE Transactions on Information Theory, 60(10):6646-6668, October 2014. (9)\n[64] Galina Jir\u00e1skov\u00e1 and Peter Mlyn\u00e1rcik. Complement on prefix-free, suffix-free, and non-returning NFA languages. Proceedings of the 16th International Workshop on Descriptional Complexity of Formal Systems, DCFS 2014, volume 8614 of Lecture Notes in Computer Science, pages 222-233. Springer, 2014. (45)\n[65] Michael Kaminski and Nissim Francez. Finite-memory automata. Theor. Comput. Sci. 134(2):329-363, 1994. (71)\n[66] Tomasz Kociumaka, Ely Porat, and Tatiana Starikovskaya. Small-space and streaming pattern matching with k edits. Proceedings of the 62nd IEEE Annual Symposium on Foundations of Computer Science, FOCS 2021, pages 885-896. IEEE, 2021. (9)\n[67] Christian Konrad and Fr\u00e9d\u00e9ric Magniez. Validating XML documents in the streaming model with external memory. ACM Trans. Database Syst. 38(4):27:1-27:36, 2013. (9)\n[68] Dexter Kozen. Automata and computability. Undergraduate texts in computer science. Springer, 1997. (10)\n\n[69] Andreas Krebs, Nutan Limaye, and Srikanth Srinivasan. Streaming algorithms for recognizing nearly well-parenthesized expressions. Proceedings of the 36th International Symposium on Mathematical Foundations of Computer Science, MFCS 2011, volume 6907 of Lecture Notes in Computer Science, pages 412-423. Springer, 2011. [70]\n[70] Ilan Kremer, Noam Nisan, and Dana Ron. On randomized one-round communication complexity. Comput. Complex. 8(1):21-49, 1999. [71] Eyal Kushilevitz and Noam Nisan. Communication complexity. Cambridge University Press, 1997. $(40,41)$\n[72] Fr\u00e9d\u00e9ric Magniez, Claire Mathieu, and Ashwin Nayak. Recognizing well-parenthesized expressions in the streaming model. SIAM J. Comput. 43(6):1880-1905, 2014. [73] Oleg Merkurev and Arseny M. Shur. Searching long repeats in streams. Proceedings of the 30th Annual Symposium on Combinatorial Pattern Matching, CPM 2019, volume 128 of LIPIcs, 31:1-31:14. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2019. (9)\n[74] Oleg Merkurev and Arseny M. Shur. Searching runs in streams. Proceedings of the 26th International Symposium on String Processing and Information Retrieval, SPIRE 2019, volume 11811 of Lecture Notes in Computer Science, pages 203-220. Springer, 2019. [75] Michael Mitzenmacher and Eli Upfal. Probability and Computing: Randomization and Probabilistic Techniques in Algorithms and Data Analysis. Cambridge University Press, New York, NY, USA, 2nd edition, 2017. (32)\n[76] Robert H. Morris Sr. Counting large numbers of events in small registers. Commun. ACM, 21(10):840-842, 1978. [77] Frank Neven, Thomas Schwentick, and Victor Vianu. Finite state machines for strings over infinite alphabets. ACM Trans. Comput. Log. 5(3):403-435, 2004. [71]\n[78] Azaria Paz. Introduction to Probabilistic Automata (Computer Science and Applied Mathematics). Academic Press, Inc., Orlando, FL, USA, 1971. (31)\n[79] Jean-Eric Pin. Syntactic semigroups. Grzegorz Rozenberg and Arto Salomaa, editors, Handbook of Formal Languages, Volume 1: Word, Language, Grammar, pages 679-746. Springer, 1997. [80]\n[80] Benny Porat and Ely Porat. Exact and approximate pattern matching in the streaming model. Proceedings of the 50th Annual IEEE Symposium on Foundations of Computer Science, FOCS 2009, pages 315-323. IEEE Computer Society, 2009. [81]\n[81] Michael O. Rabin. Probabilistic automata. Inform. Control, 6(3):230-245, 1963. [82] Jakub Radoszewski and Tatiana Starikovskaya. Streaming $k$-mismatch with error correcting and applications. Information and Computation, 271:104513, 2020. [83] (9)\n[83] J. Barkley Rosser and Lowell Schoenfeld. Approximate formulas for some functions of prime numbers. Illinois J. Math. 6(1):64-94, 1962. (39)\n[84] Tim Roughgarden. Communication complexity (for algorithm designers). Found. Trends Theor. Comput. Sci. 11(3-4):217-404, 2016. (40, 44, 47)\n[85] Luc Segoufin and Victor Vianu. Validating streaming XML documents. Proceedings of the 21st ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, PODS 2002, pages 53-64. ACM, 2002. (9)\n[86] Tatiana Starikovskaya. Communication and streaming complexity of approximate pattern matching. Proceedings of the 28th Annual Symposium on Combinatorial Pattern Matching, CPM 2017, volume 78 of LIPIcs, 13:1-13:11. Schloss Dagstuhl - Leibniz-Zentrum f\u00fcr Informatik, 2017. [87] (9)\n[87] Howard Straubing. Finite semigroup varieties of the form $V \\times D$. J. Pure Appl. Algebra, 36:53-94, 1985. [88] Kanat Tangwongsan, Martin Hirzel, and Scott Schneider. Low-latency sliding-window aggregation in worst-case constant time. Proceedings of the 11th ACM International Conference on Distributed and Event-based Systems, DEBS 2017, pages 66-77. ACM, 2017. [89] Haopeng Zhang, Yanlei Diao, and Neil Immerman. On complexity and optimization of expensive queries in complex event processing. Proceedings of the International Conference on Management of Data, SIGMOD 2014, pages 217-228. ACM, 2014. [90]\n[4]",
      "tables": {},
      "images": {}
    }
  ],
  "id": "2402.13385v2",
  "authors": [
    "Moses Ganardi",
    "Danny Hucke",
    "Markus Lohrey",
    "Konstantinos Mamouras",
    "Tatiana Starikovskaya"
  ],
  "categories": [
    "cs.FL"
  ],
  "abstract": "We study the space complexity of the following problem: For a fixed regular\nlanguage $L$, we receive a stream of symbols and want to test membership of a\nsliding window of size $n$ in $L$. For deterministic streaming algorithms we\nprove a trichotomy theorem, namely that the (optimal) space complexity is\neither constant, logarithmic or linear, measured in the window size $n$.\nAdditionally, we provide natural language-theoretic characterizations of the\nspace classes. We then extend the results to randomized streaming algorithms\nand we show that in this setting, the space complexity of any regular language\nis either constant, doubly logarithmic, logarithmic or linear. Finally, we\nintroduce sliding window testers, which can distinguish whether a sliding\nwindow of size $n$ belongs to the language $L$ or has Hamming distance $>\n\\epsilon n$ to $L$. We prove that every regular language has a deterministic\n(resp., randomized) sliding window tester that requires only logarithmic\n(resp., constant) space.",
  "updated": "2025-03-05T09:23:17Z",
  "published": "2024-02-20T21:29:53Z"
}